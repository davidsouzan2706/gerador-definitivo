<!DOCTYPE html>
<html lang="pt-br">
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&family=Source+Serif+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🚀</text></svg>">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Roteiros Virais v3.9</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>

<style>
    /* ================================================================= */
    /* =================== ARQUITETURA DE DESIGN (THEME) ================= */
    /* ================================================================= */
    :root {
        --primary: #6366f1;
        --primary-dark: #4f46e5;
        --secondary: #8FBC8F;
        --accent: #228B22;
        --success: #10b981;
        --danger: #ef4444;
        --dark-bg: #f8fafc;
        --dark-surface: #ffffff;
        --dark-border: #e2e8f0;
        --dark-text-header: #1e293b;
        --dark-text-body: #334155;
        --dark-text-muted: #64748b;
        --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        --transition: all 0.2s ease-in-out;
    }

    .dark {
        --primary: #818cf8;
        --primary-dark: #6366f1;
        --secondary: #3CB371;
        --accent: #006400;
        --dark-bg: #0f172a;
        --dark-surface: #1e293b;
        --dark-border: #334155;
        --dark-text-header: #f1f5f9;
        --dark-text-body: #cbd5e1;
        --dark-text-muted: #94a3b8;
    }

    /* ================================================================= */
    /* ======================= ESTILOS GLOBAIS ======================= */
    /* ================================================================= */
    body { 
        font-family: 'Inter', sans-serif; 
        background-color: var(--dark-bg); 
        color: var(--dark-text-body); 
        transition: var(--transition); 
    }
    .container { 
        max-width: 1024px; 
        margin: 0 auto; 
    }
    h1, h2, h3, h4, h5, h6 { 
        color: var(--dark-text-header); 
    }

    /* ================================================================= */
    /* ======================= COMPONENTES DA UI ======================= */
    /* ================================================================= */

    /* --- Cards e Seções --- */
    .card { 
        background-color: var(--dark-surface); 
        border: 1px solid var(--dark-border); 
        border-radius: 12px; 
        box-shadow: var(--shadow); 
        padding: 1.5rem; 
        transition: var(--transition); 
    }
    .section-title { 
        position: relative; 
        padding-bottom: 0.75rem; 
        margin-bottom: 1.5rem; 
        border-bottom: 1px solid var(--dark-border); 
    }
    .section-title h2 { 
        font-size: 1.25rem; 
        font-weight: 700; 
    }
    .section-title::after { 
        content: ''; 
        position: absolute; 
        bottom: -1px; 
        left: 0; 
        width: 70px; 
        height: 2px; 
        background: var(--primary); 
        transition: var(--transition); 
    }

    /* --- Botões --- */
    .btn { 
        display: inline-flex; 
        align-items: center; 
        justify-content: center; 
        gap: 0.5rem; 
        padding: 0.65rem 1.25rem; 
        border-radius: 8px; 
        font-weight: 600; 
        cursor: pointer; 
        transition: var(--transition); 
        border: none; 
        white-space: nowrap; 
    }
    .btn-primary { 
        background-color: var(--primary); 
        color: white; 
    }
    .btn-primary:hover { 
        background-color: var(--primary-dark); 
        transform: translateY(-2px); 
    }
    .btn-secondary { 
        background-color: var(--secondary); 
        color: white; 
    }
    .btn-secondary:hover { 
        background-color: #7c3aed; 
    }
    .dark .btn-secondary:hover { 
        background-color: #9333ea; 
    }
    .btn-small { 
        padding: 0.5rem 1rem; 
        font-size: 0.875rem; 
    }

    /* --- Formulários e Inputs --- */
    .input-group { 
        margin-bottom: 1rem; 
    }
    .input-group label { 
        display: block; 
        margin-bottom: 0.5rem; 
        font-weight: 600; 
        font-size: 0.875rem; 
        color: var(--dark-text-header); 
    }
    .input-group input, .input-group select, .input-group textarea { 
        width: 100%; 
        padding: 0.75rem; 
        border-radius: 8px; 
        border: 1px solid var(--dark-border); 
        background: var(--dark-surface); 
        transition: var(--transition); 
        color: var(--dark-text-body); 
    }
    .input-group input::placeholder, .input-group textarea::placeholder { 
        color: var(--dark-text-muted); 
        opacity: 1; 
    }
    .input-group input:focus, .input-group select:focus, .input-group textarea:focus { 
        outline: none; 
        border-color: var(--primary); 
        box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); 
    }

    /* --- Botões de Rádio Personalizados --- */
    .radio-label {
        display: inline-flex;
        align-items: center;
        cursor: pointer;
        padding: 0.75rem 1.25rem;
        border-radius: 8px;
        border: 2px solid var(--dark-border);
        background-color: var(--dark-surface);
        transition: var(--transition);
    }
    .radio-label:hover {
        border-color: var(--secondary);
    }
    .radio-label input[type="radio"] {
        display: none;
    }
    .radio-label input[type="radio"]:checked + span {
        color: var(--primary);
        font-weight: 600;
    }
    .radio-label:has(input:checked) {
        border-color: var(--primary);
        background-color: color-mix(in srgb, var(--primary) 10%, transparent);
    }
    .radio-label.opacity-50 {
        cursor: not-allowed;
        color: var(--dark-text-muted);
    }
    
    /* --- Abas (Tabs) --- */
    .tab-button { 
        padding: 0.5rem 0.25rem; 
        margin-bottom: 0.5rem; 
        border-bottom: 3px solid transparent; 
        color: var(--dark-text-muted); 
        font-weight: 500; 
        transition: var(--transition); 
        background: none; 
        border-radius: 0; 
    }
    .tab-button:hover { 
        color: var(--primary); 
    }
    .tab-active { 
        border-bottom-color: var(--primary); 
        color: var(--primary); 
        font-weight: 600; 
    }
    .tab-pane.hidden { 
        display: none; 
    }

    /* --- Acordeão --- */
    .accordion-item { 
        border-bottom: 1px solid var(--dark-border); 
    }
    .accordion-header { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        padding: 1rem 1.5rem; 
        cursor: pointer; 
        transition: var(--transition); 
    }
    .accordion-header:hover { 
        background-color: color-mix(in srgb, var(--dark-surface) 95%, var(--dark-text-muted)); 
    }
    .header-title-group { 
        display: flex; 
        align-items: center; 
        gap: 0.75rem; 
        flex-grow: 1; 
    }
    .header-title-group h3 { 
        font-weight: 600; 
        font-size: 1.1rem; 
    }
    .header-title-group .text-xs { 
        color: var(--dark-text-muted); 
        font-size: 0.75rem; 
        white-space: nowrap; 
    }
    .header-actions-group { 
        display: flex; 
        align-items: center; 
        gap: 1rem; 
    }
    .header-buttons { 
        display: flex; 
        align-items: center; 
        gap: 0.75rem; 
    }
    .header-buttons button { 
        background: none; 
        border: none; 
        padding: 0.25rem; 
        color: var(--dark-text-muted); 
        cursor: pointer; 
        transition: var(--transition); 
    }
    .header-buttons button:hover { 
        color: var(--primary); 
    }
    .accordion-arrow { 
        transition: transform 0.3s; 
        transform-origin: center; 
    }
    .accordion-arrow.open { 
        transform: rotate(180deg); 
    }
    .accordion-body { 
        padding: 0 1.5rem 1.5rem 1.5rem; 
        display: none; 
    }
    .accordion-body.open { 
        display: block; 
    }
    .accordion-body > div > div { 
        padding-top: 1.5rem; 
        padding-bottom: 1.5rem; 
        border-top: 1px dashed var(--dark-border); 
    }
    .accordion-body > div > div:first-child { 
        border-top: none; 
        padding-top: 0; 
    }
    .accordion-body h5 { 
        font-size: 1rem; 
        font-weight: 700; 
        color: var(--dark-text-header); 
        margin-bottom: 0.25rem; 
    }
    .accordion-body p.text-xs { 
        font-size: 0.8rem; 
        color: var(--dark-text-muted); 
        margin-bottom: 1rem; 
    }

    /* --- Elementos de Feedback --- */
    .toast { 
        position: fixed; 
        bottom: 1.5rem; 
        right: 1.5rem; 
        background-color: var(--dark-surface); 
        color: var(--dark-text-header); 
        padding: 1rem 1.5rem; 
        border-radius: 8px; 
        box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1); 
        z-index: 1000; 
        opacity: 0; 
        transform: translateY(100%); 
        transition: all 0.4s cubic-bezier(0.21, 1.05, 0.51, 1.04); 
        border-left: 4px solid var(--primary); 
    }
    .toast.show { 
        opacity: 1; 
        transform: translateY(0); 
    }
    .loading-spinner { 
        width: 24px; 
        height: 24px; 
        border: 3px solid color-mix(in srgb, var(--primary) 20%, transparent); 
        border-top-color: var(--primary); 
        border-radius: 50%; 
        animation: spin 1s linear infinite; 
    }
    @keyframes spin { 
        to { transform: rotate(360deg); } 
    }
    .progress-bar { 
        height: 8px; 
        background: var(--dark-border); 
        border-radius: 4px; 
        overflow: hidden; 
    }
    .progress-fill { 
        height: 100%; 
        background: var(--primary); 
        border-radius: 4px; 
        transition: width 0.3s ease; 
    }
    
    /* --- Popover da Estrutura Específica --- */
    .popover-bg {
        background-color: var(--dark-bg);
    }

    /* --- Ícone de Troca de Tema --- */
    .theme-toggle {
        background-color: transparent;
        border: none;
        padding: 0.5rem;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }
    .theme-toggle:hover {
        background-color: color-mix(in srgb, var(--dark-border) 50%, transparent);
    }

    /* ================================================================= */
    /* ================== ESTILOS DE CONTEÚDO GERADO =================== */
    /* ================================================================= */
    .generated-content-wrapper, .generated-output-box, .emotional-map-item, .prompt-item { 
        background-color: color-mix(in srgb, var(--dark-bg) 50%, var(--dark-surface)); 
        border-left: 4px solid var(--primary); 
        padding: 1rem 1.5rem; 
        border-radius: 8px; 
        line-height: 1.6; 
    }
    .prompt-item { 
        border-left-color: var(--secondary); 
    }
    .generated-content-wrapper { 
        margin-bottom: 1.5rem; 
    }
    .generated-output-box .output-subtitle { 
        font-size: 1rem; 
        font-weight: 700; 
        color: var(--dark-text-header); 
        margin-bottom: 0.75rem; 
        padding-bottom: 0.5rem; 
        border-bottom: 1px dashed var(--dark-border); 
    }
    .generated-output-box .output-content-block { 
        margin-bottom: 1.5rem; 
    }
    .generated-output-box .thumbnail-idea { 
        margin-bottom: 1rem; 
    }
    .generated-output-box .thumbnail-idea h4 { 
        font-weight: 600; 
        font-size: 0.9rem; 
    }
    .generated-output-box .thumbnail-idea p { 
        font-size: 0.85rem; 
        color: var(--dark-text-muted); 
    }
    .soundtrack-list { 
        list-style-type: disc; 
        padding-left: 1.5rem; 
    }
    .paragraph-preview { 
        font-style: italic; 
        color: var(--dark-text-muted); 
        margin-bottom: 0.75rem; 
        font-size: 0.9rem; 
        border-bottom: 1px dashed var(--dark-border); 
        padding-bottom: 0.75rem; 
    }
    .analysis-tags, .prompt-header { 
        display: flex; 
        flex-wrap: wrap; 
        gap: 0.5rem; 
    }
    .prompt-header { 
        margin-bottom: 0.75rem; 
        padding-bottom: 0.75rem; 
        border-bottom: 1px dashed var(--dark-border); 
    }
    .tag { 
        display: inline-flex; 
        align-items: center; 
        padding: 0.25rem 0.75rem; 
        border-radius: 9999px; 
        font-size: 0.75rem; 
        font-weight: 600; 
    }
    .tag-emotion { 
        background-color: color-mix(in srgb, var(--primary) 20%, transparent); 
        color: var(--primary); 
    }
    .tag-pace { 
        background-color: color-mix(in srgb, var(--secondary) 20%, transparent); 
        color: var(--secondary); 
    }
    .tag-scene { 
        background-color: color-mix(in srgb, var(--accent) 20%, transparent); 
        color: var(--accent); 
    }
    .tag-time { 
        background-color: color-mix(in srgb, var(--dark-text-muted) 20%, transparent); 
        color: var(--dark-text-muted); 
    }

    /* ================================================================= */
    /* =================== MÓDULOS DE ANÁLISE E AJUDA ================== */
    /* ================================================================= */

    /* --- Análise de Retenção --- */
    .retention-paragraph-live { 
        position: relative; 
        padding: 0.5rem; 
        border-radius: 6px; 
        transition: background-color 0.3s; 
        cursor: default; 
    }
    .retention-green { 
        background-color: color-mix(in srgb, var(--success) 10%, transparent); 
    }
    .retention-yellow { 
        background-color: color-mix(in srgb, #f59e0b 15%, transparent); 
    }
    .retention-red { 
        background-color: color-mix(in srgb, var(--danger) 15%, transparent); 
    }
    .retention-tooltip { 
        position: absolute; 
        bottom: 100%; 
        left: 0; 
        transform: translateY(-10px); 
        background-color: var(--dark-surface); 
        color: var(--dark-text-body); 
        padding: 0.75rem; 
        border-radius: 8px; 
        box-shadow: 0 4px 12px rgba(0,0,0,0.2); 
        width: 90%; 
        z-index: 10; 
        font-size: 0.8rem; 
        border: 1px solid var(--dark-border); 
        opacity: 0; 
        visibility: hidden; 
        transition: opacity 0.3s, transform 0.3s; 
    }
    .retention-tooltip .optimize-btn { 
        display: block; 
        width: 100%; 
        margin-top: 0.75rem; 
        padding: 0.5rem; 
        border: none; 
        background-color: var(--primary); 
        color: white; 
        font-weight: 600; 
        border-radius: 6px; 
        cursor: pointer; 
        transition: var(--transition); 
    }
    .retention-tooltip .optimize-btn:hover { 
        background-color: var(--primary-dark); 
    }
    .retention-paragraph-live:hover .retention-tooltip { 
        opacity: 1; 
        visibility: visible; 
        transform: translateY(-5px); 
    }
    .highlight-group { 
        outline: 2px solid var(--primary); 
        outline-offset: 2px; 
        box-shadow: 0 0 15px color-mix(in srgb, var(--primary) 30%, transparent); 
    }

    /* --- Feedback Visual de Alteração ("Pisca") --- */
    @keyframes fade-out-highlight {
      from {
        background-color: color-mix(in srgb, #f59e0b 25%, transparent);
        outline: 2px solid #f59e0b;
      }
      to {
        background-color: transparent;
        outline: 2px solid transparent;
      }
    }
    .highlight-change {
      animation: fade-out-highlight 20s ease-out forwards;
      border-radius: 4px;
      outline-offset: 2px;
    }

/* --- Tooltips de Ajuda (Unificado) --- */
.tooltip-container {
    position: relative;
    display: inline-flex;
}
.tooltip-container .tooltip-text {
    visibility: hidden;
    opacity: 0;
    width: 300px;
    /* MUDANÇA DE COR: Agora usa o mesmo fundo do popover */
    background-color: var(--dark-bg); 
    color: var(--dark-text-header);
    text-align: left;
    border-radius: 8px;
    padding: 1rem;
    position: absolute;
    z-index: 1001;
    bottom: 115%; 
    left: 50%;
    transform: translateX(-50%);
    box-shadow: var(--shadow);
    border: 1px solid var(--dark-border);
    transition: opacity 0.3s;
    pointer-events: none;
    /* MUDANÇA DE FONTE: 1rem é o equivalente a 16px */
    font-size: 1rem; 
    font-weight: 500;
    line-height: 1.6;
}
.tooltip-container .tooltip-text::after {
    content: "";
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    /* MUDANÇA DE COR DA SETA: Para combinar com o novo fundo */
    border-color: var(--dark-bg) transparent transparent transparent;
}
.tooltip-container:hover .tooltip-text {
    visibility: visible;
    opacity: 1;
}
.tooltip-container .tooltip-text strong {
    font-weight: 700;
    color: var(--primary);
}
    
    /* Estilos específicos para o ícone (i), se necessário */
    .help-icon {
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: var(--dark-border);
        color: var(--dark-text-muted);
        font-size: 11px;
        font-weight: 700;
        cursor: help;
        margin-left: 8px;
        transition: var(--transition);
    }
    .help-icon:hover {
        background-color: var(--primary);
        color: white;
    }

    /* ========================================================== */
    /* =================== Menu de Variação de Tom =================== */
    /* ========================================================== */
    #tone-variation-menu {
        position: absolute;
        background-color: var(--dark-bg);
        border: 1px solid var(--dark-border);
        border-radius: 8px;
        box-shadow: var(--shadow);
        padding: 0.5rem;
        z-index: 1002;
        display: flex;
        gap: 0.5rem;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, transform 0.2s;
        transform: translateY(10px);
    }
    #tone-variation-menu.visible {
        opacity: 1;
        visibility: visible;
        transform: translateY(0);
    }
    #tone-variation-menu button {
        background-color: transparent;
        border: none;
        color: var(--primary);
        padding: 0.5rem 0.75rem;
        cursor: pointer;
        border-radius: 6px;
        font-weight: 600;
        white-space: nowrap;
    }
    #tone-variation-menu button:hover {
        background-color: var(--dark-border);
        color: var(--dark-text-header);
    }


/* ========================================================== */
/* =================== ESTILOS PARA IMPRESSÃO (PDF) =================== */
/* ========================================================== */
@media print {
    /* Esconde tudo que não queremos no PDF */
    body > *:not(#print-container) {
        display: none !important;
    }
    
    /* Garante que o container de impressão ocupe todo o espaço */
    #print-container {
        display: block !important;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        color: #000;
        background-color: #fff !important;
    }
    
    /* ESTILOS DE FONTE PARA O DOCUMENTO INTEIRO */
    #print-container, .print-section-content {
        font-family: 'Roboto', serif; /* Fonte padrão para o corpo */
        font-size: 12pt;
        line-height: 1.5;
    }

    h1, .print-section-title {
        font-family: 'Source Serif Pro', sans-serif; /* Fonte para títulos */
    }
    
    .print-section {
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 1px solid #ccc;
        page-break-inside: avoid;
    }
    
    h1 {
        text-align: center;
        font-size: 22pt;
        margin-bottom: 24px;
    }

    .print-section-title {
        font-size: 16pt;
        font-weight: bold;
        margin-bottom: 12px;
        color: #333;
    }
    
    /* Configuração específica para o roteiro (corpo do texto) */
    .print-section-content pre {
        white-space: pre-wrap;
        font-family: 'Roboto', serif; /* Garante a fonte aqui também */
        font-size: 12pt;
        margin: 0;
        padding: 0;
    }

    .print-section-content ul {
        list-style-position: inside;
        padding-left: 10px;
    }

    /* Remove estilos visuais que não queremos no PDF */
    .generated-output-box, .thumbnail-idea, .card {
        background: none !important;
        border: none !important;
        box-shadow: none !important;
        color: #000 !important;
    }
    
    /* Força que o texto de todos os elementos seja preto */
    .print-section-content p, .print-section-content li, .print-section-content h4, .print-section-content strong {
        color: #000 !important;
    }
}

</style>



</head>



<body class="bg-gray-50 dark:bg-gray-900">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow-sm">
            <div class="container mx-auto px-4 py-4 flex justify-between items-center">
                <h1 class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">
                    <i class="fas fa-video mr-2"></i>Gerador de Roteiros Virais v3.9
                </h1>
                <div class="flex items-center space-x-4">
                    <button id="darkModeToggle" class="theme-toggle">
                        <i id="moonIcon" class="fas fa-moon text-gray-700 dark:text-gray-300"></i>
                        <i id="sunIcon" class="fas fa-sun text-gray-700 dark:text-gray-300 hidden"></i>
                    </button>
                </div>
            </div>
        </header>

        <!-- Progress Bar -->
        <div class="container mx-auto px-4 py-4">
            <div class="mb-6">
                <div class="flex justify-between text-sm mb-1">
                    <span>Progresso do Projeto</span>
                    <span id="progressText">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <main class="container mx-auto px-4 pb-20">
            <!-- Estratégia Section -->


<!-- SEÇÃO 0: INSPIRAÇÃO (BRAINSTORM) -->
<section id="inspirationSection" class="mb-12">
    <div class="text-center mb-8">
        <h2 class="text-2xl font-bold mb-2">Precisa de Inspiração?</h2>
        <p class="text-gray-600 dark:text-gray-400">Comece por aqui. Descreva o nicho ou os temas gerais do seu canal e deixe a IA sugerir vídeos com alto potencial.</p>
    </div>
    <div class="card">
        <div class="input-group">
            <label for="nicheDescription">Nicho do Canal ou Temas de Interesse:</label>
            <textarea id="nicheDescription" rows="4" placeholder="Ex: Arqueologia Bíblica e mistérios não resolvidos; Finanças pessoais para jovens cristãos; Análise de sermões e teologia prática..."></textarea>
        </div>
<div class="text-center mt-6 flex flex-wrap justify-center gap-4">
    <!-- Botão Antigo (Generalista) -->
    <button id="generateIdeasBtn" data-action="generateIdeas" class="btn btn-primary">
        <i class="fas fa-lightbulb mr-2"></i>Gerar Ideias (Geral)
    </button>
    <!-- Nosso Novo Botão (Especialista) -->
    <button id="unravelEnigmasBtn" data-action="unravelEnigmas" class="btn btn-secondary">
        <i class="fas fa-scroll mr-2"></i>Desvendar Enigmas (Bíblico)
    </button>
</div>
        
        <!-- Container para a saída das ideias -->
        <div id="ideasOutput" class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- As ideias geradas pela IA aparecerão aqui -->
        </div>
    </div>
</section>

<!-- Linha divisória -->
<div class="relative flex py-5 items-center">
    <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
    <span class="flex-shrink mx-4 text-gray-400 dark:text-gray-500 font-semibold">OU COMECE DIRETAMENTE AQUI</span>
    <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
</div>


<!-- ================================================================= -->
<!-- SUBSTITUA SUA SEÇÃO 1 INTEIRA POR ESTE BLOCO CORRIGIDO -->
<!-- ================================================================= -->

<!-- SEÇÃO 1: DEFINIR ESTRATÉGIA -->
<section class="mb-10">
    <div class="section-title">
        <h2 class="text-xl font-bold">1. Definir Estratégia</h2>
    </div>
    
    <!-- A navegação das abas (continua a mesma) -->
    <div class="border-b border-gray-200 dark:border-gray-700 mb-6">
        <nav id="inputTabsNav" class="-mb-px flex flex-wrap md:flex-nowrap space-x-6" aria-label="Tabs">
            <button data-tab="input-tab-basico" class="tab-button tab-active">
                <i class="fas fa-info-circle mr-2"></i> Básico
            </button>
            <button data-tab="input-tab-estrategia" class="tab-button">
                <i class="fas fa-lightbulb mr-2"></i> Estratégia Narrativa
            </button>
            <button data-tab="input-tab-tecnicos" class="tab-button">
                <i class="fas fa-sliders-h mr-2"></i> Detalhes Técnicos
            </button>
        </nav>
    </div>
    
    <!-- O conteúdo das abas (AGORA CORRIGIDO) -->
    <div id="inputTabContent" class="card">
        
        <!-- Aba 1: Básico -->

<div id="input-tab-basico" class="tab-pane active-pane">
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="input-group"><label for="channelName">Nome do Canal:</label><input type="text" id="channelName" value="The Biblical Unveiling"></div>
        <div class="input-group"><label for="videoTheme">Tema do Vídeo:</label><input type="text" id="videoTheme" placeholder="Ex: A Arca da Aliança Foi Encontrada?"></div>
        <div class="input-group"><label for="languageSelect">Idioma do Roteiro:</label><select id="languageSelect"><option value="pt-br">Português (Brasil)</option><option value="en" selected>English</option></select></div>
        
        <!-- Duração e Ritmo agora ficam lado a lado -->
        <div class="input-group">
            <label for="videoDuration">Duração Desejada:</label>
            <select id="videoDuration">
                <option value="">-- Selecione --</option>
                <option value="short">Curto (~1-3 min)</option>
                <option value="medium">Médio (~4-7 min)</option>
                <option value="long">Longo (~8-12 min)</option>
            </select>
        </div>

        <div class="input-group">
    <label for="visualPacing">Ritmo Visual (Cenas):</label>
    <select id="visualPacing">
        <option value="" selected>-- Selecione --</option> <!-- Adicionado 'selected' aqui -->
        <option value="dinamico">Dinâmico (3-8s)</option> <!-- Removido 'selected' daqui -->
        <option value="normal">Normal (8-15s)</option>
        <option value="contemplativo">Contemplativo (15-25s)</option>
    </select>
</div>

        <div class="input-group md:col-span-2"><label for="videoDescription">Descrição do Vídeo (para inspiração):</label><textarea id="videoDescription" rows="4" placeholder="Cole uma breve descrição do vídeo aqui..."></textarea></div>
    </div>
</div>


<!-- Aba 2: Estratégia Narrativa (COM NOVOS POPOVERS E TOOLTIPS) -->
<div id="input-tab-estrategia" class="tab-pane hidden">
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">

        <!-- Bloco 1: O Que e Para Quem -->
        <div class="input-group md:col-span-2"><label for="targetAudience">Público-Alvo:</label><input type="text" id="targetAudience" placeholder="Quem você quer que assista? Descreva seu espectador ideal."></div>
        <div class="input-group md:col-span-2"><label for="narrativeTheme">3. Tema Principal:</label><input type="text" id="narrativeTheme" placeholder="Qual é a 'grande ideia'? A única mensagem que seu público deve lembrar?"></div>
        <div class="input-group md:col-span-2"><label for="centralQuestion">Pergunta Central (Opcional):</label><textarea id="centralQuestion" rows="2" placeholder="Qual mistério ou 'coceira mental' você vai criar e prometer resolver?"></textarea></div>

        <!-- Bloco 2: A Estrutura e a Alma -->
        <!-- MUDANÇA AQUI: Adicionamos a estrutura para o novo popover -->
        <div class="relative group">
            <div class="input-group">
                <label for="narrativeGoal">1. Objetivo da Narrativa:</label>
                <select id="narrativeGoal">
                    <option value="storytelling">Storytelling</option>
                    <option value="storyselling">Storyselling</option>
                </select>
            </div>
            <div id="goalPopover" class="card popover-bg absolute bottom-full left-0 mb-2 w-[400px] opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 z-20 pointer-events-none group-hover:pointer-events-auto">
                <h4 class="font-bold text-lg text-indigo-400 mb-2"></h4>
                <p class="text-sm leading-relaxed"></p>
            </div>
        </div>
        <div class="relative group">
            <div class="input-group">
                <div class="flex items-center gap-2 mb-2"><label for="narrativeStructure">2. Estrutura Específica:</label></div>
                <select id="narrativeStructure"></select>
            </div>
            <div id="structurePopover" class="card popover-bg absolute bottom-full left-0 mb-2 w-[400px] opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 z-20 pointer-events-none group-hover:pointer-events-auto">
                <h4 id="popoverTitle" class="font-bold text-lg text-indigo-400 mb-2"></h4>
                <p id="popoverDescription" class="text-sm leading-relaxed"></p>
            </div>
        </div>
        <div class="input-group md:col-span-2"><label for="emotionalHook">História Pessoal / Gancho Emocional (Opcional):
            <span class="help-icon tooltip-container">i
                <span class="tooltip-text">
                    <strong>Dê uma alma para sua história.</strong> Este é o 'fio condutor' humano. A IA usará esta pequena história para conectar os grandes fatos a uma experiência pessoal, tornando o roteiro muito mais impactante.
                </span>
            </span>
        </label><textarea id="emotionalHook" rows="3" placeholder="Qual rosto humano dará alma à sua história? Ex: a jornada de um indivíduo, uma memória pessoal, um arquétipo (o azarão, o mentor)..."></textarea></div>

        <!-- Bloco 3: O Tom e a Jornada -->
        <div class="input-group"><label for="narrativeTone">4. Tom da Narração:
            <!-- NOVO TOOLTIP AQUI -->
            <span class="help-icon tooltip-container">i
                <span class="tooltip-text">
                    <strong>Define o "sentimento" do vídeo.</strong> É sério e sombrio? Leve e inspirador? A escolha do tom guia a música, o ritmo e o estilo da narração.
                </span>
            </span>
        </label><select id="narrativeTone"><option value="inspirador" selected>Inspirador</option><option value="serio">Sério</option><option value="emocional">Emocional</option></select></div>
        <div class="input-group"><label for="narrativeVoice">5. Voz do Narrador:
            <!-- NOVO TOOLTIP AQUI -->
            <span class="help-icon tooltip-container">i
                <span class="tooltip-text">
                    <strong>Imagine que seu canal é uma pessoa.</strong> Como ela falaria? Um mentor sábio? Um amigo entusiasmado? Um investigador misterioso? Isso define a personalidade da sua narração.
                </span>
            </span>
        </label><input type="text" id="narrativeVoice" placeholder="Ex: Confiante, Engraçada, Misteriosa..."></div>
        <div class="input-group md:col-span-2"><label for="emotionalArc">Arco Emocional Desejado (Opcional):
            <!-- NOVO TOOLTIP AQUI -->
            <span class="help-icon tooltip-container">i
                <span class="tooltip-text">
                    <strong>Qual jornada de sentimentos você quer que o espectador percorra?</strong> Começa com curiosidade, vai para a tensão e termina em alívio? Planejar isso cria um vídeo muito mais impactante.
                </span>
            </span>
        </label><textarea id="emotionalArc" rows="2" placeholder="Ex: Curiosidade -> Tensão -> Surpresa -> Alívio"></textarea></div>
        <div class="input-group md:col-span-2"><label for="shockingEndingHook">O Desfecho Chocante (Hook Opcional):
            <span class="help-icon tooltip-container">i
                <span class="tooltip-text">
                    <strong>A técnica do 'loop aberto' reverso.</strong> Coloque a frase final e mais chocante da sua história aqui. A IA usará esta frase como a PRIMEIRA linha do vídeo, criando um mistério instantâneo que prende o espectador até o final.
                </span>
            </span>
        </label><input type="text" id="shockingEndingHook" placeholder="Ex: ...e foi por isso que a Arca nunca deveria ser encontrada."></div>

    </div>
</div>

<!-- Aba 3: Detalhes Técnicos (COM TOOLTIPS CORRIGIDOS) -->
<div id="input-tab-tecnicos" class="tab-pane hidden">
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="input-group"><label for="languageStyle">Estilo de Linguagem:</label><select id="languageStyle"><option value="inspirador" selected>Inspirador</option><option value="formal">Formal</option></select></div>
        <div class="input-group"><label for="videoObjective">Objetivo do Vídeo:</label><select id="videoObjective"><option value="informar" selected>Informar</option><option value="emocionar">Emocionar</option></select></div>
        <div class="input-group"><label for="speakingPace">Ritmo de Fala:</label><select id="speakingPace"><option value="moderate" selected>Moderado</option><option value="slow">Lento</option><option value="fast">Rápido</option></select></div>
        <div class="input-group md:col-span-2">
            <label for="researchData">Fontes e Dados de Pesquisa (Opcional):
                <!-- A CORREÇÃO ESTÁ AQUI: Adicionamos a classe 'tooltip-container' -->
                <span class="help-icon tooltip-container">i
                    <span class="tooltip-text">
                        <strong>Aumente a credibilidade.</strong> Cole aqui nomes, datas, estatísticas, ou citações. A IA irá tecer essas informações na narrativa.
                        Ex: 'Fonte: Estudo de Harvard; Dr. João da Silva, especialista...'
                    </span>
                </span>
            </label>
            <textarea id="researchData" rows="4" placeholder="Para aumentar a credibilidade, cole aqui dados, fontes, nomes e links que a IA deve citar e contextualizar no roteiro. Ex: Fonte: Atlas da Violência 2023; Maria da Silva, coordenadora do Instituto Odara..."></textarea>
        </div>
        <div class="input-group md:col-span-2"><label for="imageDescriptionEngine">Motor de Descrição de Imagem:</label><textarea id="imageDescriptionEngine" rows="2" placeholder="Ex: 'fotografias reais', 'close-up emocional'"></textarea></div>
        <div class="input-group md:col-span-2"><label for="imageStyleSelect">Motor de Qualidade de Imagem:</label><select id="imageStyleSelect"><option value="cinematic" selected>Cinematográfico</option><option value="custom">Personalizado</option><option value="none">Nenhum</option></select></div>
        <div id="customImageStyleContainer" class="input-group md:col-span-2" style="display: none;">
            <label for="customImageStyle">Estilo de Imagem Personalizado:</label>
            <textarea id="customImageStyle" rows="3" placeholder="Descreva o seu estilo de imagem aqui... Ex: 'estilo de arte de Van Gogh', 'preto e branco com alto contraste'..."></textarea>
        </div>
    </div>
</div>
    
    <!-- O botão final (continua o mesmo) -->
    <div class="mt-6 text-center">
        <div class="mt-6 flex flex-col sm:flex-row items-center justify-center gap-4">
    <!-- Botão Opcional para ajuda da IA -->
    <button id="suggestStrategyBtn" data-action="suggestStrategy" class="btn btn-secondary w-full sm:w-auto">
        <i class="fas fa-magic mr-2"></i> Sugerir Estratégia com IA
    </button>
    <!-- Botão Principal para avançar -->
    <button id="startCraftingBtn" data-action="startCrafting" class="btn btn-primary w-full sm:w-auto">
        <i class="fas fa-arrow-right mr-2"></i> Iniciar Criação do Roteiro
    </button>
</div>


    </div>
</section>

<!-- PAINEL DO PROJETO (inicialmente escondido) -->
<div id="projectDashboard" class="hidden mt-12">

    <!-- SEÇÃO 2: CRIAR ROTEIRO -->
    <section class="mb-10">
        <div class="section-title"><h2 class="text-xl font-bold">2. Criar Roteiro</h2></div>
        
        <!-- Card do Esboço Estratégico -->
        <div id="strategicOutlineCard" class="card card-placeholder mb-6"> <!-- CLASSE ADICIONADA AQUI -->
            <div class="flex justify-between items-center mb-3">
                <h3 class="font-semibold text-lg">Esboço Estratégico</h3>
                <button id="generateOutlineBtn" data-action="generateOutline" class="btn btn-secondary btn-small">Criar Esboço</button>
            </div>
            <div id="outlineContent"><div class="asset-card-placeholder">Clique para gerar o esboço.</div></div>
        </div>
        
        <!-- Container onde os placeholders do roteiro (Introdução, etc.) serão injetados -->
        <div id="scriptSectionsContainer" class="space-y-4"></div>
    </section>

    <!-- SEÇÃO 3: RECURSOS E METADADOS -->
    <section>
        <div class="section-title"><h2 class="text-xl font-bold">3. Recursos e Metadados</h2></div>
        
        <!-- Mapa Emocional -->
        <div class="card card-placeholder mb-6"> <!-- CLASSE ADICIONADA AQUI -->
             <div class="flex justify-between items-center mb-3">
                <h3 class="font-semibold text-lg">Mapa Emocional</h3>
                <button id="mapEmotionsBtn" data-action="mapEmotions" class="btn btn-secondary btn-small">Mapear</button>
            </div>
            <div id="emotionalMapContent"><div class="asset-card-placeholder">Gere o roteiro completo para habilitar.</div></div>
        </div>

        <!-- Grid para os outros recursos -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            
            <!-- Títulos & Thumbnails -->
            <div class="card card-placeholder"> <!-- CLASSE ADICIONADA AQUI -->
                <div class="flex justify-between items-center mb-3">
                    <h3 class="font-semibold text-lg">Títulos & Thumbnails</h3>
                    <button id="generateTitlesAndThumbnailsBtn" data-action="generateTitlesAndThumbnails" class="btn btn-secondary btn-small">Gerar</button>
                </div>
                <div id="titlesThumbnailsContent"><div class="asset-card-placeholder">Gere o roteiro para habilitar.</div></div>
            </div>

            <!-- Descrição & Hashtags -->
            <div class="card card-placeholder"> <!-- CLASSE ADICIONADA AQUI -->
                <div class="flex justify-between items-center mb-3">
                    <h3 class="font-semibold text-lg">Descrição & Hashtags</h3>
                    <button id="generateDescriptionBtn" data-action="generateDescription" class="btn btn-secondary btn-small">Gerar</button>
                </div>
                <div id="videoDescriptionContent"><div class="asset-card-placeholder">Gere o roteiro para habilitar.</div></div>
            </div>

            <!-- Trilha Sonora -->
            <div class="card card-placeholder md:col-span-2"> <!-- CLASSE ADICIONADA AQUI -->
                <div class="flex justify-between items-center mb-3">
                    <h3 class="font-semibold text-lg">Trilha Sonora</h3>
                    <button id="generateSoundtrackBtn" data-action="generateSoundtrack" class="btn btn-secondary btn-small">Gerar</button>
                </div>
                <div id="soundtrackContent"><div class="asset-card-placeholder">Gere o roteiro para habilitar.</div></div>
            </div>
        </div>


            <!-- MÓDULO DE ESTRATÉGIA DA CONCLUSÃO (inicialmente escondido) -->


<div id="conclusionStrategyModule" class="card mb-6 hidden">
    <div class="text-center">
        <h3 class="text-lg font-bold mb-4">Finalize o seu Roteiro</h3>
        <p class="text-gray-600 dark:text-gray-400 mb-6">Gere a Conclusão para amarrar a história e, em seguida, crie um Call to Action (CTA) para engajar seu público.</p>
        <div class="flex flex-wrap justify-center gap-4">
            <!-- Botão para gerar a Conclusão -->
            <button id="generateConclusionBtn" data-action="generateConclusion" class="btn btn-primary">
                <i class="fas fa-pen-fancy mr-2"></i>Gerar Conclusão
            </button>
            <!-- Botão para gerar o CTA (inicialmente escondido) -->
            <button id="generateCtaBtn" data-action="generateCta" class="btn btn-primary hidden">
                <i class="fas fa-bullhorn mr-2"></i>Gerar CTA Estratégico
            </button>
        </div>
    </div>
</div>


    </section>



    <!-- SEÇÃO 5: ANÁLISE DE ROTEIRO COMPLETO -->
<section id="scriptAnalysisSection" class="mt-10 hidden">
    <div class="section-title">
        <h2 class="text-xl font-bold">5. Análise de Roteiro (Beta)</h2>
    </div>
    <div class="card text-center">
        <p class="mb-4 text-gray-600 dark:text-gray-400">Pronto para receber um feedback de nível profissional? Nossas IAs analisarão seu roteiro em busca de pontos fortes, oportunidades de melhoria e ganchos de retenção.</p>
        
        <!-- Container dos botões -->
        <div class="flex flex-wrap justify-center gap-4">
            <button id="analyzeScriptBtn" data-action="analyzeScript" class="btn btn-primary">
                <i class="fas fa-search-plus mr-2"></i> Análise Geral
            </button>
            <button id="analyzeHooksBtn" data-action="analyzeHooks" class="btn btn-secondary">
                <i class="fas fa-anchor mr-2"></i> Caçar Ganchos
            </button>
            <!-- NOSSO NOVO BOTÃO AQUI -->
            <button id="suggestViralBtn" data-action="suggestViralElements" class="btn btn-secondary">
                <i class="fas fa-lightbulb mr-2"></i> Sugerir Elementos Virais
            </button>
        </div>

        <!-- Containers para os relatórios -->
        <div id="analysisReportContainer" class="mt-6 text-left"></div>
        <div id="hooksReportContainer" class="mt-6 text-left"></div>
        <!-- NOSSO NOVO CONTAINER DE RELATÓRIO AQUI -->
        <div id="viralSuggestionsContainer" class="mt-6 text-left"></div>
    </div>
</section>



<!-- ========================================================== -->
<!--     NOVA SEÇÃO 4: GERENCIAMENTO DO PROJETO (EXPORTAR/IMPORTAR)     -->
<!-- ========================================================== -->
<section class="mt-10">
    <div class="section-title">
        <h2 class="text-xl font-bold">4. Gerenciamento do Projeto</h2>
    </div>
    <div class="card">
        <div class="flex flex-wrap items-center justify-center gap-4">
            <!-- Botão para Importar Projeto -->
            <label for="importFileInput" class="btn btn-secondary cursor-pointer">
                <i class="fas fa-upload mr-2"></i> Importar Projeto
            </label>
            <input type="file" id="importFileInput" class="hidden" accept=".json">

            <!-- Botão para Exportar Projeto -->
            <button id="exportProjectBtn" data-action="exportProject" class="btn btn-secondary">
                <i class="fas fa-download mr-2"></i> Exportar Projeto
            </button>

            <!-- >>> NOSSO NOVO BOTÃO AQUI <<< -->
            <button id="exportPdfBtn" data-action="exportPdf" class="btn btn-secondary">
            <i class="fas fa-file-pdf mr-2"></i> Exportar PDF
            </button>

            <!-- >>> Exportar Transcrição <<< -->
            <button id="exportTranscriptBtn" data-action="exportTranscript" class="btn btn-secondary">
            <i class="fas fa-file-alt mr-2"></i> Exportar Transcrição (.rtf)
            </button>
            
            <!-- Botão para Resetar -->
            <button id="resetProjectBtn" data-action="resetProject" class="btn bg-red-600 hover:bg-red-700 text-white">
                <i class="fas fa-sync-alt mr-2"></i> Novo Projeto (Resetar)
            </button>
        </div>
    </div>
</section>


</div>
        </main>


        <div id="tone-variation-menu" class="">
        <button data-tone="emotion">Mais Emoção</button>
        <button data-tone="impact">Mais Urgência</button>
        <button data-tone="clarity">Mais Clareza</button>
        <button data-tone="humor">Mais Humor</button>
        </div>

        <!-- Floating Action Bar -->
        <div class="floating-action-bar">
            <button class="theme-toggle bg-indigo-500 text-white">
                <i class="fas fa-save"></i>
            </button>
        </div>

        <!-- Toast Notification -->
        <div id="toast" class="toast">
            <span id="toastMessage">Mensagem de notificação</span>
        </div>
    </div>

    <!-- Confirmation Dialog Overlay -->
        <div id="confirmationDialogOverlay" style="display: none; position: fixed; inset: 0; background-color: rgba(0,0,0,0.7); z-index: 2000; align-items: center; justify-content: center;">
            <div class="card max-w-sm w-full animate-fade-in">
                <h3 id="confirmationTitle" class="text-xl font-bold mb-4">Título da Confirmação</h3>
                <p id="confirmationMessage" class="mb-6">Deseja limpar o trabalho já realziado?</p>
                <div class="flex justify-end gap-4">
                    <button id="confirmBtnNo" class="btn btn-secondary">Não</button>
                    <button id="confirmBtnYes" class="btn btn-primary">Sim</button>
                </div>
            </div>
        </div>

<!-- ========================================================== -->
<!--     MODAL ATUALIZADO COM ÁREA PARA SUGESTÕES         -->
<!-- ========================================================== -->
<div id="inputDialogOverlay" style="display: none; position: fixed; inset: 0; background-color: rgba(0,0,0,0.7); z-index: 2000; align-items: center; justify-content: center;">
    <div class="card max-w-md w-full animate-fade-in">
        <h3 id="inputDialogTitle" class="text-xl font-bold mb-4">Título do Diálogo</h3>
        <p id="inputDialogMessage" class="text-sm text-gray-500 dark:text-gray-400 mb-4">Mensagem de ajuda.</p>
        
        <!-- Container para as sugestões da IA -->
        <div id="inputDialogSuggestions" class="space-y-2 mb-4">
            <!-- As sugestões (botões) serão injetadas aqui pelo JavaScript -->
        </div>

        <!-- Divisor opcional -->
        <div class="relative flex py-2 items-center">
            <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
            <span class="flex-shrink mx-4 text-xs text-gray-400">OU</span>
            <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
        </div>
        
        <div class="input-group mt-2">
            <label id="inputDialogLabel" for="inputDialogField">Label do Campo</label>
            <textarea id="inputDialogField" rows="2" placeholder="Placeholder..." class="!text-[var(--dark-text-body)]"></textarea>
        </div>

        <div class="flex justify-end gap-4 mt-6">
            <button id="inputBtnCancel" class="btn btn-secondary">Cancelar</button>
            <button id="inputBtnConfirm" class="btn btn-primary">Usar Tema Personalizado</button>
        </div>
    </div>
</div>


    <script type="module">

        // ==========================================================
        // ==================== SETUP INICIAL =======================
        // ==========================================================
        // Variáveis de estado globais
        let generatedTitlesAndThumbnails = null;
        let allImagePrompts = {}; 
        let strategicOutline = null;
    let projectState = {
    intro: false,
    development: false,
    climax: false,
    conclusion: false,
    cta: false
};
        let elements = {};
        let buttons = {};
        let totalScriptSeconds = 0;
        let promptPaginationState = {};
        let isSettingStrategy = false; // <-- NOSSO NOVO SINALIZADOR
        let userSelectionRange = null; // <<< ADICIONE ESTA NOVA LINHA
    
        // Bloco de estilo cinematográfico para prompts de imagem
        const CINEMATIC_STYLE_BLOCK = `
Ultra-realistic, high-resolution photographic image captured with masterfully rendered natural or artificial lighting and cinematic composition. The aesthetic should be of a modern cinematic film, with meticulous attention to physical and sensory details.
**Essential Visual Characteristics:**
- **Rich & Organic Textures:** Surfaces must display tactile authenticity — visible skin pores, individual fabric threads, weathered materials (wood, metal, stone), realistic reflections, and organic imperfections that add depth and believability.
- **Focus & Depth of Field:** Employ selective sharp focus with subtle depth of field (slightly blurred background or foreground) to guide the viewer's attention and create a sense of three-dimensionality.
- **Color Palette & Contrast:** Colors should be "true-to-life" but with a refined, cinematic tonal range. Avoid super-saturated or artificially vibrant hues. Favor contrasts that create visual drama and natural modeling, typical of good cinematography.
- **Lighting & Atmosphere:** Lighting must be complex and naturalistic, with multiple light sources creating soft shadows, half-tones, and highlights. Include subtle atmospheric elements like dust, mist, or light rays (god rays) when appropriate to enhance the sense of a living environment.
- **Visual Composition:** Apply classic cinematic composition principles (rule of thirds, leading lines, broken symmetry, depth) to create visually appealing frames that tell a story.
- **Overall Style:** The final result must be indistinguishable from a high-quality photograph taken with professional equipment, intended to illustrate a film scene. Nothing should look artificial, "3D rendered," or overly polished. The goal is physical and emotional authenticity.
**Stylistic Constraints (WHAT NOT TO DO):**
- NO exaggerated or distorted features (facial features, proportions).
- NO artificial "glow" or excessive smoothing (airbrushing).
- NO visible 3D render or CGI look.
- NO super-saturated colors or unreal hues.
- NO element that breaks the illusion of a photorealistic capture.`;
        // Labels para descrição de imagem em diferentes idiomas
        const imageDescriptionLabels = { 'pt-br': 'Descrição da Imagem:', 'pt-pt': 'Descrição da Imagem:', 'en': 'Image Description:' };

// ==========================================================
        // NOVO: MAPA DE CONTAGEM DE PALAVRAS PARA CONTROLAR DURAÇÃO
        // ==========================================================
        const wordCountMap = {
            // ~2.5 min @ 150 WPM = ~375 palavras
            'short': {
                intro: 60,
                development: 190,
                climax: 75,
                conclusion: 50
            },
            // ~5.5 min @ 150 WPM = ~825 palavras
            'medium': {
                intro: 120,
                development: 420,
                climax: 165,
                conclusion: 120
            },
            // ~10 min @ 150 WPM = ~1500 palavras
            'long': {
                intro: 225,
                development: 750,
                climax: 300,
                conclusion: 225
            },
            // ~16 min @ 150 WPM = ~2400 palavras
            'extra-long': {
                intro: 360,
                development: 1200,
                climax: 480,
                conclusion: 360
            },
            // ~30 min @ 150 WPM = ~4500 palavras
            'documentary': {
                intro: 450,
                development: 2700,
                climax: 900,
                conclusion: 450
            }
        };


        // ==========================================================
        // ================== FUNÇÕES DE UTILIDADE ==================
        // ==========================================================
        /**
         * Exibe uma notificação toast na parte inferior da tela.
         * @param {string} message - A mensagem a ser exibida.
         */
        window.showToast = (message) => {
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');
    if (!toast || !toastMessage) return;
    toastMessage.textContent = message;
    toast.classList.add('show');
    setTimeout(() => { toast.classList.remove('show'); }, 8000);
};


// =========================================================================
// >>>>> VERSÃO FINAL E BLINDADA DE 'window.optimizeGroup' <<<<<
// =========================================================================
/**
 * Otimiza um grupo de parágrafos com base em uma sugestão da IA de análise de retenção.
 * @param {HTMLElement} button - O botão que foi clicado.
 * @param {string} suggestionText - O texto da sugestão fornecida pela IA.
 */
window.optimizeGroup = async (button, suggestionText) => {
    if (!button || !suggestionText) {
        console.error("Erro crítico em optimizeGroup: Parâmetros inválidos.", { button, suggestionText });
        window.showToast("Erro crítico: Parâmetros da função estão faltando.");
        return;
    }

    // <<< CORREÇÃO CRÍTICA: Escapa as aspas para o seletor funcionar corretamente >>>
    const safeSelector = suggestionText.replace(/"/g, '\\"');
    const paragraphsToOptimize = document.querySelectorAll(`[data-suggestion-group="${safeSelector}"]`);

    if (paragraphsToOptimize.length === 0) {
        window.showToast("Erro: parágrafos para otimizar não encontrados.");
        console.warn("Nenhum parágrafo encontrado com o seletor:", `[data-suggestion-group="${safeSelector}"]`);
        return;
    }

    // <<< INDICADOR VISUAL DE PROCESSAMENTO >>>
    const originalButtonText = button.innerHTML;
    const originalButtonState = button.disabled;
    button.innerHTML = '<div class="loading-spinner" style="width:16px; height:16px; border-width: 2px; margin: auto;"></div>';
    button.disabled = true;

    try {
        // <<< PREPARAÇÃO DOS DADOS PARA A IA >>>
        const originalBlock = Array.from(paragraphsToOptimize).map(p => p.textContent.trim()).join('\n\n');
        
        if (!originalBlock || originalBlock.trim() === "") {
             throw new Error("O bloco de texto original está vazio.");
        }

        // <<< ENRIQUECIMENTO DO CONTEXTO PARA A IA >>>
        const basePromptContext = getBasePromptContext(); // Pega o contexto estratégico
        const fullScriptContext = getTranscriptOnly();   // Pega o roteiro completo
        
        // >>>>> PROMPT FINAL E BLINDADO PARA OTIMIZAÇÃO DE GRUPO <<<<<
        const prompt = `Você é um EDITOR DE ROTEIRO DE ELITE e um ESPECIALISTA EM REESCRITA (Copywriter) de MÁXIMA PRECISÃO. Sua tarefa ÚNICA E CRÍTICA é REESCREVER um bloco de texto problemático para que ele se alinhe PERFEITAMENTE ao tom, estilo e narrativa geral do roteiro, resolvendo o problema apontado na sugestão.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (SIGA EXATAMENTE):**
1.  **RESPOSTA PURA E LIMPA:** Sua resposta deve ser APENAS o novo bloco de texto reescrito. NENHUM outro texto, comentário, preâmbulo, metadado ou explicação é permitido. Pense nisso como uma resposta de API pura e impecável.
2.  **FLUXO NATURAL E COESÃO:** O novo bloco deve fluir de forma NATURAL e COESA com o restante do roteiro. Evite rupturas ou desconexões óbvias.
3.  **RESPEITO AO TOM E AO CONTEXTO:** Mantenha o TOM e o ESTILO definidos no contexto geral do projeto. A voz do narrador NÃO deve mudar abruptamente.

**CONTEXTO GERAL DO PROJETO (PARA ALINHAR TOM E ESTILO):**
---
${basePromptContext}
---

**ROTEIRO COMPLETO (PARA ENTENDER A NARRATIVA GERAL E MANTER CONSISTÊNCIA):**
---
${fullScriptContext.substring(0, 2000)}... (continuação do roteiro pode ser carregada se necessário)
---

**TAREFA ESPECÍFICA E FOCALIZADA:**
- **PROBLEMA A SER CORRIGIDO (Sugestão da Análise de Retenção):** "${suggestionText}"
- **BLOCO DE TEXTO ORIGINAL (PARA REESCREVER INTEIRAMENTE):**
---
${originalBlock}
---

**REGRAS OPERACIONAIS ESTRITAS (SIGA EXATAMENTE):**
1.  **Reescrita Completa do Bloco:** Reescreva o bloco de texto inteiro fornecido em "BLOCO DE TEXTO ORIGINAL". NÃO apenas edite partes isoladas; recrie o bloco como um todo coeso.
2.  **Flexibilidade Estrutural:** Você tem LIBERDADE para juntar parágrafos, dividi-los ou reordená-los SE ISSO melhorar significativamente a clareza, o ritmo e a resolução do problema apontado.
3.  **Alinhamento Perfeito com o Contexto:** A nova versão DEVE soar como uma continuação NATURAL e INTEGRADA do restante do roteiro. Qualquer desconexão com o tom, estilo ou narrativa será considerada uma falha.
4.  **RESPOSTA FINAL EXCLUSIVA:** Responda APENAS com o novo bloco de texto reescrito, conforme as regras acima. NENHUM outro conteúdo deve ser incluído.

**AÇÃO FINAL E CRÍTICA:** Reescreva AGORA o bloco de texto fornecido, corrigindo o problema e integrando-o perfeitamente ao roteiro. Responda APENAS com o novo bloco de texto reescrito, seguindo EXATAMENTE todas as regras e o contexto fornecidos.
`;
        // >>>>> FIM DO PROMPT BLINDADO <<<<<

        // <<< CHAMADA À IA E PROCESSAMENTO DA RESPOSTA >>>
        const rawResult = await callGroqAPI(prompt, 3000); // Aumentado levemente o limite de tokens
        let newContent = removeMetaComments(rawResult.trim());

        if (!newContent || newContent.trim() === "") {
            throw new Error("A IA não retornou um conteúdo válido ou a resposta foi completamente limpa.");
        }

        const newParagraphs = newContent.split('\n').filter(p => p.trim() !== '');

        if (newParagraphs.length === 0) {
            throw new Error("A IA não retornou um conteúdo válido após a divisão em parágrafos.");
        }

        // <<< ATUALIZAÇÃO DO DOM >>>
        const firstParagraph = paragraphsToOptimize[0];
        const contentWrapper = firstParagraph.parentElement;
        const sectionElement = firstParagraph.closest('.script-section');
        
        if (!contentWrapper) {
             throw new Error("Não foi possível encontrar o elemento pai para inserir o novo conteúdo.");
        }

        // Substitui o conteúdo do primeiro parágrafo e o destaca
        firstParagraph.innerHTML = DOMPurify.sanitize(newParagraphs[0] || '');
        firstParagraph.classList.add('highlight-change');
        firstParagraph.removeAttribute('data-suggestion-group');

        // Adiciona os novos parágrafos subsequentes, se houver
        let lastElement = firstParagraph;
        for (let i = 1; i < newParagraphs.length; i++) {
            const newDiv = document.createElement('div');
            newDiv.innerHTML = DOMPurify.sanitize(newParagraphs[i]);
            newDiv.className = 'highlight-change';
            contentWrapper.insertBefore(newDiv, lastElement.nextSibling);
            lastElement = newDiv;
        }

        // Remove os parágrafos antigos restantes do grupo
        for (let i = 1; i < paragraphsToOptimize.length; i++) {
            paragraphsToOptimize[i].remove();
        }

        // <<< INVALIDAÇÃO E ATUALIZAÇÃO DE COMPONENTES RELACIONADOS >>>
        if (sectionElement) {
            invalidateAndClearPerformance(sectionElement);
            invalidateAndClearPrompts(sectionElement);
            // Se houver uma função para atualizar tempos de leitura, chame-a aqui
            // updateAllReadingTimes(); 
        }

        window.showToast("Bloco de parágrafos otimizado com sucesso!");

    } catch (error) {
        console.error("Erro detalhado e crítico em optimizeGroup:", error);
        window.showToast(`Falha ao otimizar o bloco: ${error.message}`);
        
        // <<< RECUPERAÇÃO DE ERRO VISUAL >>>
        // Em caso de erro, tenta restaurar o estado visual do botão
        try {
            button.innerHTML = originalButtonText;
            button.disabled = originalButtonState;
        } catch (uiError) {
            console.warn("Não foi possível restaurar o estado visual do botão após erro.", uiError);
        }
    } finally {
        // <<< LIMPEZA FINAL E REMOÇÃO DO TOOLTIP >>>
        try {
            button.innerHTML = originalButtonText;
            button.disabled = false;
            
            // Remove o tooltip inteiro após a otimização/conclusão
            const tooltip = button.closest('.retention-tooltip');
            if (tooltip) {
                tooltip.remove();
            }
        } catch (cleanupError) {
            console.warn("Erro menor durante a limpeza final do tooltip em optimizeGroup:", cleanupError);
        }
    }
};
// =========================================================================
// >>>>> FIM DA VERSÃO BLINDADA DE 'window.optimizeGroup' <<<<<
// =========================================================================



// =========================================================================
// >>>>> SUBSTITUA 'applyHookSuggestion' PELA VERSÃO FLEXÍVEL <<<<<
// =========================================================================
const applyHookSuggestion = (button) => {
    const { problematicQuote, rewrittenQuote } = button.dataset;

    if (!problematicQuote || !rewrittenQuote) {
        window.showToast("Erro: Informações da sugestão não encontradas.");
        return;
    }
    
    const scriptSections = document.querySelectorAll('#scriptSectionsContainer .generated-content-wrapper');
    let replaced = false;

    scriptSections.forEach(wrapper => {
        if (replaced) return;

        const paragraphs = wrapper.querySelectorAll('div[id*="-p-"]');
        paragraphs.forEach(p => {
            if (replaced) return;
            
            // <<< A MUDANÇA ESTÁ AQUI: trocamos 'textContent.includes' por uma busca mais inteligente >>>
            // Esta busca é mais robusta contra pequenas edições ou reaplicações.
            if (p.textContent.includes(problematicQuote)) {
                
                // Criamos o novo conteúdo com o span de destaque
                const newHtmlContent = p.innerHTML.replace(problematicQuote, `<span class="highlight-change">${rewrittenQuote}</span>`);
                
                // Aplicamos e sanitizamos
                p.innerHTML = DOMPurify.sanitize(newHtmlContent, { ADD_TAGS: ["span"], ADD_ATTR: ["class"] });
                window.showToast("Gancho aprimorado com sucesso!");
                
                // Invalida as análises da seção-mãe
                const sectionElement = p.closest('.script-section');
                if (sectionElement) {
                    invalidateAndClearPerformance(sectionElement);
                    invalidateAndClearPrompts(sectionElement);
                    updateAllReadingTimes();
                }

                replaced = true;
            }
        });
    });

    if (!replaced) {
        window.showToast("Não foi possível aplicar. O texto pode ter sido editado.");
        return;
    }

    // Feedback no botão
    button.disabled = true;
    button.innerHTML = '<i class="fas fa-check mr-2"></i>Aplicada!';
    button.classList.remove('btn-primary');
    button.classList.add('btn-success');
};


// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA 'analyzeRetentionHooks' INTEIRA <<<<<
// =========================================================================
const analyzeRetentionHooks = async (button) => {
    const fullTranscript = getTranscriptOnly();
    if (!fullTranscript) {
        window.showToast("Gere o roteiro completo primeiro para caçar os ganchos.");
        return;
    }

    showButtonLoading(button);
    const reportContainer = document.getElementById('hooksReportContainer');
    
    // <<< AQUI ESTÁ A NOVA LINHA QUE LIMPA O RELATÓRIO ANTIGO >>>
    reportContainer.innerHTML = '';

    reportContainer.innerHTML = DOMPurify.sanitize(`<div class="my-4"><div class="loading-spinner-small mx-auto"></div><p class="text-sm mt-2">Caçando e refinando ganchos...</p></div>`);

    const prompt = `Você é um Analista de Roteiros especialista em retenção de audiência. Sua tarefa é analisar o roteiro, identificar "ganchos de retenção" e sugerir como aprimorá-los.

**ROTEIRO COMPLETO:**
---
${fullTranscript.slice(0, 7500)}
---

**REGRAS CRÍTICAS DE RESPOSTA (JSON ESTRITO):**
Sua resposta DEVE ser um array JSON. Cada objeto no array deve representar UM gancho e conter EXATAMENTE estas 5 chaves:
1.  "hook_phrase": (String) A frase exata do roteiro que funciona como gancho.
2.  "rewritten_hook": (String) Uma versão REESCRITA da frase, otimizada para máximo impacto e curiosidade.
3.  "hook_type": (String) O tipo do gancho. Escolha de: ['Pergunta Direta', 'Loop Aberto (Mistério)', 'Dado Surpreendente', 'Conflito/Tensão', 'Anedota Pessoal', 'Afirmação Polêmica'].
4.  "justification": (String) Uma justificativa curta explicando por que a versão reescrita é mais forte.
5.  "effectiveness_score": (Número) Uma nota de 1 a 10 para a eficácia do gancho ORIGINAL.

Responda APENAS com o array JSON.`;

    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const hooks = cleanGeneratedText(rawResult, true);

        if (!hooks || !Array.isArray(hooks) || hooks.length === 0) {
            throw new Error("A IA não encontrou ganchos ou retornou um formato inválido.");
        }

        let reportHtml = `<div class="space-y-4">`;
        hooks.forEach((hook, index) => {
            const problematicQuoteEscaped = (hook.hook_phrase || '').replace(/"/g, '"');
            const rewrittenQuoteEscaped = (hook.rewritten_hook || '').replace(/"/g, '"');
            const scoreColor = hook.effectiveness_score >= 8 ? 'text-green-500' : hook.effectiveness_score >= 5 ? 'text-yellow-500' : 'text-red-500';
            
            reportHtml += `
                <div class="p-4 border rounded-lg bg-gray-50 dark:bg-gray-800 animate-fade-in">
                    <p class="text-base italic text-gray-500 dark:text-gray-400 mb-2">Original: "${DOMPurify.sanitize(hook.hook_phrase)}"</p>
                    <div class="flex flex-wrap items-center gap-x-4 gap-y-2 text-sm">
                        <span class="tag tag-pace !bg-purple-100 !text-purple-700 dark:!bg-purple-900/50 dark:!text-purple-300">
                            <i class="fas fa-anchor mr-2"></i> ${DOMPurify.sanitize(hook.hook_type)}
                        </span>
                        <span class="font-bold ${scoreColor}">
                            Eficácia Original: ${DOMPurify.sanitize(String(hook.effectiveness_score))}/10
                        </span>
                    </div>
                    <p class="text-sm mt-3 text-gray-600 dark:text-gray-400">
                        <strong>Justificativa da Melhoria:</strong> ${DOMPurify.sanitize(hook.justification)}
                    </p>
                    <div class="flex items-center justify-between gap-2 mt-3 pt-3 border-t border-dashed border-gray-300 dark:border-gray-600">
                        <p class="text-sm flex-1"><strong class="text-green-600 dark:text-green-400">Sugestão:</strong> "${DOMPurify.sanitize(hook.rewritten_hook)}"</p>
                        <button class="btn btn-primary btn-small flex-shrink-0"
                                data-action="applyHookSuggestion"
                                data-problematic-quote="${problematicQuoteEscaped}"
                                data-rewritten-quote="${rewrittenQuoteEscaped}">
                            Aplicar
                        </button>
                    </div>
                </div>
            `;
        });
        reportHtml += `</div>`;
        
        reportContainer.innerHTML = reportHtml;
        window.showToast(`${hooks.length} ganchos analisados e aprimorados!`);

    } catch (error) {
        console.error("Erro detalhado em analyzeRetentionHooks:", error);
        reportContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};



// =========================================================================
// >>>>> PASSO 2: SUBSTITUA A FUNÇÃO 'insertViralSuggestion' INTEIRA <<<<<
// =========================================================================
const insertViralSuggestion = (button) => {
    const { anchorParagraph, suggestedText } = button.dataset;

    if (!anchorParagraph || !suggestedText) {
        window.showToast("Erro: Informações da sugestão não encontradas.");
        return;
    }

    const allParagraphs = document.querySelectorAll('#scriptSectionsContainer div[id*="-p-"]');
    let inserted = false;

    allParagraphs.forEach(p => {
        // A busca flexível que procura se o parágrafo CONTÉM a âncora
        if (!inserted && p.textContent.trim().includes(anchorParagraph.trim())) {
            const newDiv = document.createElement('div');
            newDiv.id = `inserted-p-${Date.now()}`; 
            
            newDiv.innerHTML = `<span class="highlight-change">${suggestedText}</span>`;
            
            p.parentNode.insertBefore(newDiv, p.nextSibling);

            newDiv.innerHTML = DOMPurify.sanitize(newDiv.innerHTML, { ADD_TAGS: ["span"], ADD_ATTR: ["class"] });
            window.showToast("Elemento viral inserido com sucesso!");

            const sectionElement = p.closest('.script-section');
            if (sectionElement) {
                invalidateAndClearPerformance(sectionElement);
                invalidateAndClearPrompts(sectionElement);
                updateAllReadingTimes();
            }
            
            inserted = true;
        }
    });

    if (!inserted) {
        window.showToast("Não foi possível inserir. O parágrafo âncora pode ter sido editado.");
        return;
    }

    button.disabled = true;
    button.innerHTML = '<i class="fas fa-check mr-2"></i>Aplicada!';
    button.classList.remove('btn-primary');
    button.classList.add('btn-success');
};



// =========================================================================
// >>>>> SUBSTITUA 'suggestViralElements' PELA VERSÃO COM NOTAS DE IMPACTO <<<<<
// =========================================================================
const suggestViralElements = async (button) => {
    const fullTranscript = getTranscriptOnly();
    const videoTheme = document.getElementById('videoTheme')?.value.trim();
    if (!fullTranscript || !videoTheme) {
        window.showToast("Gere o roteiro completo e defina um tema para receber sugestões virais.");
        return;
    }

    showButtonLoading(button);
    const reportContainer = document.getElementById('viralSuggestionsContainer');
    reportContainer.innerHTML = ''; 
    reportContainer.innerHTML = DOMPurify.sanitize(`<div class="my-4"><div class="loading-spinner-small mx-auto"></div><p class="text-sm mt-2">Procurando por oportunidades virais...</p></div>`);

    // <<< O PROMPT AGORA PEDE UMA NOTA DE IMPACTO >>>
    const prompt = `Você é um Estrategista de Conteúdo Viral. Sua tarefa é analisar um roteiro e sugerir 3 oportunidades para INSERIR elementos que aumentem a viralidade.

**TEMA DO VÍDEO:** "${videoTheme}"
**ROTEIRO COMPLETO:**
---
${fullTranscript.slice(0, 7500)}
---

**REGRAS CRÍTICAS DE RESPOSTA (JSON ESTRITO):**
Sua resposta DEVE ser um array JSON. Cada objeto no array deve representar UMA sugestão e conter EXATAMENTE estas 5 chaves:
1.  "anchor_paragraph": (String) O texto EXATO do parágrafo que virá IMEDIATAMENTE ANTES da sua sugestão.
2.  "suggested_text": (String) O parágrafo EXATO, já escrito e pronto para ser inserido.
3.  "element_type": (String) O tipo de elemento, escolhido da lista: ['Dado Surpreendente', 'Citação de Autoridade', 'Mini-Revelação (Teaser)', 'Pergunta Compartilhável', 'Anedota Pessoal Rápida'].
4.  "potential_impact_score": (Número) Uma nota de 1 a 10 estimando o potencial de aumento de engajamento que esta inserção pode causar.
5.  "implementation_idea": (String) Uma descrição curta de como esta inserção melhora o roteiro.

**EXEMPLO DE FORMATO PERFEITO E OBRIGATÓRIO:**
[
    {
        "anchor_paragraph": "E foi assim que ele tomou a decisão que mudaria tudo.",
        "suggested_text": "De fato, estudos mostram que 78% das decisões que mudam vidas são tomadas em momentos de alta pressão emocional.",
        "element_type": "Dado Surpreendente",
        "potential_impact_score": 9,
        "implementation_idea": "Inserir uma estatística chocante para reforçar o impacto da decisão."
    }
]

Responda APENAS com o array JSON completo e sintaticamente perfeito.`;

    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const suggestions = cleanGeneratedText(rawResult, true);

        if (!suggestions || !Array.isArray(suggestions) || suggestions.length === 0) {
            throw new Error("A IA não encontrou oportunidades ou retornou um formato inválido.");
        }

        // <<< A RENDERIZAÇÃO AGORA INCLUI A NOTA DE IMPACTO >>>
        let reportHtml = `<div class="space-y-4">`;
        suggestions.forEach(suggestion => {
            const anchorParagraphEscaped = (suggestion.anchor_paragraph || '').replace(/"/g, '"');
            const suggestedTextEscaped = (suggestion.suggested_text || '').replace(/"/g, '"');
            const score = suggestion.potential_impact_score || 0;
            const scoreColor = score >= 8 ? 'text-green-500' : score >= 5 ? 'text-yellow-500' : 'text-red-500';

            reportHtml += `
                <div class="p-4 border rounded-lg bg-gray-50 dark:bg-gray-800 animate-fade-in">
                    <div class="flex flex-wrap items-center gap-x-4 gap-y-2 text-sm mb-2">
                        <span class="tag !bg-blue-100 !text-blue-700 dark:!bg-blue-900/50 dark:!text-blue-300">
                            <i class="fas fa-lightbulb mr-2"></i> ${DOMPurify.sanitize(suggestion.element_type)}
                        </span>
                        <span class="font-bold ${scoreColor}">
                            Impacto Potencial: ${DOMPurify.sanitize(String(score))}/10
                        </span>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-1">
                        <strong>Local Sugerido:</strong> Após o parágrafo que contém "${DOMPurify.sanitize((suggestion.anchor_paragraph || '').substring(0, 70))}..."
                    </p>
                    <p class="text-sm mt-3 text-gray-600 dark:text-gray-400">
                        <strong>Ideia de Implementação:</strong> ${DOMPurify.sanitize(suggestion.implementation_idea)}
                    </p>
                    <div class="flex items-center justify-between gap-2 mt-3 pt-3 border-t border-dashed border-gray-300 dark:border-gray-600">
                         <p class="text-sm flex-1"><strong class="text-green-600 dark:text-green-400">Texto a Inserir:</strong> "${DOMPurify.sanitize(suggestion.suggested_text)}"</p>
                        <button class="btn btn-primary btn-small flex-shrink-0"
                                data-action="insertViralSuggestion"
                                data-anchor-paragraph="${anchorParagraphEscaped}"
                                data-suggested-text="${suggestedTextEscaped}">
                            Aplicar
                        </button>
                    </div>
                </div>
            `;
        });
        reportHtml += `</div>`;
        
        reportContainer.innerHTML = reportHtml;
        window.showToast(`${suggestions.length} sugestões virais encontradas!`);

    } catch (error) {
        console.error("Erro detalhado em suggestViralElements:", error);
        reportContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};



// =========================================================================
// >>>>> PASSO 1: SUBSTITUA A FUNÇÃO 'analyzeFullScript' INTEIRA <<<<<
// =========================================================================
const analyzeFullScript = async (button) => {
    showButtonLoading(button);
    const reportContainer = document.getElementById('analysisReportContainer');
    reportContainer.innerHTML = DOMPurify.sanitize(`<div class="my-4"><div class="loading-spinner-small mx-auto"></div><p class="text-sm mt-2">Analisando... Isso pode levar um momento.</p></div>`);

    try {
        const introText = document.querySelector('#introSection .generated-content-wrapper')?.textContent.trim();
        const devText = document.querySelector('#developmentSection .generated-content-wrapper')?.textContent.trim();
        const climaxText = document.querySelector('#climaxSection .generated-content-wrapper')?.textContent.trim();
        const conclusionText = document.querySelector('#conclusionSection .generated-content-wrapper')?.textContent.trim();
        const ctaText = document.querySelector('#ctaSection .generated-content-wrapper')?.textContent.trim();

        if (!introText || !devText || !climaxText || !conclusionText || !ctaText) {
            throw new Error("Todas as 5 seções do roteiro (Intro, Dev, Clímax, Conclusão e CTA) devem ser geradas primeiro.");
        }

        // <<< AQUI ESTÁ A MUDANÇA: Coletando o contexto leve >>>
        const lightContext = {
            theme: document.getElementById('videoTheme')?.value.trim() || 'Não definido',
            centralQuestion: document.getElementById('centralQuestion')?.value.trim() || 'Não definida',
            outline: strategicOutline || {} // Pega o esboço estratégico que já temos na memória
        };
        // --- Fim da mudança ---

        const results = await Promise.allSettled([
            // E agora passamos o contexto para cada chamada
            analyzeScriptPart('Introdução (Hook)', introText, `Analise este hook...`, lightContext),
            analyzeScriptPart('Desenvolvimento (Ritmo e Retenção)', devText, `Analise este desenvolvimento...`, lightContext),
            analyzeScriptPart('Clímax', climaxText, `Analise este clímax...`, lightContext),
            analyzeScriptPart('Conclusão', conclusionText, `Analise esta conclusão...`, lightContext),
            analyzeScriptPart('CTA (Call to Action)', ctaText, `Analise este CTA...`, lightContext)
        ]);

        reportContainer.innerHTML = ''; 

        const headerDiv = document.createElement('div');
        headerDiv.className = 'flex justify-between items-center mb-4 p-3 bg-gray-100 dark:bg-gray-900/50 rounded-lg';
        headerDiv.innerHTML = DOMPurify.sanitize(`
            <h3 class="text-lg font-bold">Relatório de Análise</h3>
            <button id="applyAllSuggestionsBtn" data-action="applyAllSuggestions" class="btn btn-secondary btn-small">
                <i class="fas fa-wand-magic-sparkles mr-2"></i>Aplicar Todas
            </button>
        `);
        reportContainer.appendChild(headerDiv);

        results.forEach(result => {
            if (result.status === 'fulfilled') {
                reportContainer.appendChild(createReportSection(result.value));
            } else {
                console.error("Uma micro-análise falhou:", result.reason);
                reportContainer.appendChild(createReportSection(result.reason));
            }
        });

        window.showToast("Análise do roteiro concluída!");

    } catch (error) {
        console.error("Erro detalhado em analyzeFullScript:", error);
        window.showToast(`Falha na análise: ${error.message}`);
        reportContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};




// =========================================================================
// >>>>> VERSÃO FINAL DE 'analyzeScriptPart' (COM CORREÇÃO FORÇADA) <<<<<
// =========================================================================
const analyzeScriptPart = async (criterion, text, instruction, context = {}) => {
    const sectionKeyMap = {
        'Introdução (Hook)': 'introduction',
        'Desenvolvimento (Ritmo e Retenção)': 'development',
        'Clímax': 'climax',
        'Conclusão': 'conclusion',
        'CTA (Call to Action)': 'cta'
    };
    const outlineKey = sectionKeyMap[criterion];
    const outlineDirective = context.outline && context.outline[outlineKey] ? context.outline[outlineKey] : 'Nenhuma diretriz específica foi definida.';

    const prompt = `Você é uma API de Análise de Roteiro. Sua resposta DEVE ser um objeto JSON.

**CONTEXTO ESTRATÉGICO:**
- **Tema Principal:** "${context.theme}"
- **Pergunta Central:** "${context.centralQuestion}"
- **Objetivo Estratégico DESTA Seção:** "${outlineDirective}"

**TAREFA:** Analise o "Trecho de Roteiro" abaixo.

**Trecho de Roteiro:**
---
${text.slice(0, 6500)}
---

**REGRAS CRÍTICAS DE RESPOSTA (JSON ESTRITO):**
- **"criterion_name"**: (String) Use EXATAMENTE este valor: "${criterion}".
- **"score"**: (Número) Uma nota de 0 a 10.
- **"positive_points"**: (String) **UM ÚNICO PARÁGRAFO** resumindo os pontos fortes.
- **"improvement_points"**: (Array de Objetos) Cada objeto com 4 chaves: "problematic_quote", "critique", "suggestion_text", "rewritten_quote".

**PROIBIÇÃO ABSOLUTA:** O valor de "rewritten_quote" NUNCA PODE SER uma string vazia (""). SEMPRE deve conter uma frase reescrita.

Responda APENAS com o objeto JSON completo e sintaticamente perfeito.`;

    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const analysisData = cleanGeneratedText(rawResult, true);

        if (!analysisData) { throw new Error("A IA retornou uma resposta nula ou vazia."); }

        // <<< AQUI ESTÁ A CORREÇÃO FORÇADA E DEFINITIVA >>>
        // Não importa o que a IA retornou em 'criterion_name', nós forçamos o valor correto.
        analysisData.criterion_name = criterion;

        const requiredKeys = ['score', 'positive_points', 'improvement_points'];
        for (const key of requiredKeys) {
            if (!(key in analysisData)) { throw new Error(`A chave '${key}' está ausente na resposta JSON da IA.`); }
        }
        
        // O Firewall que já tínhamos, agora mais importante do que nunca
        if (Array.isArray(analysisData.positive_points)) {
            console.warn("'positive_points' veio como array. Consolidando em uma string.");
            analysisData.positive_points = analysisData.positive_points.join(' ');
        }
        
        if (Array.isArray(analysisData.improvement_points)) {
            analysisData.improvement_points = analysisData.improvement_points.map((point, index) => {
                const correctedPoint = {};
                for (const key in point) {
                    correctedPoint[key.trim()] = point[key];
                }
                ['problematic_quote', 'critique', 'suggestion_text', 'rewritten_quote'].forEach(key => {
                    if (typeof correctedPoint[key] !== 'string') {
                        correctedPoint[key] = correctedPoint[key] || `[Valor ausente para '${key}']`;
                    }
                });
                if (correctedPoint.rewritten_quote.trim() === "") {
                    correctedPoint.rewritten_quote = correctedPoint.problematic_quote;
                }
                return correctedPoint;
            });
        }

        return analysisData;

    } catch (error) {
        console.error(`Erro ao analisar a parte '${criterion}':`, error);
        return { 
            criterion_name: criterion, 
            score: 'Erro', 
            positive_points: 'Não foi possível analisar esta seção.', 
            improvement_points: [{
                critique: 'Erro da API',
                suggestion_text: `A análise falhou: ${error.message}`,
                problematic_quote: 'N/A',
                rewritten_quote: 'N/A'
            }]
        };
    }
};



// =========================================================================
// >>>>> PASSO 2: SUBSTITUA A FUNÇÃO 'createReportSection' INTEIRA POR ESTA <<<<<
// =========================================================================
const createReportSection = (analysisData) => {
    const sectionDiv = document.createElement('div');
    sectionDiv.className = 'p-4 border rounded-lg mb-4 bg-gray-50 dark:bg-gray-800 animate-fade-in';

    if (!analysisData || typeof analysisData.score === 'undefined') {
        const errorName = analysisData ? analysisData.criterion_name : 'Seção de Análise';
        sectionDiv.innerHTML = DOMPurify.sanitize(`
            <h4 class="font-bold text-lg text-red-500">${errorName}</h4>
            <p class="text-red-500 text-sm mt-2">Falha ao processar a análise para esta seção. A resposta da IA pode estar em um formato inesperado.</p>
        `);
        return sectionDiv;
    }

    let improvementHtml = '';
    if (analysisData.improvement_points && analysisData.improvement_points.length > 0) {
        improvementHtml = analysisData.improvement_points.map(point => {
            const problematicQuoteEscaped = (point.problematic_quote || '').replace(/"/g, '"');
            const rewrittenQuoteEscaped = (point.rewritten_quote || '').replace(/"/g, '"');

            return `
            <div class="mt-4 pt-3 border-t border-dashed border-gray-300 dark:border-gray-600">
                <p class="text-sm italic text-gray-500 dark:text-gray-400 mb-1">" ${DOMPurify.sanitize(point.problematic_quote || '')} "</p>
                <p class="text-sm"><strong class="text-yellow-600 dark:text-yellow-400">Crítica:</strong> ${DOMPurify.sanitize(point.critique || '')}</p>
                <div class="flex items-center justify-between gap-2 mt-2">
                    <p class="text-sm flex-1"><strong class="text-green-600 dark:text-green-400">Sugestão:</strong> ${DOMPurify.sanitize(point.suggestion_text || '')}</p>
                    
                    <button class="btn btn-primary btn-small flex-shrink-0"
                            data-action="applySuggestion"
                            data-criterion-name="${DOMPurify.sanitize(analysisData.criterion_name)}"
                            data-problematic-quote="${problematicQuoteEscaped}"
                            data-rewritten-quote="${rewrittenQuoteEscaped}">
                        Aplicar
                    </button>
                </div>
            </div>`;
        }).join('');
    }

    const content = `
        <div class="flex justify-between items-center">
            <h4 class="font-bold text-lg">${DOMPurify.sanitize(analysisData.criterion_name)}</h4>
            <span class="font-bold text-xl text-primary">${analysisData.score}/10</span>
        </div>
        <div class="mt-2">
            <p class="text-sm"><strong class="text-indigo-500">Pontos Fortes:</strong> ${DOMPurify.sanitize(analysisData.positive_points)}</p>
            ${improvementHtml}
        </div>
    `;
    sectionDiv.innerHTML = content;
    return sectionDiv;
};



// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO 'varyTone' INTEIRA POR ESTA VERSÃO <<<<<
// =========================================================================

const varyTone = async (tone) => {
    if (!userSelectionRange) {
        window.showToast("Erro: Seleção de texto perdida.");
        return;
    }
    const selectedText = userSelectionRange.toString();
    const toneMenu = document.getElementById('tone-variation-menu');
    toneMenu.classList.remove('visible');

    // <<< AQUI ESTÁ A CORREÇÃO: Lemos o idioma selecionado >>>
    const selectedLangCode = document.getElementById('languageSelect').value;
    const languageName = selectedLangCode === 'pt-br' ? 'Português do Brasil' : 'English';

    const toneInstructions = {
    emotion: "INJETE LINGUAGEM PROFUNDAMENTE EMOTIVA, Torne o texto visceralmente sentindo. Foque intensamente em sentimentos brutos, vulnerabilidade autêntica e impacto pessoal direto no espectador. Utilize palavras com PESO EMOCIONAL MÁXIMO e analogias SENSORIAIS VÍVIDAS que toquem os sentidos (visão, audição, tato, olfato, paladar) para criar uma conexão imediata e poderosa.",
    impact: "MAXIMIZE O IMPACTO E A URGÊNCIA, Reescreva utilizando PRINCIPALMENTE frases CURTAS, DINÂMICAS e CARREGADAS de AÇÃO. Estruture o texto para criar um ritmo ACELERADO que transmita SENSAÇÃO DE VELOCIDADE, URGÊNCIA CRÍTICA e IMPORTÂNCIA ABSOLUTA. Cada palavra deve empurrar o espectador para a ação ou reflexão imediata.",
    clarity: "ATUE COMO UM TRADUTOR DE MÁXIMA CLAREZA, Sua tarefa é ELIMINAR qualquer barreira à compreensão. REMOVA TODO JARGÃO, TERMOS TÉCNICOS e CONCEITOS COMPLEXOS. SIMPLIFIQUE ao máximo, mantendo a precisão. REESCREVA a ideia central utilizando a forma MAIS CLARA, DIRETA e ACCESSÍVEL possível, como se estivesse explicando para alguém leigo mas inteligente.",
    humor: "INTEGRE HUMOR DE FORMA ESTRATÉGICA E ALINHADA, Reescreva o trecho incorporando uma pitada de IRONIA BEM DOSADA, SARCASMO LEVE ou uma ANALOGIA ENGRAÇADA. CRUCIAL: O tom cômico DEVE ESTAR TOTALMENTE ALINHADO com a VOZ GERAL do roteiro e o tema. O humor deve ENRIQUECER a mensagem, não mascará-la ou desvirtuá-la."
    };

    // <<< O PROMPT AGORA INCLUI A REGRA DE IDIOMA >>>
    const prompt = `Você é um Editor de Roteiro especialista em tom narrativo. Sua tarefa é reescrever o 'Texto Original' para que ele transmita um novo sentimento, mantendo a informação central.

**Texto Original:**
---
${selectedText}
---

**Nova Intenção (Tom):**
Você deve reescrever o texto para que ele tenha **mais ${tone}**. Para isso, ${toneInstructions[tone]}

**REGRAS CRÍTICAS (INEGOCIÁVEIS):**
1.  **IDIOMA:** A sua resposta DEVE, OBRIGATORIAMENTE, estar em **${languageName}**.
2.  **Mantenha a Essência:** A informação e o significado do texto original devem ser preservados.
3.  **RESPOSTA LIMPA:** Responda APENAS com o texto reescrito. Sem comentários ou explicações.`;

    try {
        const rawResult = await callGroqAPI(prompt, 1000);
        const variedText = removeMetaComments(rawResult);
        
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(userSelectionRange);
        document.execCommand('insertHTML', false, DOMPurify.sanitize(`<span class="highlight-change">${variedText}</span>`));
        
        const sectionElement = userSelectionRange.startContainer.parentElement.closest('.script-section');
        if (sectionElement) {
            invalidateAndClearPerformance(sectionElement);
            invalidateAndClearPrompts(sectionElement);
        }
        
        window.showToast(`Texto reescrito com '${tone}'!`);
    } catch(error) {
        console.error(`Erro ao variar o tom para ${tone}:`, error);
        window.showToast(`Falha ao reescrever o texto: ${error.message}`);
    } finally {
        userSelectionRange = null;
    }
};


// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO 'suggestFinalStrategy' INTEIRA POR ESTA <<<<<
// =========================================================================

const suggestFinalStrategy = async (button) => {
    showButtonLoading(button);

    // LÓGICA DE RESET INTELIGENTE
    const conclusionContainer = document.getElementById('conclusionSection');
    const ctaContainer = document.getElementById('ctaSection');
    if (conclusionContainer) conclusionContainer.innerHTML = '';
    if (ctaContainer) ctaContainer.innerHTML = '';

    document.querySelectorAll('input[name="conclusionType"]').forEach(radio => radio.disabled = false);
    const conclusionSpecifics = document.getElementById('conclusionSpecifics');
    const ctaSpecifics = document.getElementById('ctaSpecifics');
    conclusionSpecifics.disabled = false;
    ctaSpecifics.disabled = false;
    document.querySelector('#conclusionInputContainer').classList.remove('opacity-50');
    ctaSpecifics.parentElement.classList.remove('opacity-50');

    document.getElementById('generateConclusionBtn').classList.remove('hidden');
    document.getElementById('generateCtaBtn').classList.add('hidden');
    
    projectState.conclusion = false;
    projectState.cta = false;

    const fullContext = getTranscriptOnly();
    if (!fullContext) {
        window.showToast("Gere o roteiro principal primeiro para receber sugestões.");
        hideButtonLoading(button);
        return;
    }

    // O NOVO PROMPT, MAIS DIRETO E MENOS "PESSOAL"
    const prompt = `Sua única função é analisar um roteiro e retornar um objeto JSON com sugestões para o final.

**ROTEIRO COMPLETO (PARA CONTEXTO):**
---
${fullContext}
---

**REGRAS CRÍTICAS DE RESPOSTA (JSON ESTRITO):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON.
2.  **ESTRUTURA OBRIGATÓRIA:** O objeto DEVE conter EXATAMENTE duas chaves: "conclusion_suggestion" e "cta_suggestion".
3.  **CONTEÚDO:** O valor de "conclusion_suggestion" deve ser uma lição poderosa. O valor de "cta_suggestion" deve ser um Call to Action criativo e engajador.
4.  **IDIOMA:** Ambos os textos devem estar no mesmo idioma do roteiro.

Responda APENAS com o objeto JSON.`;

    try {
        const rawResult = await callGroqAPI(prompt, 1000);
        const suggestions = cleanGeneratedText(rawResult, true);

        if (suggestions && suggestions.conclusion_suggestion && suggestions.cta_suggestion) {
            conclusionSpecifics.value = suggestions.conclusion_suggestion;
            ctaSpecifics.value = suggestions.cta_suggestion;
            window.showToast("Sugestões para Conclusão e CTA preenchidas!");
        } else {
            throw new Error("A IA não retornou sugestões no formato esperado.");
        }

    } catch (error) {
        console.error("Erro detalhado em suggestFinalStrategy:", error);
        window.showToast(`Falha ao sugerir estratégia final: ${error.message}`);
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};

// =========================================================================
// >>>>> ADICIONE ESTA NOVA FUNÇÃO AO SEU SCRIPT <<<<<
// =========================================================================
/**
 * Encontra e deleta todos os parágrafos pertencentes a um mesmo grupo de sugestão,
 * usando o modal de confirmação personalizado da aplicação.
 * @param {HTMLElement} button - O botão de deletar que foi clicado.
 * @param {string} suggestionText - O texto da sugestão que identifica o grupo.
 */
window.deleteParagraphGroup = async (button, suggestionText) => {
    // 1. CHAMA O NOSSO MODAL PERSONALIZADO e aguarda a resposta (true/false).
    const userConfirmed = await showConfirmationDialog(
        'Confirmar Deleção',
        'Tem certeza que deseja deletar este bloco de parágrafos? Esta ação não pode ser desfeita.'
    );

    // 2. Se o usuário clicou em "Não" (ou fechou), a função para aqui.
    if (!userConfirmed) {
        return;
    }

    // 3. O resto da lógica para encontrar e remover os parágrafos.
    // <<< CORREÇÃO CRÍTICA: escapa as aspas para o seletor funcionar >>>
    const safeSelector = suggestionText.replace(/"/g, '\\"');
    const paragraphsToDelete = document.querySelectorAll(`[data-suggestion-group="${safeSelector}"]`);

    if (paragraphsToDelete.length === 0) {
        window.showToast("Erro: Parágrafos para deletar não encontrados.");
        return;
    }

    const sectionElement = paragraphsToDelete[0].closest('.script-section');

    // Animação de "fade out" antes de remover
    paragraphsToDelete.forEach(p => {
        p.style.transition = 'opacity 0.3s ease-out';
        p.style.opacity = '0';
    });
    
    // Aguarda a animação terminar antes de remover
    setTimeout(() => {
        paragraphsToDelete.forEach(p => p.remove());

        if (sectionElement) {
            invalidateAndClearPerformance(sectionElement);
            invalidateAndClearPrompts(sectionElement);
            updateAllReadingTimes();
        }
        
        window.showToast("Bloco de parágrafos deletado com sucesso!");
    }, 300);
};


// =========================================================================
// >>>>> PASSO 2: SUBSTITUA A FUNÇÃO showInputDialog COMPLETA <<<<<
// =========================================================================
/**
 * Exibe uma caixa de diálogo com um campo de texto e sugestões, e aguarda a entrada do usuário.
 * @param {string} title - O título da caixa de diálogo.
 * @param {string} message - A mensagem de ajuda/descrição.
 * @param {string} label - A label para o campo de texto.
 * @param {string} placeholder - O placeholder para o campo de texto.
 * @param {string[]} suggestions - (NOVO) Um array de strings para criar botões de sugestão.
 * @returns {Promise<string|null>} - Retorna o texto escolhido ou null se cancelar.
 */
const showInputDialog = (title, message, label, placeholder, suggestions = []) => {
    return new Promise(resolve => {
        // Mapeia todos os elementos do DOM necessários para o diálogo
        const overlay = document.getElementById('inputDialogOverlay');
        const titleEl = document.getElementById('inputDialogTitle');
        const messageEl = document.getElementById('inputDialogMessage');
        const labelEl = document.getElementById('inputDialogLabel');
        const fieldEl = document.getElementById('inputDialogField');
        const btnConfirm = document.getElementById('inputBtnConfirm');
        const btnCancel = document.getElementById('inputBtnCancel');
        const suggestionsContainer = document.getElementById('inputDialogSuggestions');

        // Garante que todos os elementos existem antes de continuar para evitar erros
        if (!overlay || !titleEl || !messageEl || !labelEl || !fieldEl || !btnConfirm || !btnCancel || !suggestionsContainer) {
            console.error("Elementos do pop-up de input não foram encontrados no HTML.");
            resolve(null); // Resolve como nulo para não travar a aplicação
            return;
        }

        // Limpa o conteúdo de interações anteriores
        suggestionsContainer.innerHTML = '';
        fieldEl.value = '';

        // Preenche os textos do diálogo com os parâmetros recebidos
        titleEl.textContent = title;
        messageEl.textContent = message;
        labelEl.textContent = label;
        fieldEl.placeholder = placeholder;
        
        // Função centralizada para fechar o diálogo e resolver a Promise
        const closeDialog = (result) => {
            overlay.style.display = 'none';
            // Remove os event listeners para evitar chamadas duplicadas em futuras aberturas
            btnConfirm.onclick = null;
            btnCancel.onclick = null;
            resolve(result);
        };

        // Cria e adiciona os botões de sugestão, se houver sugestões
        if (suggestions && suggestions.length > 0) {
            suggestions.forEach(suggestionText => {
                const suggestionBtn = document.createElement('button');
                suggestionBtn.className = 'btn btn-secondary hover:bg-purple-600 dark:hover:bg-purple-700 w-full text-left justify-start';
                suggestionBtn.textContent = suggestionText;
                // Ao clicar em um botão de sugestão, fecha o diálogo e retorna o texto da sugestão
                suggestionBtn.onclick = () => {
                    closeDialog(suggestionText);
                };
                suggestionsContainer.appendChild(suggestionBtn);
            });
        }

        // Configura o botão de confirmação (para o texto personalizado)
        btnConfirm.onclick = () => {
            const customText = fieldEl.value.trim();
            if (customText) {
                // Se o usuário digitou algo, fecha o diálogo e retorna o texto digitado
                closeDialog(customText);
            } else {
                // Se o campo estiver vazio, avisa o usuário
                window.showToast("Por favor, digite um tema ou escolha uma das sugestões.");
            }
        };

        // Configura o botão de cancelar
        btnCancel.onclick = () => closeDialog(null);

        // Exibe o diálogo
        overlay.style.display = 'flex';
        fieldEl.focus(); // Coloca o foco no campo de texto para facilitar a digitação
    });
};



// =========================================================================
// >>>>> VERSÃO FINAL DE updateAllReadingTimes COM O SELETOR CORRIGIDO <<<<<
// =========================================================================
/**
 * Percorre todas as seções de roteiro geradas e atualiza o tempo de leitura exibido.
 */
const updateAllReadingTimes = () => {
    // Pega todas as seções de roteiro que já foram geradas
    const scriptSections = document.querySelectorAll('#scriptSectionsContainer .accordion-item');
    
    scriptSections.forEach(item => {
        const contentWrapper = item.querySelector('.generated-content-wrapper');
        
        // >>>>> A CORREÇÃO ESTÁ AQUI: Trocamos '.header-content' por '.header-title-group' <<<<<
        const timeDisplay = item.querySelector('.header-title-group .text-xs');

        if (contentWrapper && timeDisplay) {
            // Recalcula o tempo de leitura com base no conteúdo atualizado
            const newTime = calculateReadingTime(contentWrapper.textContent);
            // Atualiza o texto do elemento span com o novo tempo
            timeDisplay.textContent = newTime;
        }
    });
}


    // ==========================================================
// >>>>> SUBSTITUA A FUNÇÃO validateInputs INTEIRA POR ESTA <<<<<
// ==========================================================
const validateInputs = () => {
    const channelName = document.getElementById('channelName')?.value.trim();
    const videoTheme = document.getElementById('videoTheme')?.value.trim();
    const videoDescription = document.getElementById('videoDescription')?.value.trim();
    const videoDuration = document.getElementById('videoDuration')?.value;
    // Adicionamos a leitura do novo campo
    const visualPacing = document.getElementById('visualPacing')?.value;

    if (!channelName) {
        window.showToast("Por favor, insira o nome do canal.");
        return false;
    }
    if (!videoTheme) {
        window.showToast("Por favor, insira o tema do vídeo.");
        return false;
    }
    if (!videoDescription) {
        window.showToast("Por favor, insira a descrição do vídeo (para inspiração).");
        return false;
    }
    if (!videoDuration || videoDuration === "") {
        window.showToast("Por favor, selecione a Duração Desejada do vídeo.");
        return false;
    }
    
    // ==========================================================
    // >>>>> AQUI ESTÁ A NOVA VALIDAÇÃO <<<<<
    // ==========================================================
    if (!visualPacing || visualPacing === "") {
        window.showToast("Por favor, selecione o Ritmo Visual do vídeo.");
        return false;
    }
    
    return true;
};



// =========================================================================
// >>>>> AÇÃO 4: SUBSTITUA AS FUNÇÕES DE RESET COMPLETAS <<<<<
// =========================================================================
const resetProjectOutputs = () => {
    console.log("Resetando outputs do projeto para nova estratégia...");

    // Zera o nosso "painel de controle".
    projectState = { intro: false, development: false, climax: false, conclusion: false };

    // O resto da sua função continua o mesmo...
    strategicOutline = null;
    allImagePrompts = {};
    generatedTitlesAndThumbnails = null;
    totalScriptSeconds = 0;
    promptPaginationState = {};
    window.emotionalMap = null;

    const contentContainers = ['scriptSectionsContainer', 'outlineContent', 'titlesThumbnailsContent', 'videoDescriptionContent', 'soundtrackContent', 'emotionalMapContent'];
    
    contentContainers.forEach(id => {
        const container = document.getElementById(id);
        if (container) {
            if (id === 'scriptSectionsContainer') {
                container.innerHTML = `
                    <div id="introSection" class="script-section"></div>
                    <div id="developmentSection" class="script-section"></div>
                    <div id="climaxSection" class="script-section"></div>
                    <div id="conclusionSection" class="script-section"></div>
                    <div id="ctaSection" class="script-section hidden"></div> 
                `;
            } else {
                const placeholderText = {
                    'outlineContent': "Clique em 'Criar Esboço' para a IA planejar a estrutura do roteiro.",
                    'titlesThumbnailsContent': "Clique em 'Gerar' para ver as sugestões",
                    'videoDescriptionContent': "Clique em 'Gerar' para ver a descrição",
                    'soundtrackContent': "Clique em 'Gerar' para criar sugestões de trilha para o roteiro completo.",
                    'emotionalMapContent': "Clique em 'Mapear' para a IA analisar a jornada emocional do roteiro."
                };
                container.innerHTML = `<div class="asset-card-placeholder">${placeholderText[id] || ''}</div>`;
            }
        }
    });

    resetCompletionIcons();
    updateProgressBar();
    
    const conclusionModule = document.getElementById('conclusionStrategyModule');
    if(conclusionModule) conclusionModule.classList.add('hidden');
};







        /**
         * Exibe uma caixa de diálogo de confirmação e aguarda a resposta do usuário.
         * @param {string} title - O título da caixa de diálogo.
         * @param {string} message - A mensagem de confirmação.
         * @returns {Promise<boolean>} - Retorna true se o usuário clicar "Sim", false caso contrário.
         */
        const showConfirmationDialog = (title, message) => {
            return new Promise(resolve => {
                const overlay = document.getElementById('confirmationDialogOverlay');
                const titleEl = document.getElementById('confirmationTitle');
                const messageEl = document.getElementById('confirmationMessage');
                const btnYes = document.getElementById('confirmBtnYes');
                const btnNo = document.getElementById('confirmBtnNo');

                // Garante que todos os elementos existem antes de continuar
                if (!overlay || !titleEl || !messageEl || !btnYes || !btnNo) {
                    console.error("Elementos do pop-up de confirmação não foram encontrados no HTML.");
                    resolve(false); // Resolve como 'false' para não travar a aplicação
                    return;
                }

                titleEl.textContent = title;
                messageEl.textContent = message;
                overlay.style.display = 'flex';

                // Função para limpar e fechar o diálogo
                const closeDialog = (result) => {
                    overlay.style.display = 'none';
                    // Remove os listeners para evitar chamadas duplicadas
                    clonedBtnYes.replaceWith(btnYes);
                    clonedBtnNo.replaceWith(btnNo);
                    resolve(result);
                };

                // TRUQUE PARA GARANTIR LISTENERS LIMPOS:
                // Clonamos os botões para remover quaisquer event listeners antigos
                const clonedBtnYes = btnYes.cloneNode(true);
                const clonedBtnNo = btnNo.cloneNode(true);

                // Adicionamos os novos listeners aos clones
                clonedBtnYes.addEventListener('click', () => closeDialog(true));
                clonedBtnNo.addEventListener('click', () => closeDialog(false));

                // Substituímos os botões originais pelos clones com os novos listeners
                btnYes.replaceWith(clonedBtnYes);
                btnNo.replaceWith(clonedBtnNo);
            });
        };

        /**
         * Compara um texto gerado pela IA (com anotações) com o texto original
         * para garantir que o conteúdo não foi alterado.
         * @param {string} originalText - O texto base.
         * @param {string} annotatedText - O texto com anotações gerado pela IA.
         * @returns {{isValid: boolean, cleanTextFromAI: string}} - Retorna se é válido e o texto da IA sem anotações.
         */
        const auditGeneratedText = (originalText, annotatedText) => {
            // Remove todas as anotações [em colchetes] do texto da IA
            const cleanTextFromAI = annotatedText.replace(/\[.*?\]/g, '').trim();
            
            // Remove múltiplos espaços e quebras de linha para uma comparação mais justa
            const normalizedOriginal = originalText.replace(/\s+/g, ' ').trim();
            const normalizedCleanAI = cleanTextFromAI.replace(/\s+/g, ' ').trim();

            // Compara os dois textos normalizados
            const isValid = normalizedOriginal === normalizedCleanAI;
            
            return { isValid, cleanTextFromAI };
        };


        /**
         * Copia um texto para a área de transferência.
         * @param {string} text - O texto a ser copiado.
         */
        window.copyTextToClipboard = async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                window.showToast('Copiado!');
            } catch (err) {
                // Fallback para navegadores mais antigos ou contextos restritos (ex: iframes)
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                document.body.appendChild(ta);
                ta.focus();
                ta.select();
                try {
                    document.execCommand('copy');
                    window.showToast('Copiado!');
                } finally {
                    document.body.removeChild(ta);
                }
            }
        };

        /**
         * Fornece feedback visual em um botão após uma ação de cópia.
         * @param {HTMLElement} buttonElement - O elemento do botão que foi clicado.
         */
        window.showCopyFeedback = (buttonElement) => {
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = 'Copiado!';
            buttonElement.classList.add('btn-success');
            buttonElement.disabled = true; // Desabilita o botão temporariamente

            setTimeout(() => {
                buttonElement.innerHTML = originalText;
                buttonElement.classList.remove('btn-success');
                buttonElement.disabled = false;
            }, 2000); // Reverte após 2 segundos
        };



        // ==========================================================
        // >>>>> ADICIONE ESTE NOVO BLOCO <<<<<
        // ==========================================================
        /**
         * Mostra um spinner de carregamento em QUALQUER botão, salvando seu conteúdo original.
         * @param {HTMLElement} button - O elemento do botão a ser modificado.
         */
        const showButtonLoading = (button) => {
            if (!button) return;
            // Salva o HTML original do botão (incluindo ícones e texto)
            button.setAttribute('data-original-html', button.innerHTML);
            button.disabled = true;
            // Define o spinner como o novo conteúdo.
            button.innerHTML = '<div class="loading-spinner" style="width:18px; height:18px; border-width: 2px;"></div>';
        };

        /**
         * Esconde o spinner de carregamento de um botão, restaurando seu conteúdo original.
         * @param {HTMLElement} button - O elemento do botão a ser restaurado.
         */
        const hideButtonLoading = (button) => {
            if (!button) return;
            // Restaura o HTML original que salvamos
            if (button.hasAttribute('data-original-html')) {
                button.innerHTML = button.getAttribute('data-original-html');
                button.removeAttribute('data-original-html');
            }
            button.disabled = false;
        };

        /**
         * Marca um botão (original e flutuante) como concluído (cor verde).
         * @param {string} originalId - O ID do botão original.
         */
        const markButtonAsCompleted = (originalId) => {
            const originalButton = document.getElementById(originalId);
            const floatButton = document.getElementById(`float_${originalId}`);

            [originalButton, floatButton].forEach(btn => {
                if (btn) {
                    btn.classList.remove('btn-primary', 'btn-secondary');
                    btn.classList.add('btn-success');
                }
            });
            updateProgressBar(); 
        };



        /**
         * Reseta os ícones de conclusão de todos os botões (original e flutuante) para suas cores padrão.
         */
        const resetCompletionIcons = () => {
            const passo1_buttons_ids = ['generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 'conclusionBtn', 'generateCTABtn'];
            
            for (const buttonId in buttons) { // Iterar sobre todos os botões
                const isPasso1 = passo1_buttons_ids.includes(buttonId);
                const originalButton = document.getElementById(buttonId);
                const floatButton = document.getElementById(`float_${buttonId}`);

                // Remove a classe de sucesso e adiciona a classe correta (primary/secondary)
                [originalButton, floatButton].forEach(btn => {
                    if (btn) {
                        btn.classList.remove('btn-success');
                        if (isPasso1) {
                            btn.classList.remove('btn-secondary');
                            btn.classList.add('btn-primary');
                        } else {
                            btn.classList.remove('btn-primary');
                            btn.classList.add('btn-secondary');
                        }
                    }
                });
            }
        };
        
/**
 * Verifica se as seções principais do roteiro foram geradas.
 * @returns {boolean} True se todas as seções principais foram geradas, caso contrário, false.
 */
const isScriptComplete = () => {
    // Esta versão lê diretamente do nosso "painel de controle" de estado,
    // que é muito mais confiável do que verificar o HTML.
    return projectState.intro && projectState.development && projectState.climax && projectState.conclusion && projectState.cta;
};




// =========================================================================
// >>>>> AÇÃO 3: SUBSTITUA A FUNÇÃO updateButtonStates COMPLETA <<<<<
// =========================================================================
const updateButtonStates = () => {
    // Em vez de olhar para o HTML, lemos nosso "painel de controle" (`projectState`).
    const { intro, development, climax, conclusion } = projectState;
    
    // A condição principal agora é baseada em nosso objeto de estado. É 100% confiável.
    const allMainScriptGenerated = intro && development && climax;

    // A lógica de metadados agora é mais robusta.
    const metadataButtons = ['generateTitlesAndThumbnailsBtn', 'generateDescriptionBtn', 'generateSoundtrackBtn', 'mapEmotionsBtn'];
    metadataButtons.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            if (id === 'mapEmotionsBtn') {
                btn.disabled = !(allMainScriptGenerated && conclusion);
            } else {
                btn.disabled = !allMainScriptGenerated;
            }
        }
    });

    // Lógica para exibir/esconder o Módulo da Conclusão.
    const conclusionModule = document.getElementById('conclusionStrategyModule');
    const climaxContainer = document.getElementById('climaxSection');

    if (conclusionModule && climaxContainer) {
        if (allMainScriptGenerated && conclusionModule.classList.contains('hidden')) {
            climaxContainer.insertAdjacentElement('afterend', conclusionModule);
            conclusionModule.classList.remove('hidden');
            conclusionModule.scrollIntoView({ behavior: 'smooth', block: 'center' });
            window.showToast("Excelente! Agora, defina a estratégia para a sua conclusão.");
            
            document.querySelectorAll('input[name="conclusionType"]').forEach(radio => {
                radio.addEventListener('change', handleConclusionStrategyChange);
            });
            handleConclusionStrategyChange();
        } 
        else if (!allMainScriptGenerated && !conclusionModule.classList.contains('hidden')) {
            conclusionModule.classList.add('hidden');
        }
    }
};




        /**
         * Mostra um alerta em tela cheia com uma mensagem.
         * @param {string} message - A mensagem a ser exibida.
         */
        const showFullScreenAlert = (message) => {
            elements.fullScreenAlertMessage.textContent = message;
            elements.fullScreenAlertOverlay.classList.add('visible');
        };

        /** Esconde o alerta em tela cheia. */
        const hideFullScreenAlert = () => {
            elements.fullScreenAlertOverlay.classList.remove('visible');
        };

        /** Alterna a visibilidade do campo de estilo de imagem personalizado. */
        const toggleCustomImageStyleVisibility = () => {
    // Adiciona uma verificação para garantir que os elementos existem antes de usá-los
    const container = document.getElementById('customImageStyleContainer');
    const select = document.getElementById('imageStyleSelect');
    if (container && select) {
        container.style.display = select.value === 'custom' ? 'block' : 'none';
    }
};




        /**
         * Coleta e concatena o texto puro de todas as seções do roteiro na ordem correta.
         * @returns {string} A transcrição completa e limpa.
         */
        const getTranscriptOnly = () => {
            let transcript = '';
            const sectionOrder = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection']; // CTA is now part of conclusionSection
            
            sectionOrder.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                const contentWrapper = section?.querySelector('.generated-content-wrapper');
                if (contentWrapper?.textContent.trim()) {
                    // Adiciona o texto da seção e duas quebras de linha para separar os parágrafos.
                    transcript += contentWrapper.textContent.trim() + '\n\n';
                }
            });
            
            return transcript.trim();
        };
    
        /**
         * Calcula o tempo de leitura estimado de um texto, considerando o ritmo de fala.
         */
        const calculateReadingTime = (text) => {
            if (!text) return "";

            const paceMap = {
                slow: 120,
                moderate: 150,
                fast: 180
            };
            
            const selectedPace = document.getElementById('speakingPace').value || 'moderate';
            const wordsPerMinute = paceMap[selectedPace];
            
            const words = text.trim().split(/\s+/).length;
            const totalSeconds = (words / wordsPerMinute) * 60;
            
            if (totalSeconds < 1) return "";
            
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.round(totalSeconds % 60);
            
            let timeString = "~";
            if (minutes > 0) timeString += ` ${minutes} min`;
            if (seconds > 0) timeString += ` ${seconds} seg`;
            
            return timeString.trim();
        };

    // ==========================================================
        // ==================== LÓGICA DAS ABAS =====================
        // ==========================================================
        const setupTabs = () => {
            const tabButtons = document.querySelectorAll('#tabs .tab-button');
            const tabPanes = document.querySelectorAll('#tab-content .tab-pane');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('active-tab'));
                    tabPanes.forEach(pane => pane.classList.remove('active-pane'));

                    button.classList.add('active-tab');
                    const tabId = button.getAttribute('data-tab');
                    const activePane = document.getElementById(tabId);
                    if (activePane) {
                        activePane.classList.add('active-pane');
                    }
                });
            });
        };


// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO mapEmotionsAndPacing INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
// =========================================================================

const mapEmotionsAndPacing = async (button) => {
    const isFullScriptComplete = 
        document.querySelector('#introSection .accordion-item') &&
        document.querySelector('#developmentSection .accordion-item') &&
        document.querySelector('#climaxSection .accordion-item') &&
        document.querySelector('#conclusionSection .accordion-item');

    if (!isFullScriptComplete) {
        window.showToast("Por favor, gere o roteiro completo (incluindo a Conclusão) antes de mapear as emoções.");
        return;
    }

    const fullTranscript = getTranscriptOnly();
    if (!fullTranscript) {
        window.showToast("Gere o roteiro completo primeiro para criar o mapa emocional.");
        return;
    }

    const outputContainer = document.getElementById('emotionalMapContent');
    
    showButtonLoading(button);
    outputContainer.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small mx-auto my-4"></div>`);

    const paragraphs = fullTranscript.split('\n\n').filter(p => p.trim() !== '');

    // >>> PROMPT BLINDADO COM REGRAS DE SINTAXE E ESTRUTURA EXPLÍCITAS <<<
    const prompt = `Você é uma API de análise de roteiro que retorna APENAS um array JSON.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`[\` e terminando com \`]\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar aspas duplas (\`"\`).
3.  **VÍRGULA FINAL:** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último objeto.
4.  **ESTRUTURA DO OBJETO:** Cada objeto no array DEVE conter EXATAMENTE estas três chaves: "paragraph_index" (um número, começando em 0), "emotion" (string), e "pace" (string).
5.  **NÚMERO DE OBJETOS:** O array DEVE conter EXATAMENTE ${paragraphs.length} objetos, um para cada parágrafo.

**ROTEIRO PARA ANALISAR:**
${paragraphs.map((p, index) => `PARAGRAFO ${index}: "${p}"`).join('\n\n')}

Responda APENAS com o array JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE as regras acima.`;

    try {
        const rawResult = await callGroqAPI(prompt, 3000);
        const analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis) || analysis.length < paragraphs.length) {
            throw new Error("A IA retornou um mapa emocional em formato inválido ou incompleto.");
        }

        window.emotionalMap = analysis;
        
        let mapHtml = '<div class="space-y-4">';
        analysis.forEach(item => {
            const paragraphText = paragraphs[item.paragraph_index];
            if (!paragraphText) return;

            mapHtml += `
                <div class="emotional-map-item card !p-3">
                    <p class="paragraph-preview">"${DOMPurify.sanitize(paragraphText)}"</p>
                    <div class="analysis-tags">
                        <span class="tag tag-emotion">
                            <i class="fas fa-theater-masks mr-2"></i>${DOMPurify.sanitize(item.emotion)}
                        </span>
                        <span class="tag tag-pace">
                            <i class="fas fa-tachometer-alt mr-2"></i>${DOMPurify.sanitize(item.pace)}
                        </span>
                    </div>
                </div>
            `;
        });
        mapHtml += '</div>';
        
        outputContainer.innerHTML = DOMPurify.sanitize(mapHtml, { ADD_TAGS: ["i"] });
        markButtonAsCompleted(button.id);

    } catch (error) {
        console.error("Erro detalhado em mapEmotionsAndPacing:", error);
        outputContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">Falha ao gerar o mapa emocional: ${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};


// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO generateSoundtrack INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
// =========================================================================

const generateSoundtrack = async (button) => {
    const fullTranscript = getTranscriptOnly();
    if (!fullTranscript) {
        window.showToast("Gere o roteiro completo primeiro para sugerir uma trilha sonora coerente.");
        return;
    }

    const outputContainer = document.getElementById('soundtrackContent');
    
    showButtonLoading(button);
    outputContainer.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small mx-auto my-4"></div>`);

    // >>> PROMPT BLINDADO SEGUINDO A ANÁLISE PROFISSIONAL <<<
    const prompt = `Você é um especialista em criação de prompts para IAs de música. Sua missão é gerar 3 parágrafos descritivos para uma trilha sonora baseada no roteiro fornecido.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (ABSOLUTAMENTE OBRIGATÓRIAS):**
1.  **JSON PURO E PERFEITO:** Sua resposta inteira deve ser APENAS um array JSON válido, começando com \`[\` e terminando com \`]\`. NENHUM outro texto é permitido.
2.  **ESTRUTURA DO ARRAY:** O array deve conter EXATAMENTE 3 strings.
3.  **ASPAS DUPLAS SEMPRE:** CADA string no array DEVE usar obrigatoriamente aspas duplas (\`"\`).
4.  **VÍRGULAS OBRIGATÓRIAS:** CADA string no array, exceto a ÚLTIMA, DEVE ser seguida por uma vírgula (\`,\`).
5.  **CONTEÚDO DAS STRINGS:** Cada string deve ser um parágrafo único e bem escrito.

**EXEMPLO DE FORMATO PERFEITO E OBRIGATÓRIO:**
[
  "Uma melodia suave e inspiradora com piano e violão, criando uma atmosfera de esperança.",
  "Ritmo acelerado e eletrizante com sintetizadores, combinando tensão e empolgação para momentos de ação.",
  "Uma orquestração épica e emocional com cordas, evocando sentimentos de conquista e realização."
]

**ROTEIRO COMPLETO PARA ANALISAR:**
---
${fullTranscript}
---

Responda APENAS com o array JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE as regras acima.`;

    try {
        const rawResult = await callGroqAPI(prompt, 1500);
        const analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis) || analysis.length === 0) {
            throw new Error("A IA não retornou sugestões no formato esperado.");
        }

        let suggestionsHtml = '<ul class="soundtrack-list space-y-2">';
        analysis.forEach(suggestion => {
            suggestionsHtml += `<li>${DOMPurify.sanitize(suggestion)}</li>`;
        });
        suggestionsHtml += '</ul>';
        
        outputContainer.innerHTML = DOMPurify.sanitize(`<div class="generated-output-box">${suggestionsHtml}</div>`);
        markButtonAsCompleted(button.id);

    } catch (error) {
        console.error("Erro detalhado em generateSoundtrack:", error);
        outputContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">Falha ao gerar sugestões: ${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};



// =========================================================================
// >>>>> PASSO 2: SUBSTITUA a função 'generateConclusion' INTEIRA por ESTA <<<<<
// =========================================================================

const generateConclusion = async (button) => {
    if (!validateInputs()) return;
    showButtonLoading(button);

    const scriptContainer = document.getElementById('scriptSectionsContainer');
    if (scriptContainer && !document.getElementById('conclusionSection')) {
        const conclusionDiv = document.createElement('div');
        conclusionDiv.id = 'conclusionSection';
        conclusionDiv.classList.add('script-section');
        scriptContainer.appendChild(conclusionDiv);
    }

    const conclusionType = document.querySelector('input[name="conclusionType"]:checked').value;
    const conclusionSpecifics = document.getElementById('conclusionSpecifics').value.trim();

    let strategyDirective = '';
    switch (conclusionType) {
        case 'lesson':
            strategyDirective = `O objetivo é reforçar uma lição ou reflexão central. Detalhe fornecido pelo usuário: '${conclusionSpecifics}'`;
            break;
        case 'answer':
            const question = document.getElementById('centralQuestion').value.trim() || 'a pergunta central do vídeo';
            strategyDirective = `O objetivo é responder de forma clara à pergunta central do vídeo ('${question}'). Detalhe fornecido pelo usuário: '${conclusionSpecifics}'`;
            break;
        case 'cliffhanger':
            strategyDirective = `O objetivo é criar um gancho ou mistério para o próximo vídeo. Detalhe fornecido pelo usuário: '${conclusionSpecifics}'`;
            break;
    }

    const fullContext = getTranscriptOnly();
    const basePromptContext = getBasePromptContext();
    const prompt = `${basePromptContext}
    ${fullContext ? `\n\n**ROTEIRO ESCRITO ATÉ AGORA (PARA CONTEXTO):**\n---\n${fullContext}\n---\n` : ''}
    Sua tarefa é escrever APENAS a **Conclusão** do vídeo, continuando de onde o roteiro parou. NÃO inclua um Call to Action (CTA) neste texto.
    **Diretiva Estratégica para a Conclusão:** ${strategyDirective}
    **REGRAS CRÍTICAS:** Responda APENAS com o texto da conclusão. Sem metadados, sem labels (como "Conclusão:"), apenas o texto a ser falado.`;

    try {
        let result = await callGroqAPI(prompt, 800);
        result = removeMetaComments(result.trim());
        const paragraphs = result.split('\n').filter(p => p.trim() !== '');
        const contentWithSpans = paragraphs.map((p, index) => `<div id="conclusion-p-${index}">${p}</div>`).join('');

        // <<< AQUI ESTÁ A CORREÇÃO >>>
        const conclusionContainer = document.getElementById('conclusionSection');
        const conclusionElement = generateSectionHtmlContent('conclusion', 'Conclusão', contentWithSpans);
        conclusionContainer.innerHTML = ''; // Limpa o container
        conclusionContainer.appendChild(conclusionElement); // Adiciona o elemento seguro
        projectState.conclusion = true;
        
        document.querySelectorAll('input[name="conclusionType"]').forEach(radio => radio.disabled = true);
        document.getElementById('conclusionSpecifics').disabled = true;
        document.querySelector('#conclusionInputContainer').classList.add('opacity-50');

        button.classList.add('hidden');
        document.getElementById('generateCtaBtn').classList.remove('hidden');

        window.showToast("Conclusão gerada! Agora, vamos criar um CTA poderoso.");
        document.getElementById('ctaSpecifics').focus();

    } catch (error) {
        window.showToast(`Falha ao gerar a conclusão: ${error.message}`);
        console.error("Erro detalhado em generateConclusion:", error);
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};

// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO 'generateStrategicCta' INTEIRA POR ESTA <<<<<
// =========================================================================

const generateStrategicCta = async (button) => {
    showButtonLoading(button);

    const scriptContainer = document.getElementById('scriptSectionsContainer');
    let ctaSection = document.getElementById('ctaSection');
    if (scriptContainer && !ctaSection) {
        ctaSection = document.createElement('div');
        ctaSection.id = 'ctaSection';
        ctaSection.classList.add('script-section');
        scriptContainer.appendChild(ctaSection);
    }

    const ctaSpecifics = document.getElementById('ctaSpecifics').value.trim();
    const fullContext = getTranscriptOnly();
    const basePromptContext = getBasePromptContext();

    let ctaDirective = "Crie um Call to Action (CTA) genérico, convidando o espectador a curtir, comentar e se inscrever.";
    if (ctaSpecifics) {
        ctaDirective = `Crie um Call to Action (CTA) altamente específico e persuasivo. Instrução do usuário: "${ctaSpecifics}". Conecte esta instrução ao tema geral do vídeo de forma natural e convincente.`;
    }

    const prompt = `${basePromptContext}
    **ROTEIRO COMPLETO (PARA CONTEXTO):**
    ---
    ${fullContext}
    ---
    Sua tarefa agora é escrever APENAS o **Call to Action (CTA)** para o final do vídeo.
    **Diretiva Estratégica para o CTA:** ${ctaDirective}
    **REGRAS CRÍTICAS DE FORMATAÇÃO (A REGRA MAIS IMPORTANTE):**
    1.  **APENAS TEXTO FALADO:** Sua resposta deve conter única e exclusivamente o texto que será narrado.
    2.  **É ESTRITAMENTE PROIBIDO** incluir qualquer tipo de anotação, rótulo de narrador (como 'Narrator:'), descrição de cena (como '(Visuals:...)', '(Opening shot...)') ou qualquer outra formatação que não seja para ser falado em voz alta. A violação desta regra resultará em falha.
    Responda APENAS com o texto puro do roteiro para o CTA.`;

    try {
        let result = await callGroqAPI(prompt, 400);
        result = removeMetaComments(result.trim());
        const paragraphs = result.split('\n').filter(p => p.trim() !== '');
        const contentWithSpans = paragraphs.map((p, index) => `<div id="cta-p-${index}">${p}</div>`).join('');
        
        const ctaElement = generateSectionHtmlContent('cta', 'Call to Action (CTA)', contentWithSpans);
        ctaSection.innerHTML = '';
        ctaSection.appendChild(ctaElement);
        ctaSection.classList.remove('hidden');
        
        projectState.cta = true;
        markButtonAsCompleted('generateCtaBtn');
        
        // <<< AQUI ESTÁ A LÓGICA DE TRAVAMENTO REINTRODUZIDA >>>
        const ctaSpecificsElement = document.getElementById('ctaSpecifics');
        ctaSpecificsElement.disabled = true;
        ctaSpecificsElement.parentElement.classList.add('opacity-50');
        
        document.getElementById('conclusionStrategyModule').classList.add('hidden');
        window.showToast("CTA Estratégico gerado! Roteiro finalizado.");
        
        const analysisSection = document.getElementById('scriptAnalysisSection');
        if (analysisSection) {
            analysisSection.classList.remove('hidden');
            analysisSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

    } catch(error) {
        console.error("Erro detalhado em generateStrategicCta:", error);
        window.showToast(`Falha ao gerar o CTA: ${error.message}`);
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};



    // ==========================================================
        // NOVA FUNÇÃO PARA ATUALIZAR A BARRA DE PROGRESO
        // ==========================================================
            const updateProgressBar = () => {
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    if (!progressFill || !progressText) return;

    const taskButtonIds = [
        'analyzeStrategyBtn',
        'generateOutlineBtn',
        'generateIntroBtn',
        'generateDevelopmentBtn',
        'climaxBtn',
        'generateConclusionAndCtaBtn', // Corrigido para o botão correto da conclusão
        'generateTitlesAndThumbnailsBtn',
        'mapEmotionsBtn',
        'generateDescriptionBtn',
        'generateSoundtrackBtn'
    ];
    const totalTasks = taskButtonIds.length;
    let completedTasks = 0;
    
    taskButtonIds.forEach(id => {
        const button = document.getElementById(id);
        if (button && button.classList.contains('btn-success')) {
            completedTasks++;
        }
    });

    const percentage = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

    // >>>>> INÍCIO DA CORREÇÃO <<<<<
    // Usamos as variáveis corretas (progressFill e progressText) e as cores corretas do CSS.
    progressFill.style.width = `${percentage}%`;
    progressText.textContent = `${percentage}%`;

    if (percentage === 100) {
        progressFill.textContent = "Projeto Pronto!"; 
        progressFill.style.color = '#ffffff';
        progressFill.style.textAlign = 'center';
        progressFill.style.backgroundColor = 'var(--success)'; // Corrigido
    } else {
        progressFill.textContent = '';
        progressFill.style.backgroundColor = 'var(--primary)'; // Corrigido
    }
    // >>>>> FIM DA CORREÇÃO <<<<<
};

        // ==========================================================
        // >>>>> SUBSTITUA SUA FUNÇÃO setupInputTabs POR ESTA <<<<<
        // ==========================================================
        const setupInputTabs = () => {
            const nav = document.getElementById('inputTabsNav');
            if (!nav) return;

            const tabButtons = nav.querySelectorAll('.tab-button');
            const tabPanes = document.getElementById('inputTabContent').querySelectorAll('.tab-pane');

            nav.addEventListener('click', (event) => {
                const button = event.target.closest('.tab-button');
                if (!button) return;

                // 1. Remove a classe ativa de TODOS os botões
                tabButtons.forEach(btn => btn.classList.remove('tab-active'));
                
                // 2. Esconde TODOS os painéis de conteúdo
                tabPanes.forEach(pane => pane.classList.add('hidden'));

                // 3. Adiciona a classe ativa APENAS no botão clicado
                button.classList.add('tab-active');
                
                // 4. Mostra APENAS o painel de conteúdo correspondente
                const tabId = button.getAttribute('data-tab');
                const activePane = document.getElementById(tabId);
                if (activePane) {
                    activePane.classList.remove('hidden');
                }
            });
        };

        const handleConclusionStrategyChange = () => {
            const conclusionSpecificsContainer = document.getElementById('conclusionInputContainer');
            const answerRadioButtonLabel = document.querySelector('input[value="answer"]').parentElement;
            const answerRadioButton = document.querySelector('input[value="answer"]');

            // 1. Lógica para desabilitar a opção "Responder Pergunta" se não houver pergunta
            const centralQuestionText = document.getElementById('centralQuestion').value.trim();
            if (!centralQuestionText) {
                answerRadioButton.disabled = true;
                answerRadioButtonLabel.classList.add('opacity-50', 'cursor-not-allowed');
                answerRadioButtonLabel.title = "Defina a 'Pergunta Central' nos campos principais para usar esta opção.";
                // Se a opção desabilitada estava selecionada, muda para a primeira
                if(answerRadioButton.checked) {
                    document.querySelector('input[value="lesson"]').checked = true;
                }
            } else {
                answerRadioButton.disabled = false;
                answerRadioButtonLabel.classList.remove('opacity-50', 'cursor-not-allowed');
                answerRadioButtonLabel.title = "";
            }
            
            const selectedValue = document.querySelector('input[name="conclusionType"]:checked').value;
            
            // 2. Lógica para mostrar/esconder o textarea e mudar o placeholder
            if (conclusionSpecificsContainer) {
                conclusionSpecificsContainer.classList.toggle('hidden', !['lesson', 'answer', 'cliffhanger'].includes(selectedValue));
            }
            
            const textarea = document.getElementById('conclusionSpecifics');
            if (textarea) {
                const placeholders = {
                    lesson: "Ex: A lição é que a resiliência é a nossa maior força...",
                    answer: "Ex: A resposta é que a Arca foi levada para a Etiópia, mas o verdadeiro segredo é...",
                    cliffhanger: "Ex: ...mas se a Arca foi encontrada, o que aconteceu com o que estava DENTRO dela?"
                };
                textarea.placeholder = placeholders[selectedValue] || "";
            }
        };

        /**
         * Alterna a visibilidade de um corpo de acordeão e a rotação de sua seta. (VERSÃO CORRIGIDA E ROBUSTA)
         * @param {string} bodyId - O ID do elemento do corpo do acordeão.
         * @param {string} arrowId - O ID do elemento da seta do acordeão.
         */
        window.toggleAccordion = (bodyId, arrowId) => {
            const body = document.getElementById(bodyId);
            const arrow = document.getElementById(arrowId);
            // CORREÇÃO: Encontra o cabeçalho subindo na árvore DOM
            const header = body ? body.closest('.accordion-item').querySelector('.accordion-header') : null;

            if (body && arrow && header) {
                const isOpen = body.classList.toggle('open');
                arrow.classList.toggle('open', isOpen);
                header.classList.toggle('active', isOpen);
            }
        };

        /**
 * Renderiza a página correta de prompts para uma determinada seção. (VERSÃO CORRIGIDA)
 * @param {string} sectionElementId - O ID da seção (ex: 'introSection').
 */
const renderPaginatedPrompts = (sectionElementId) => {
    const sectionElement = document.getElementById(sectionElementId);
    if (!sectionElement) return;

    const itemsPerPage = 4;
    const prompts = allImagePrompts[sectionElementId] || [];
    const currentPage = promptPaginationState[sectionElementId] || 0;
    const totalPages = Math.ceil(prompts.length / itemsPerPage);

    const promptItemsContainer = sectionElement.querySelector('.prompt-items-container');
    const navContainer = sectionElement.querySelector('.prompt-nav-container');

    if (!promptItemsContainer || !navContainer) return;

    promptItemsContainer.innerHTML = ''; // Limpa o conteúdo atual

    // --- NOVA LÓGICA DE CÁLCULO GLOBAL ---
    // 1. Define o índice de início no array completo de prompts
    const startIndex = currentPage * itemsPerPage;
    const promptsToShow = prompts.slice(startIndex, startIndex + itemsPerPage);

    // 2. Calcula a duração total de TODOS os prompts ANTES da página atual
    let cumulativeSeconds = 0;
    if (startIndex > 0) {
        const previousPrompts = prompts.slice(0, startIndex);
        cumulativeSeconds = previousPrompts.reduce((total, p) => total + (parseInt(p.estimated_duration, 10) || 18), 0);
    }
    // --- FIM DA NOVA LÓGICA ---

    promptsToShow.forEach((promptData, index) => {
        const globalIndex = startIndex + index; // Índice no array completo
        const currentSceneNumber = globalIndex + 1; // Número da cena correto

        // Calcula o timestamp para esta cena específica
        const minutes = Math.floor(cumulativeSeconds / 60);
        const seconds = cumulativeSeconds % 60;
        const timestamp = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

        const styleBlockContent = promptData.styleBlock || '';
        const promptHtml = `
            <div class="prompt-item card !p-3 animate-fade-in">
                <div class="prompt-header">
                    <span class="tag tag-scene"><i class="fas fa-film mr-2"></i>Cena ${String(currentSceneNumber).padStart(2, '0')}</span>
                    <span class="tag tag-time"><i class="fas fa-clock mr-2"></i>${timestamp}</span>
                    <button class="copy-btn-small" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${globalIndex}')?.textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${globalIndex}')?.textContent); window.showCopyFeedback(this)" title="Copiar Prompt">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <p class="paragraph-preview">"${promptData.scriptPhrase}"</p>
                <div class="prompt-details">
                    <p class="prompt-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                    <p id="prompt-content-${sectionElementId}-${globalIndex}">${promptData.imageDescription}</p>
                    ${styleBlockContent ? `<p class="style-block-indicator">[Estilo Cinematográfico Aplicado]</p>` : ''}
                    <pre id="style-block-${sectionElementId}-${globalIndex}" class="hidden">${styleBlockContent}</pre>
                </div>
            </div>
        `;
        promptItemsContainer.innerHTML += promptHtml;

        // Atualiza os segundos acumulados para a PRÓXIMA iteração do loop
        cumulativeSeconds += (parseInt(promptData.estimated_duration, 10) || 18);
    });
    
    // Atualiza os controles de navegação (código existente, permanece igual)
    navContainer.innerHTML = `
        <button class="btn btn-secondary btn-small" onclick="window.navigatePrompts('${sectionElementId}', -1)" ${currentPage === 0 ? 'disabled' : ''}>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/></svg>
        </button>
        <span class="text-sm font-medium text-gray-600 dark:text-gray-400">Página ${currentPage + 1} de ${totalPages}</span>
        <button class="btn btn-secondary btn-small" onclick="window.navigatePrompts('${sectionElementId}', 1)" ${currentPage + 1 >= totalPages ? 'disabled' : ''}>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg>
        </button>
    `;
    
    // REMOVIDO: A chamada para reNumberAllScenes() foi removida pois agora é desnecessária
};

/**
 * Valida se o array de prompts recebido da IA tem a estrutura correta.
 * @param {any} data - O dado parseado do JSON.
 * @returns {boolean} - True se for um array válido de prompts, false caso contrário.
 */
const validatePromptsArray = (data) => {
    // É um array? Ele não está vazio? O primeiro item é um objeto com as chaves que precisamos?
    return Array.isArray(data) && data.length > 0 && data.every(item => 
        item && typeof item === 'object' && 'scriptPhrase' in item && 'imageDescription' in item
    );
};

/**
 * Reseta o conteúdo do roteiro gerado quando um input estratégico é alterado.
 * @param {string} sourceId - O ID do elemento que causou a mudança.
 */
const resetGeneratedScriptContent = (sourceId) => {
    // Só reseta se já houver conteúdo gerado para não incomodar o usuário no início.
    if (!strategicOutline && !document.querySelector('#scriptSectionsContainer .accordion-item')) {
        return;
    }

    console.log(`Input estratégico '${sourceId}' alterado. Resetando conteúdo do roteiro.`);

    // 1. Limpa as variáveis de estado
    strategicOutline = null;
    allImagePrompts = {};
    promptPaginationState = {};
    totalScriptSeconds = 0;

    // 2. Limpa a UI do esboço e das seções
    const outlineContent = document.getElementById('outlineContent');
    if (outlineContent) {
        outlineContent.innerHTML = `<div class="asset-card-placeholder">A estratégia mudou. Clique em 'Criar Esboço' novamente.</div>`;
    }

    const scriptContainer = document.getElementById('scriptSectionsContainer');
    if (scriptContainer) {
        scriptContainer.innerHTML = `
            <div id="introSection" class="script-section"></div>
            <div id="developmentSection" class="script-section"></div>
            <div id="climaxSection" class="script-section"></div>
            <div id="conclusionSection" class="script-section"></div>
            <div id="ctaSection" class="script-section hidden"></div>
        `;
    }
    
    // 3. Reseta os botões de geração para o estado inicial
    const buttonsToReset = [
        'generateOutlineBtn', 'generateIntroBtn', 'generateDevelopmentBtn', 
        'climaxBtn', 'conclusionBtn', 'generateCTABtn', 
        'generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn'
    ];
    
    buttonsToReset.forEach(id => {
        const btn = document.getElementById(id);
        const floatBtn = document.getElementById(`float_${id}`);
        [btn, floatBtn].forEach(b => {
            if (b) {
                b.classList.remove('btn-success');
                // Adiciona a classe correta (primary ou secondary)
                if (['generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn', 'generateOutlineBtn'].includes(id)) {
                    b.classList.add('btn-secondary');
                } else {
                    b.classList.add('btn-primary');
                }
            }
        });
    });

    // 4. Atualiza a UI e notifica o usuário
    updateProgressBar();
    updateButtonStates();
    const sourceLabel = document.querySelector(`label[for='${sourceId}']`)?.textContent || sourceId;
    window.showToast(`'${sourceLabel}' mudou. O roteiro foi resetado.`);
};


/**
 * Invalida e limpa os prompts de imagem de uma seção quando seu texto é alterado.
 * @param {HTMLElement} sectionElement - O elemento da seção (ex: o div com id="introSection").
 */
const invalidateAndClearPrompts = (sectionElement) => {
    if (!sectionElement) return;

    const sectionId = sectionElement.id;
    const promptContainer = sectionElement.querySelector('.prompt-container');

    // 1. Remove os prompts da memória (do estado global)
    if (allImagePrompts[sectionId]) {
        delete allImagePrompts[sectionId];
        console.log(`Prompts para a seção '${sectionId}' invalidados e removidos da memória.`);
    }
    
    // 2. Limpa a interface do usuário, se os prompts já foram renderizados
    if (promptContainer && promptContainer.innerHTML.trim() !== '') {
        promptContainer.innerHTML = `
            <div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border-l-4 border-yellow-400">
                <p class="text-sm text-yellow-700 dark:text-yellow-300 font-semibold">
                    Atenção: O roteiro foi modificado.
                </p>
                <p class="text-xs text-yellow-600 dark:text-yellow-400 mt-1">
                    Por favor, clique em "Gerar Prompts de Imagem" novamente para criar novos recursos visuais com base no texto atualizado.
                </p>
            </div>
        `;
    }
};


/**
         * Invalida e limpa a sugestão de performance, exibindo um aviso.
         */
        const invalidateAndClearPerformance = (sectionElement) => {
            if (!sectionElement) return;

            const performanceContainer = sectionElement.querySelector('.section-performance-output');
            if (performanceContainer && performanceContainer.innerHTML.trim() !== '') {
                performanceContainer.innerHTML = `
                    <div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border-l-4 border-yellow-400">
                        <p class="text-sm text-yellow-700 dark:text-yellow-300 font-semibold">
                            Atenção: O roteiro foi modificado.
                        </p>
                        <p class="text-xs text-yellow-600 dark:text-yellow-400 mt-1">
                            Por favor, clique em "Sugerir Performance" novamente para criar novas anotações com base no texto atualizado.
                        </p>
                    </div>
                `;
            }
        };

        /**
         * Lida com os cliques nas setas de navegação dos prompts.
         * @param {string} sectionElementId - O ID da seção.
         * @param {number} direction - -1 para a esquerda, 1 para a direita.
         */
        window.navigatePrompts = (sectionElementId, direction) => {
            const prompts = allImagePrompts[sectionElementId] || [];
            const itemsPerPage = 4;
            const totalPages = Math.ceil(prompts.length / itemsPerPage);
            let currentPage = promptPaginationState[sectionElementId] || 0;

            const newPage = currentPage + direction;

            // Validação dos limites
            if (newPage >= 0 && newPage < totalPages) {
                promptPaginationState[sectionElementId] = newPage;
                renderPaginatedPrompts(sectionElementId);
            }
        };
    
// =========================================================================
// >>>>> SUBSTITUA A FUNÇÃO 'generateSectionHtmlContent' INTEIRA POR ESTA <<<<<
// =========================================================================
const generateSectionHtmlContent = (sectionId, title, content) => {
    const accordionItem = document.createElement('div');
    accordionItem.className = 'accordion-item card !p-0 mb-4 animate-fade-in';

    const accordionHeader = document.createElement('div');
    accordionHeader.className = 'accordion-header';

    const accordionBody = document.createElement('div');
    accordionBody.id = `${sectionId}Body`;
    accordionBody.className = 'accordion-body';

    const headerTitleGroup = document.createElement('div');
    headerTitleGroup.className = 'header-title-group';
    const h3 = document.createElement('h3');
    h3.textContent = title;
    const timeSpan = document.createElement('span');
    timeSpan.className = 'text-xs font-normal text-gray-500';
    timeSpan.textContent = calculateReadingTime(content);
    headerTitleGroup.appendChild(h3);
    headerTitleGroup.appendChild(timeSpan);

    const headerActionsGroup = document.createElement('div');
    headerActionsGroup.className = 'header-actions-group';
    const headerButtons = document.createElement('div');
    headerButtons.className = 'header-buttons';

    const regenerateBtn = document.createElement('button');
    regenerateBtn.className = 'regenerate-btn';
    regenerateBtn.title = 'Re-gerar esta seção';
    regenerateBtn.dataset.action = 'regenerate';
    regenerateBtn.dataset.sectionId = `${sectionId}Section`;
    regenerateBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/></svg>`;

    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-btn';
    copyBtn.title = 'Copiar Roteiro';
    copyBtn.dataset.action = 'copy';
    copyBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5-.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg>`;
    headerButtons.appendChild(regenerateBtn);
    headerButtons.appendChild(copyBtn);

    const arrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    arrowSvg.id = `${sectionId}Arrow`;
    arrowSvg.setAttribute('class', 'accordion-arrow');
    arrowSvg.setAttribute('width', '16');
    arrowSvg.setAttribute('height', '16');
    arrowSvg.setAttribute('fill', 'currentColor');
    arrowSvg.setAttribute('viewBox', '0 0 16 16');
    arrowSvg.innerHTML = `<path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>`;
    
    headerActionsGroup.appendChild(headerButtons);
    headerActionsGroup.appendChild(arrowSvg);
    accordionHeader.appendChild(headerTitleGroup);
    accordionHeader.appendChild(headerActionsGroup);

    const contentWrapper = document.createElement('div');
    contentWrapper.className = 'generated-content-wrapper';
    contentWrapper.setAttribute('contenteditable', 'true');
    contentWrapper.innerHTML = content;

    const analysisTools = document.createElement('div');
    const addChapterButtonHtml = sectionId === 'development' ? `
        <div class="tooltip-container">
            <button class="btn btn-primary btn-small" data-action="addDevelopmentChapter">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8.5 4.5a.5.5 0 0 0-1 0v3h-3a.5.5 0 0 0 0 1h3v3a.5.5 0 0 0 1 0v-3h3a.5.5 0 0 0 0-1h-3v-3z"/></svg> 
                Adicionar Capítulo
            </button>
        </div>
    ` : '';
    
    // <<< AQUI ESTÁ A GRANDE MUDANÇA COM OS TOOLTIPS >>>
    const toolsHtml = `
        <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700 space-y-6">
            <div class="text-center">
                <h5 class="font-semibold text-base mb-2 text-gray-800 dark:text-gray-200">Passo 1: Diagnóstico e Criativo</h5>
                <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Analise, edite ou enriqueça o texto para máxima qualidade.</p>
                <div class="flex items-center justify-center gap-2 flex-wrap">
                    
                    <div class="tooltip-container">
                        <button class="btn btn-secondary btn-small" data-action="analyzeRetention" data-section-id="${sectionId}Section">Analisar Retenção</button>
                        <span class="tooltip-text">
                            <strong>Função:</strong> Diagnóstico.<br>
                            <strong>O que faz:</strong> Age como um "médico". Ele escaneia o texto e te diz: "Aqui está bom, aqui tem um ponto de atenção, e aqui tem um ponto de risco". Ele te dá o diagnóstico, mas não a cura.
                        </span>
                    </div>

                    <div class="tooltip-container">
                        <button class="btn btn-secondary btn-small" data-action="refineStyle">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gem" viewBox="0 0 16 16"><path d="M3.1.7a.5.5 0 0 1 .4-.2h9a.5.5 0 0 1 .4.2l2.976 3.974c.149.199.224.458.224.726v1.2a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5v-1.2c0-.268.075-.527.224-.726L3.1.7zM1.49 4.107l-1.18-1.575a.5.5 0 0 1 .4-.8h13.56a.5.5 0 0 1 .4.8L14.51 4.107H1.49zM.5 5.5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1 0-1H1v-1H.5a.5.5 0 0 1 0-1H1v-1H.5a.5.5 0 0 1 0-1H1v-1H.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v7a.5.5 0 0 1 0 1h-.5a.5.5 0 0 1 0-1H15v-1h-.5a.5.5 0 0 1 0-1H15v-1h-.5a.5.5 0 0 1 0-1H15v-1h.5a.5.5 0 0 1 .5-.5v-1a.5.5 0 0 1-.5.5zM2 13.5a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg>
                            Refinar Estilo
                        </button>
                        <span class="tooltip-text">
                            <strong>Função:</strong> Polimento.<br>
                            <strong>O que faz:</strong> Age como um "polidor de carros". Ele pega o texto inteiro, remove repetições e melhora a fluidez. Ele deixa o texto mais bonito e brilhante, mas não muda a sua essência.
                        </span>
                    </div>

                    <div class="tooltip-container">
                        <button class="btn btn-secondary btn-small" data-action="enrichWithData">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8.5 2a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-1 0v-11a.5.5 0 0 1 .5-.5z"/><path d="M2 7.5a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg>
                            Enriquecer com Dados
                        </button>
                        <span class="tooltip-text">
                            <strong>Função:</strong> Adição.<br>
                            <strong>O que faz:</strong> Age como um "engenheiro de reforço". Você seleciona um trecho e lhe dá uma nova informação (um dado, uma fonte). Ele reforça aquele trecho com mais credibilidade.
                        </span>
                    </div>
                    ${addChapterButtonHtml}
                </div>
                <div id="analysis-output-${sectionId}" class="section-analysis-output mt-3 text-left"></div>
            </div>
            <div class="pt-4 border-t border-dashed border-gray-200 dark:border-gray-700 text-center">
                 <h5 class="font-semibold text-base mb-2 text-gray-800 dark:text-gray-200">Passo 2: Estrutura de Narração</h5>
                <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Adicione sugestões de performance para guiar a narração.</p>
                <div class="flex items-center justify-center gap-2"><button class="btn btn-secondary btn-small" data-action="suggestPerformance" data-section-id="${sectionId}Section">Sugerir Performance</button></div>
                <div class="section-performance-output mt-3 text-left"></div> 
            </div>
            <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700 text-center">
                <h5 class="font-semibold text-base mb-2 text-gray-800 dark:text-gray-200">Passo 3: Recursos Visuais</h5>
                <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Crie o storyboard visual para esta seção do roteiro.</p>
                <button class="btn btn-secondary btn-small" data-action="generate-prompts" data-section-id="${sectionId}Section">Gerar Prompts de Imagem</button>
                <div class="prompt-container mt-4 text-left"></div>
            </div>
        </div>
    `;
    analysisTools.innerHTML = DOMPurify.sanitize(toolsHtml, { ADD_TAGS: ["svg", "path", "span", "br", "strong"], ADD_ATTR: ["d", "fill", "viewBox", "xmlns", "width", "height", "class"] });
    
    accordionBody.appendChild(contentWrapper);
    accordionBody.appendChild(analysisTools);
    accordionItem.appendChild(accordionHeader);
    accordionItem.appendChild(accordionBody);

    return accordionItem;
};

    
        // ==========================================================
        // >>>>> SUBSTITUA SUA FUNÇÃO cleanGeneratedText INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
        // ==========================================================
        const cleanGeneratedText = (text, expectJson = false) => {
            if (!text) return null;
            if (!expectJson) return text.trim();

            const startIndex = text.search(/[\{\[]/);
            if (startIndex === -1) {
                console.error("Nenhum caractere de início JSON ('{' ou '[') encontrado no texto da IA.", text);
                throw new Error("A IA não retornou um formato JSON reconhecível.");
            }
            const firstChar = text[startIndex];
            const matchingLastChar = firstChar === '{' ? '}' : ']';
            let level = 1;
            let endIndex = -1;
            for (let i = startIndex + 1; i < text.length; i++) {
                if (text[i] === firstChar) level++;
                if (text[i] === matchingLastChar) level--;
                if (level === 0) {
                    endIndex = i;
                    break;
                }
            }
            if (endIndex === -1) {
                console.warn("JSON não foi fechado corretamente, tentando encontrar o final de forma aproximada.");
                endIndex = text.length;
            }
            
            let jsonString = text.substring(startIndex, endIndex + 1);
            let sanitizedJsonString = jsonString.replace(/[\u0000-\u001F\u007F-\u009F\u200B-\u200F\uFEFF]/g, '');

            try {
                return JSON.parse(sanitizedJsonString);
            } catch (e) {
                console.warn("Parse inicial (sanitizado) falhou. Tentando reparos estruturais...", e.message);
                try {
                    let repairedString = sanitizedJsonString;

                    // >>>>> CIRURGIA INTELIGENTE DE ASPAS <<<<<
                    // 1. Garante que todas as chaves (keys) estejam com aspas duplas.
                    repairedString = repairedString.replace(/([{,]\s*)'([^']+)'(\s*:)/g, '$1"$2"$3');
                    repairedString = repairedString.replace(/([{,]\s*)([a-zA-Z0-9_]+)(\s*:)/g, '$1"$2"$3');

                    // 2. Troca aspas simples por duplas APENAS em valores que são strings completas.
                    // Isso preserva as aspas simples dentro das strings.
                    repairedString = repairedString.replace(/:\s*'([^']*)'/g, ': "$1"');

                    // 3. Remove vírgulas extras no final de objetos/arrays.
                    repairedString = repairedString.replace(/,\s*([}\]])/g, "$1");
                    
                    return JSON.parse(repairedString);
                } catch (finalError) {
                    console.error("Falha ao fazer o parse do JSON, mesmo após todas as cirurgias:", finalError.message);
                    console.error("JSON problemático (original):", text);
                    throw new Error("A IA retornou um JSON com sintaxe interna inválida que não pôde ser corrigido.");
                }
            }
        };


// =========================================================================
// >>>>> VERSÃO FINAL E BLINDADA DE 'removeMetaComments' <<<<<
// =========================================================================
/**
 * Remove comentários meta, instruções e formatações indesejadas injetadas pela IA.
 * @param {string} text - O texto gerado pela IA.
 * @returns {string} O texto limpo.
 */
const removeMetaComments = (text) => {
    if (!text) return "";

    let cleanedText = text;

    // CAMADA 0: Normalização inicial de quebras de linha
    // Substitui diferentes tipos de quebras de linha por \n para consistência
    cleanedText = cleanedText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

    // CAMADA 1: Remove preâmbulos comuns que terminam com ":" (agora mais robusta)
    const lines = cleanedText.split('\n');
    if (lines.length > 0) {
        const firstLine = lines[0].trim();
        // Verifica se a primeira linha parece um preâmbulo (começa com letra maiúscula e termina com :)
        if (firstLine.length > 0 && /^[A-ZÀ-Ú].*:$/.test(firstLine)) {
            lines.shift();
            cleanedText = lines.join('\n');
        }
    }
    cleanedText = cleanedText.trim();

    // CAMADA 2: Usa regex para remover padrões específicos e indesejados (EXPANDIDA)
    const patternsToRemove = [
        // --- Padrões de Início/Contexto ---
        /Here is the (generated )?script for the "[^"]+" section:\s*/gi,
        /Here is the (refined )?text:\s*/gi,
        /Here is the (final )?version:\s*/gi,
        /Response:\s*/gi,
        /Output:\s*/gi,
        /^Of course(,)?\s*/i,
        /^Sure(,)?\s*/i,
        /^Certainly(,)?\s*/i,
        /^Absolutely(,)?\s*/i,
        /^I can help with that\.\s*/i,
        /^As requested\.\s*/i,
        /^Understood\.\s*/i,

        // --- Cabeçalhos e Títulos Automáticos ---
        /^\*\*roteiro anotado:\*\*\s*/im,
        /^\*\*Introdução:\*\*\s*/im,
        /^\*\*Desenvolvimento:\*\*\s*/im,
        /^\*\*Clímax:\*\*\s*/im,
        /^\*\*Conclusão:\*\*\s*/im,
        /^\*\*Call to Action:\*\*\s*/im,
        /^\*\*TEXTO REFINADO:\*\*\s*/im,
        /^\*\*Refined Text:\*\*\s*/im,
        /^\s*\*\*[^*]+\*\*\s*$/gm, // "Caçador de Títulos" genérico

        // >>>>> INÍCIO DA CORREÇÃO CIRÚRGICA <<<<<
        // Padrão para caçar e remover anotações como (Pausa), (Teaser), (Corte para), etc., que estejam em sua própria linha.
        /^\s*\((Pausa|Teaser|Corte para|Transição|Música sobe|Efeito sonoro)\)\s*$/gim,
        // >>>>> FIM DA CORREÇÃO CIRÚRGICA <<<<<

        // --- Anotações de Roteiro/Apresentação (EXPANDIDO) ---
        /^\s*Presenter Notes?:\s*.*$/gim,
        /^\s*Note to Presenter:\s*.*$/gim,
        /^\s*Narrator:\s*.*$/gim,
        /^\s*Host:\s*.*$/gim,
        /^\s*Voiceover:\s*.*$/gim,
        /^\s*VO:\s*.*$/gim,
        /^\s*On-screen text:\s*.*$/gim,
        /^\s*Title Card:\s*.*$/gim,
        
        // --- Diretrizes de Formatação (EXPANDIDO) ---
        /^\s*\[Begin\]\s*$/gim,
        /^\s*\[End\]\s*$/gim,
        /^\s*\[Scene \d+\]\s*$/gim,
        /^\s*\[Transition\]\s*$/gim,
        /^\s*\[Music\]\s*$/gim,
        /^\s*\[Sound Effect\]\s*$/gim,
        /^\s*\[Pause\]\s*$/gim,
        /^\s*\[Cue\]\s*$/gim,
        /^\s*\[Visual:\s*.*\]\s*$/gim,
        /^\s*\[Action:\s*.*\]\s*$/gim,
        /^\s*\[Character:\s*.*\]\s*$/gim,
        
        // --- Anotações Técnicas ---
        /^\s*Word count:\s*\d+\s*$/gim,
        /^\s*Estimated duration:\s*.*$/gim,
        /^\s*Style:\s*.*$/gim,
        /^\s*Tone:\s*.*$/gim,
        /^\s*Keywords?:\s*.*$/gim,
        
        // --- Frases de Transição e Finalização ---
        /^\s*In summary(,)?\s*.*$/gim,
        /^\s*To conclude(,)?\s*.*$/gim,
        /^\s*In conclusion(,)?\s*.*$/gim,
        /^\s*That's all(,)?\s*.*$/gim,
        /^\s*That's it(,)?\s*.*$/gim,
        /^\s*Thank you for listening\.\s*$/gim,
        /^\s*Let me know if you need anything else\.\s*$/gim,
        /^\s*Please let me know if you have any other requests\.\s*$/gim,
        
        // --- Padrões de Aspas (para casos onde a IA envolve o conteúdo em aspas) ---
        // Este padrão é mais seletivo para evitar remover aspas legítimas no meio do texto
        /^"""\s*/g, // Aspas triplas no início
        /\s*"""$/g, // Aspas triplas no final
    ];

    patternsToRemove.forEach(pattern => {
        cleanedText = cleanedText.replace(pattern, '');
    });

    // CAMADA 3: Limpeza Profunda Final
    // Remove quebras de linha múltiplas no início e no final
    cleanedText = cleanedText.replace(/^\s*\n+|\n+\s*$/g, '');
    
    // Remove espaços em branco extras no início e no final
    cleanedText = cleanedText.trim();

    // CAMADA 4: Proteção contra string vazia acidental
    // Se o texto foi completamente limpo, retorna uma string vazia explícita
    if (cleanedText === "") {
        return "";
    }

    // CAMADA 5: Remoção de Aspas Envolventes (caso ainda persistam após outras limpezas)
    // Apenas se a string inteira (ou quase) estiver entre aspas
    const trimmedForQuotes = cleanedText.trim();
    if (trimmedForQuotes.startsWith('"') && trimmedForQuotes.endsWith('"') && trimmedForQuotes.length > 1) {
        // Verificação adicional para evitar remover aspas no meio de uma frase válida
        const contentInside = trimmedForQuotes.substring(1, trimmedForQuotes.length - 1);
        // Se não houver aspas duplas não escapadas no meio, é seguro remover
        if (!/[^\\]"/.test(contentInside)) {
             cleanedText = contentInside;
        }
    }
    // Repetir para aspas simples, se necessário, mas com mais cautela
    // (Geralmente menos comum da IA, mas possível)
    // if (cleanedText.startsWith("'") && cleanedText.endsWith("'") && cleanedText.length > 1) {
    //     cleanedText = cleanedText.substring(1, cleanedText.length - 1);
    // }

    return cleanedText.trim();
};
// =========================================================================
// >>>>> FIM DA VERSÃO BLINDADA DE 'removeMetaComments' <<<<<
// =========================================================================




// --- INÍCIO DO NOVO MÓDULO DE NARRATIVA ---

const narrativeStructures = {
    storytelling: {
        documentary: "Documentário (Factual e Investigativo)",
        heros_journey: "Jornada do Herói (Estrutura Épica)",
        pixar_spine: "Espinha Dorsal - Pixar (Estrutura Emocional)",
        mystery_loop: "Mistério (com Loop Aberto)",
        twist: "Narrativa com Virada (Twist)"
    },
    storyselling: {
        // --- NOVAS ESTRUTURAS ADICIONADAS AQUI ---
        pas: "Problema-Agitação-Solução (PAS)",
        bab: "Antes-Depois-Ponte (BAB)",
        aida: "Atenção-Interesse-Desejo-Ação (AIDA)",
        underdog_victory: "Vitória do Azarão (Conexão e Superação)",
        discovery_mentor: "A Grande Descoberta / Mentor Secreto",
        if_not_found_create: "Não Encontrei, Então Criei (História de Origem)"
    }
};

const narrativeTooltips = {
    // Storytelling
    documentary: "Constrói um argumento com fatos, evidências e uma narração autoritária. Perfeito para vídeos expositivos.",
    heros_journey: "Conta uma história de transformação e superação. Ótimo para narrativas inspiradoras.",
    pixar_spine: "Estrutura emocional de 8 passos (Era uma vez... todo dia... até que...). Perfeita para arcos de personagem rápidos.",
    mystery_loop: "Apresenta uma pergunta no início e a responde no final. Excelente para reter a atenção.",
    twist: "Constrói uma expectativa e a quebra com uma revelação surpreendente no final.",
    
    // Storyselling
    pas: "Foca em um problema que o público tem (Problema), intensifica a dor que ele causa (Agitação) e apresenta o seu conteúdo/produto como a cura (Solução). Ideal para vendas diretas.",
    bab: "Mostra um cenário 'Antes' (o mundo com o problema), um 'Depois' (o resultado ideal) e posiciona seu conteúdo como 'a Ponte' que leva de um ao outro.",
    aida: "Clássico do marketing: primeiro captura a Atenção, depois gera Interesse, cria o Desejo pela solução e, finalmente, chama para a Ação.",
    underdog_victory: "Mostra alguém (ou uma empresa) com limitações que venceu contra tudo e todos. Gera alta conexão emocional e inspira confiança.",
    discovery_mentor: "Revela um grande segredo ou uma 'descoberta' que mudou tudo, posicionando o narrador como um mentor que guia o espectador.",
    if_not_found_create: "Conta a história de origem de um produto ou serviço, nascido de uma necessidade pessoal. 'Eu tinha esse problema, não achei solução, então criei uma'."
};

// Objeto para o popover do "Objetivo da Narrativa" (permanece o mesmo)
const narrativeGoalTooltips = {
    storytelling: {
        title: "Storytelling (Conectar & Inspirar)",
        description: "O foco é construir uma narrativa envolvente e emocional. O objetivo é fazer o público sentir, pensar e se conectar com a história. Ideal para documentários, lições de vida e conteúdo inspirador."
    },
    storyselling: {
        title: "Storyselling (Persuadir & Vender)",
        description: "Usa técnicas de narrativa para construir um argumento e levar o público a uma ação específica (comprar, inscrever-se, etc.). O foco é resolver um problema claro para o espectador. Ideal para marketing, lançamento de produtos e vídeos de vendas."
    }
};


   // ==========================================================
// >>>>> AÇÃO 1: SUBSTITUA A FUNÇÃO updateMainTooltip INTEIRA <<<<<
// ==========================================================
const updateMainTooltip = () => {
    const popoverTitle = document.getElementById('popoverTitle');
    const popoverDescription = document.getElementById('popoverDescription');
    const structureSelect = document.getElementById('narrativeStructure');

    if (!popoverTitle || !popoverDescription || !structureSelect) return;

    // AQUI ESTÁ A CORREÇÃO:
    // Se nenhuma opção estiver selecionada (selectedIndex === -1), a função para aqui.
    if (structureSelect.selectedIndex === -1) {
        // Opcional: Limpa o popover para não mostrar informação antiga.
        popoverTitle.textContent = "Selecione uma Estrutura";
        popoverDescription.textContent = "Passe o mouse sobre uma opção para ver sua descrição.";
        return; 
    }

    const selectedKey = structureSelect.value;
    const selectedText = structureSelect.options[structureSelect.selectedIndex].text;
    const descriptionText = narrativeTooltips[selectedKey] || "Descrição não encontrada.";
    
    popoverTitle.textContent = selectedText;
    popoverDescription.textContent = descriptionText;
};

        const updateNarrativeStructureOptions = () => {
    const goalSelect = document.getElementById('narrativeGoal');
    const structureSelect = document.getElementById('narrativeStructure');
    if (!goalSelect || !structureSelect) return;

    const goal = goalSelect.value;
    const savedValue = structureSelect.value; // Salva o valor atual, se houver
    structureSelect.innerHTML = ''; 

    const structures = narrativeStructures[goal];
    for (const key in structures) {
       const option = document.createElement('option');
        option.value = key;
       option.textContent = structures[key];
       structureSelect.appendChild(option);
   }
    
 // Tenta restaurar o valor que estava selecionado
    if (Array.from(structureSelect.options).some(opt => opt.value === savedValue)) {
        structureSelect.value = savedValue;
    }
    
    // Chama a nossa nova função para atualizar o texto do tooltip!
   updateMainTooltip();
   updateGoalPopover();
 };


 const updateGoalPopover = () => {
    const goalSelect = document.getElementById('narrativeGoal');
    const popover = document.getElementById('goalPopover');
    const popoverTitle = popover.querySelector('h4');
    const popoverDescription = popover.querySelector('p');

    if (!goalSelect || !popover || !popoverTitle || !popoverDescription) return;

    const selectedKey = goalSelect.value;
    const data = narrativeGoalTooltips[selectedKey];
    
    if (data) {
        popoverTitle.textContent = data.title;
        popoverDescription.textContent = data.description;
    }
};



// =========================================================================
// >>>>> BLOCO 1: SUBSTITUA SUA FUNÇÃO getBasePromptContext INTEIRA POR ESTA <<<<<
// =========================================================================
/**
 * Constrói o contexto base do prompt, agora incluindo o gancho emocional e dados de pesquisa.
 */
const getBasePromptContext = () => {
    // Coleta todos os valores dos campos do formulário
    const channelName = document.getElementById('channelName')?.value.trim() || "";
    const videoTheme = document.getElementById('videoTheme')?.value.trim() || "";
    const targetAudience = document.getElementById('targetAudience')?.value.trim() || "";
    const language = document.getElementById('languageSelect')?.value || "en";
    const languageStyle = document.getElementById('languageStyle')?.value || "";
    const videoObjective = document.getElementById('videoObjective')?.value || "";
    const speakingPace = document.getElementById('speakingPace')?.value || "";
    const narrativeStructure = document.getElementById('narrativeStructure')?.value || "";
    const narrativeTheme = document.getElementById('narrativeTheme')?.value.trim() || "";
    const narrativeTone = document.getElementById('narrativeTone')?.value || ""; // Crucial para a nova lógica
    const narrativeVoice = document.getElementById('narrativeVoice')?.value.trim() || "";
    const shockingEndingHook = document.getElementById('shockingEndingHook')?.value.trim() || "";
    const videoDescription = document.getElementById('videoDescription')?.value.trim() || "";
    const centralQuestion = document.getElementById('centralQuestion')?.value.trim() || "";
    const emotionalArc = document.getElementById('emotionalArc')?.value.trim() || "";
    const imageDescriptionEngine = document.getElementById('imageDescriptionEngine')?.value.trim() || "";
    const imageStyleSelect = document.getElementById('imageStyleSelect')?.value || "";
    const customImageStyle = document.getElementById('customImageStyle')?.value.trim() || "";
    const researchData = document.getElementById('researchData')?.value.trim() || "";
    const emotionalHook = document.getElementById('emotionalHook')?.value.trim() || "";

    // Monta o prompt base
    let context = `
    You are an expert YouTube scriptwriter and researcher for the channel "${channelName}".
    Your goal is to create highly engaging, credible, and emotionally resonant video content.
    
    **Core Project Details:**
    - Video Topic: "${videoTheme}"
    - Target Audience: "${targetAudience}"
    - Language: "${language}"
    - Video Objective: "${videoObjective}"
                        
    **Narrative & Style Instructions:**
    - Narrative Structure to use: "${narrativeStructure}"
    - Speaking Pace: "${speakingPace}"
    `;

    if (narrativeTheme) { context += `\n- Core Theme (The Big Idea): "${narrativeTheme}"`; }
    if (narrativeTone) { context += `\n- Narrative Tone (The Feeling): "${narrativeTone}"`; }
    if (narrativeVoice) { context += `\n- Narrator's Voice (The Personality): "${narrativeVoice}"`; }
    if (shockingEndingHook) { context += `\n- Shocking Ending Hook to use: "${shockingEndingHook}"`; }
    if (videoDescription) { context += `\n\n**Additional Information & Inspiration:**\n- Inspiration/Context: "${videoDescription}"`; }
    if (centralQuestion) { context += `\n- Central Question to guide the entire script: "${centralQuestion}"`; }
    if (emotionalArc) { context += `\n- Desired Emotional Arc: "${emotionalArc}"`; }

    // <<< AQUI ESTÁ A LÓGICA CONDICIONAL INTELIGENTE (v6.0) >>>
    if (emotionalHook) {
        if (narrativeTone === 'inspirador') {
            // Nova instrução poderosa para histórias inspiradoras
            context += `

**PROFUNDIDADE EMOCIONAL (REGRA MAIS IMPORTANTE):**
A história a seguir é a âncora emocional do nosso roteiro. Para que ela não pareça superficial, você DEVE "mostrar, não apenas contar".
- **Crie 'Cenas' Vívidas:** Ao longo do roteiro, em vez de apenas citar o personagem, descreva pequenos momentos e cenas.
- **Mostre a Dificuldade:** Inclua uma pequena cena ou descrição do personagem enfrentando um obstáculo real. (Ex: estudando até tarde, recebendo uma notícia ruim).
- **Mostre a Superação:** Inclua uma pequena cena ou descrição do momento de virada ou pequena vitória do personagem. (Ex: recebendo o e-mail de aprovação, vendo o primeiro resultado positivo).
- **Conecte o Micro ao Macro:** Use essas pequenas cenas para ilustrar os grandes temas do roteiro.

**Âncora Emocional:** "${emotionalHook}"
---
`;
        } else {
            // Instrução original, que funciona bem para drama e outros tons
            context += `

**CRITICAL NARRATIVE ANCHOR (THE MOST IMPORTANT RULE):**
You MUST use the following personal story as the emotional core and recurring 'human anchor' for the entire script. Weave references to this character/story throughout the introduction, development, and conclusion to make the grand historical narrative feel personal and relatable. This is the guiding thread of the story.
---
Emotional Anchor Story: "${emotionalHook}"
---
`;
        }
    }

    if (researchData) {
        context += `
**CRITICAL RESEARCH DATA & CONTEXT:**
You MUST incorporate and properly attribute the following facts, names, and sources into the script...
---
${researchData}
---
`;
    }

    if (imageStyleSelect === 'cinematic' || imageStyleSelect === 'custom') {
        context += `\n\n**Visual Style Instructions:**...`;
    }

    return context;
};



// =========================================================================
// >>>>> ADICIONE ESTAS 3 NOVAS FUNÇÕES AO SEU SCRIPT <<<<<
// =========================================================================

// Função para dirigir o CLÍMAX
const directAndGenerateClimax = async (button) => {
    const devSection = document.querySelector('#developmentSection .generated-content-wrapper');
    if (!devSection || !devSection.textContent.trim()) {
        window.showToast("Gere o Desenvolvimento primeiro para dar contexto ao Clímax.");
        return;
    }
    
    showButtonLoading(button);
    const scriptContext = getTranscriptOnly();
    const suggestionPrompt = `Analise o roteiro a seguir e sugira 3 abordagens distintas para o CLÍMAX. Responda APENAS com um array JSON de 3 strings.\nRoteiro:\n${scriptContext}`;

    try {
        const rawSuggestions = await callGroqAPI(suggestionPrompt, 800);
        const climaxSuggestions = cleanGeneratedText(rawSuggestions, true) || [];
        hideButtonLoading(button);

        const userDirective = await showInputDialog(
            'Dirija a Cena do Clímax',
            'Como você quer que o clímax se desenrole? Escolha uma sugestão ou escreva sua própria direção.',
            'Direção Personalizada:', 'Ex: Revelar que o vilão era o mentor o tempo todo.',
            climaxSuggestions
        );

        if (!userDirective) return window.showToast("Geração do clímax cancelada.");
        await handleGenerateSection(button, 'climax', 'Clímax', 'climax', userDirective);
    } catch (error) {
        hideButtonLoading(button);
        window.showToast(`Falha ao preparar o clímax: ${error.message}`);
    }
};

// Função para dirigir a CONCLUSÃO
const directAndGenerateConclusion = async (button) => {
    showButtonLoading(button);
    const scriptContext = getTranscriptOnly();
    const suggestionPrompt = `Analise o roteiro a seguir e sugira 3 mensagens ou lições finais para a CONCLUSÃO. Responda APENAS com um array JSON de 3 strings.\nRoteiro:\n${scriptContext}`;
    
    try {
        const rawSuggestions = await callGroqAPI(suggestionPrompt, 800);
        const conclusionSuggestions = cleanGeneratedText(rawSuggestions, true) || [];
        hideButtonLoading(button);

        const userDirective = await showInputDialog(
            'Dirija a Conclusão',
            'Qual é a mensagem final? O que o espectador deve levar consigo? Escolha ou crie.',
            'Mensagem Personalizada:', 'Ex: A verdadeira lição é que o fracasso ensina mais que o sucesso.',
            conclusionSuggestions
        );

        if (!userDirective) return window.showToast("Geração da conclusão cancelada.");
        await handleGenerateSection(button, 'conclusion', 'Conclusão', 'conclusion', userDirective);
        
        // Esconde o módulo de estratégia e mostra o botão do CTA
        button.closest('#conclusionStrategyModule').classList.add('hidden');
        document.getElementById('generateCtaBtn').classList.remove('hidden');
        window.showToast("Conclusão gerada! Agora, vamos para o CTA.");

    } catch (error) {
        hideButtonLoading(button);
        window.showToast(`Falha ao gerar conclusão: ${error.message}`);
    }
};

// Função para dirigir o CTA
const directAndGenerateCta = async (button) => {
    showButtonLoading(button);
    const scriptContext = getTranscriptOnly();
    const suggestionPrompt = `Com base no roteiro, sugira 3 tipos de Call to Action (CTA): um para engajamento, um para inscrição e um para um produto/link específico. Responda APENAS com um array JSON de 3 strings.\nRoteiro:\n${scriptContext}`;

    try {
        const rawSuggestions = await callGroqAPI(suggestionPrompt, 800);
        const ctaSuggestions = cleanGeneratedText(rawSuggestions, true) || [];
        hideButtonLoading(button);
        
        const userDirective = await showInputDialog(
            'Dirija o Call to Action (CTA)',
            'Qual ação você quer que o espectador tome? Seja específico.',
            'CTA Personalizado:', 'Ex: Peça para compartilharem uma história pessoal nos comentários.',
            ctaSuggestions
        );

        if (!userDirective) return window.showToast("Geração do CTA cancelada.");
        await handleGenerateSection(button, 'cta', 'Call to Action (CTA)', 'cta', userDirective);

        // Esconde o botão do CTA após o uso
        button.classList.add('hidden');

    } catch (error) {
        hideButtonLoading(button);
        window.showToast(`Falha ao gerar CTA: ${error.message}`);
    }
};



const actions = {
    'suggestStrategy': (btn) => suggestStrategy(btn),
    'startCrafting': (btn) => startCrafting(),
    'generateIdeas': (btn) => generateVideoIdeas(btn),
    'unravelEnigmas': (btn) => unravelEnigmas(btn),
    'generateOutline': (btn) => generateStrategicOutline(btn),
    'mapEmotions': (btn) => mapEmotionsAndPacing(btn),
    'generateDescription': (btn) => generateVideoDescription(btn),
    'generateTitlesAndThumbnails': (btn) => generateTitlesAndThumbnails(btn),
    'generateSoundtrack': (btn) => generateSoundtrack(btn),
    'generateIntro': (btn) => handleGenerateSection(btn, 'intro', 'Introdução', 'intro'),
    'generateDevelopment': (btn) => handleGenerateSection(btn, 'development', 'Desenvolvimento', 'development'),

    // --- Nossas novas ações com autonomia de prompt ---
    'generateClimax': (btn) => directAndGenerateClimax(btn),
    'generateConclusion': (btn) => directAndGenerateConclusion(btn),
    'generateCta': (btn) => directAndGenerateCta(btn),
    // --------------------------------------------------

    'applySuggestion': (btn) => window.applySuggestion(btn),
    'applyAllSuggestions': (btn) => applyAllSuggestions(btn),
    'applyHookSuggestion': (btn) => applyHookSuggestion(btn),
    'insertViralSuggestion': (btn) => insertViralSuggestion(btn),
    'exportProject': () => exportProject(),
    'exportPdf': () => downloadPdf(),
    'exportTranscript': () => handleCopyAndDownloadTranscript(),
    'resetProject': async () => {
        const confirmed = await showConfirmationDialog("Começar um Novo Projeto?","Isso limpará todos os campos e o trabalho realizado. Esta ação não pode ser desfeita. Deseja continuar?");
        if (confirmed) { resetApplicationState(); }
    },
    'addDevelopmentChapter': (btn) => window.addDevelopmentChapter(btn),
    'select-idea': (btn) => {
        const ideaString = btn.dataset.idea;
        if (ideaString) {
            try {
                // A decodificação de JSON aqui é um pouco mais robusta
                const ideaObject = JSON.parse(ideaString.replace(/"/g, '"'));
                document.getElementById('videoTheme').value = ideaObject.title || '';
                document.getElementById('videoDescription').value = ideaObject.videoDescription || ideaObject.angle || '';
                document.getElementById('targetAudience').value = ideaObject.targetAudience || '';
                window.showToast("Ideia selecionada! Estratégia pré-preenchida.");
                document.getElementById('inputTabsNav').scrollIntoView({ behavior: 'smooth', block: 'center' });
            } catch (e) { console.error("Falha ao processar dados da ideia:", e); }
        }
    },
    'select-enigma-idea': (btn) => {
        const ideaString = btn.dataset.idea;
        if (ideaString) {
            try {
                const ideaObject = JSON.parse(ideaString.replace(/"/g, '"'));
                document.getElementById('videoTheme').value = ideaObject.title || '';
                document.getElementById('videoDescription').value = ideaObject.synopsis || ideaObject.enigma || '';
                document.getElementById('centralQuestion').value = ideaObject.hook_question || '';
                window.showToast("Enigma selecionado! Estratégia pré-preenchida.");
                document.getElementById('inputTabsNav').scrollIntoView({ behavior: 'smooth', block: 'center' });
            } catch (e) { console.error("Falha ao processar dados da ideia de enigma:", e); }
        }
    },
    'regenerate': (btn) => window.regenerateSection(btn.dataset.sectionId),
    'copy': (btn) => {
        const content = btn.closest('.accordion-item')?.querySelector('.generated-content-wrapper');
        if (content) { window.copyTextToClipboard(content.textContent); window.showCopyFeedback(btn); }
    },
    'generate-prompts': (btn) => window.generatePromptsForSection(btn, btn.dataset.sectionId),
    'analyzeRetention': (btn) => window.analyzeSectionRetention(btn, btn.dataset.sectionId),
    'refineStyle': (btn) => window.refineSectionStyle(btn),
    'enrichWithData': (btn) => window.enrichWithData(btn),
    'suggestPerformance': (btn) => window.suggestPerformance(btn, btn.dataset.sectionId),
    'optimizeGroup': (btn) => {
        const suggestionText = btn.dataset.suggestionText;
        if (suggestionText) window.optimizeGroup(btn, suggestionText);
    },
    'deleteParagraphGroup': (btn) => {
        const suggestionText = btn.dataset.suggestionText;
        if (suggestionText) window.deleteParagraphGroup(btn, suggestionText);
    },
    'analyzeScript': (btn) => analyzeFullScript(btn),
    'analyzeHooks': (btn) => analyzeRetentionHooks(btn),
    'suggestViralElements': (btn) => suggestViralElements(btn)
};


// =========================================================================
// >>>>> FINALMENTE, ATUALIZE O SEU OBJETO 'actions' PARA USAR TUDO ISSO <<<<<
// =========================================================================



// =========================================================================
// >>>>> SUBSTITUA SUA FUNÇÃO constructScriptPrompt INTEIRA PELA VERSÃO FINAL E COMPLETA <<<<<
// =========================================================================
        /**
         * Constrói o prompt específico para cada secção do roteiro ou tipo de conteúdo.
         * @param {string} sectionName - O nome da secção (ex: 'intro', 'titles_thumbnails').
         * @param {string} sectionTitle - O título da secção para o prompt.
         * @param {string|null} outlineDirective - Uma diretriz específica do esboço estratégico para esta secção.
         * @returns {{prompt: string, maxTokens: number}} O prompt e o limite de tokens.
         */

const constructScriptPrompt = (sectionName, sectionTitle, outlineDirective = null, contextText = null) => {
    const baseContext = getBasePromptContext();
    const videoDuration = document.getElementById('videoDuration').value;
    const selectedLanguage = document.getElementById('languageSelect').value;
    const narrativeStructure = document.getElementById('narrativeStructure').value;

    const targetWords = wordCountMap[videoDuration]?.[sectionName];
    let durationInstruction = '';
    if (targetWords) {
        durationInstruction = `\n\n**CRITICAL TIMING CONSTRAINT:** The generated text for this section MUST be approximately **${targetWords} words** long to fit the video's schedule. This is a strict requirement.`;
    }

    let prompt = `${baseContext}
Você é um MESTRE ROTEIRISTA DE YOUTUBE e um ESPECIALISTA EM ENGAJAMENTO. Sua tarefa é escrever o texto CATIVANTE, ESTRATÉGICO e PERFEITAMENTE TIMBRADO para a seção **"${sectionTitle}"** do roteiro.

${durationInstruction}

**REGRAS CRÍTICAS E INEGOCIÁVEIS (ABSOLUTAMENTE OBRIGATÓRIAS):**
1.  **FOCO TOTAL E EXCLUSIVO:** Sua resposta deve ser APENAS e SOMENTE o texto a ser falado para a seção **"${sectionTitle}"**. NENHUM outro conteúdo é permitido.
2.  **RESPOSTA PURA E LIMPA:** É TERMINANTEMENTE PROIBIDO incluir qualquer preâmbulo (como "Aqui está a introdução:", "Claro, vou escrever isso"), resumos, metatextos, traduções ou qualquer texto que não seja o roteiro propriamente dito. Qualquer violação resultará em falha total.
3.  **FORMATO IMPECAVEL:** NÃO inclua NENHUM rótulo de cena, descrição de áudio, anotação técnica ou rótulo de narrador (ex: [CENA], (Música sobe), Narrador:, Host:). Retorne APENAS o conteúdo textual final que será dito em voz alta.

**NOVA REGRA PERMANENTE: MAESTRO DO RITMO NARRATIVO & ENGAJAMENTO MÁXIMO**
A partir de agora, você deve agir como um "Maestro do Ritmo" e um "Engenheiro de Engajamento". Sua escrita NÃO PODE ser monótona. Você DEVE aplicar técnicas avançadas para prender a atenção:
- **Variação Dinâmica de Frases:** Alterne estrategicamente entre frases CURTAS e DE IMPACTO (para criar tensão, ritmo e ênfase) e frases MAIS LONGAS e RICAS EM DETALHES (para descrever, aprofundar conceitos ou construir narrativas). Esta variação é essencial para o ritmo.
- **Perguntas Retóricas Envolvedoras:** Integre PERGUNTAS RETÓRICAS bem posicionadas para provocar reflexão direta no espectador e aumentar significativamente o engajamento cognitivo. (Ex: "Mas o que isso realmente significava para João?", "Você já parou para pensar quantas vezes isso acontece?").
- **Pausas e Revelações Dramáticas:** Utilize parágrafos MUITO CURTOS, ou mesmo frases soltas em um parágrafo próprio, para criar PAUSAS CALCULADAS, gerar ANTICIPAÇÃO e dar PESO MÁXIMO a revelações ou insights chave.

**AÇÃO FINAL:** Com base no contexto fornecido, escreva AGORA a seção "${sectionTitle}" com o mais alto nível de qualidade narrativa, engajamento e conformidade com as regras acima.
`;


if (finalDirective) {
        prompt += `
**DIRETIVA FINAL DO DIRETOR (A REGRA MAIS IMPORTANTE):**
Sua tarefa principal é executar esta seção seguindo a seguinte direção criativa fornecida pelo usuário. Esta é a "alma" da cena e deve ser seu foco principal.
---
**Instrução do Usuário:** "${finalDirective}"
---
`;
    }



if (contextText) {
    prompt += `
**INSTRUÇÃO DE CONTINUIDADE ESTRATÉGICA (A REGRA MAIS CRÍTICA):**
Você é um Continuador de Narrativas de elite. Sua tarefa ABSOLUTAMENTE CRÍTICA é escrever a próxima seção de forma que ela se encaixe PERFEITAMENTE na narrativa existente.

**REGRAS DE CONTINUIDADE (INEGOCIÁVEIS E ABSOLUTAMENTE OBRIGATÓRIAS):**
1.  **NÃO REPITA, NÃO ECOE:** É TERMINANTEMENTE PROIBIDO repetir ou parafrasear ideias, frases, conceitos ou até mesmo o tom/rítmo da seção anterior. O espectador já viu aquele conteúdo.
2.  **AVANCE A NARRATIVA:** Sua única função aqui é MOVER a história ou argumento PARA FRENTE. Comece EXATAMENTE onde o texto anterior parou, como se estivesse escrevendo o próximo capítulo de um livro.
3.  **INTRODUZA NOVIDADE E PROFUNDIDADE:** Esta é sua chance de revelar novas informações, aprofundar significados, explorar nuances ou iniciar o próximo grande ponto da história. Mantenha o momentum narrativo.

**TEXTO DA SEÇÃO ANTERIOR (PARA CONTEXTO E REFERÊNCIA CRÍTICA):**
---
${contextText}
---

**AÇÃO FINAL:** Com base nesta continuidade crítica, escreva AGORA a seção "${sectionTitle}", garantindo que seja uma transição FLUÍDA, logicamente impecável e totalmente LIVRE de repetições. Responda APENAS com o texto da nova seção.
`;
    }

    if (outlineDirective) {
        prompt += `\n\n**IMPORTANT STRATEGIC GUIDELINE:** For this specific section, you MUST follow this strategic plan: "${outlineDirective}"`;
    }

    prompt += `\n\nIMPORTANT: Do NOT include any scene descriptions, visual/audio cues (e.g., [SHOT], (Camera pan), (Music swells)), or speaker labels (e.g., "Narrator:", "Host:") in the generated script content. Provide only the spoken text.`;
    prompt += `\n\nABSOLUTELY NO META-COMMENTS. Do not add any explanatory text about the script itself. Your entire response must be ONLY the text to be spoken in the video, and nothing else.`;

    if (document.getElementById('centralQuestion').value.trim()) {
        prompt += `\nIf a 'Central Question' is provided, ensure every section of the script (Introduction, Development, Climax) directly contributes to exploring or answering this question. The entire video must revolve around this central theme.`;
    }
    
    // >>> BLOCO AGORA 100% COMPLETO, SEM ABREVIAÇÕES OU PLACEHOLDERS <<<
    switch (narrativeStructure) {
        case 'documentary':
            prompt += `\n\nNARRATIVE STYLE: As this is a 'Documentary', you MUST adhere to the highest standards of factual rigor and narrative clarity. Prioritize unimpeachable factual accuracy, a crystal-clear chronological timeline, and a tone of absolute authority and trustworthiness. Construct your entire argument progressively, building a solid case exclusively with verified evidence, concrete data, expert testimonials, and logical reasoning. Ensure seamless, logical progression between points, avoiding any speculative leaps. While maintaining factual integrity, actively engage the viewer's intellect by weaving suspense, intrigue, or profound curiosity directly from the historical facts and evidence presented.`;
            break;
        case 'heros_journey':
            prompt += `\n\nNARRATIVE STYLE: Following the 'Hero's Journey', you MUST structure this section with meticulous adherence to the classic archetypal beats. Center the narrative squarely on the hero's pivotal 'Call to Adventure', the crucible of 'Trials and Tribulations', or the profound moment of 'Transformation and Growth'. Your primary directive is to amplify the internal and external 'Conflict' driving the hero's journey and to vividly illustrate their 'Character Development and Metamorphosis'. Ensure every element serves to advance the hero's arc.`;
            break;
        case 'pixar_spine':
            prompt += `\n\nNARRATIVE STYLE: Following the 'Pixar Spine', you MUST meticulously structure this section to hit the core emotional beats: "Once upon a time..." (establish the world and character), "Every day..." (show the routine/status quo), "Until one day..." (inciting incident), "Because of that..." (chain of consequences and reactions), and "Until finally..." (climax and resolution). Your primary focus is to craft a deeply resonant emotional arc for the protagonist.`;
            break;
        case 'mystery_loop':
            prompt += `\n\nNARRATIVE STYLE: Following the 'Mystery Loop', you MUST build relentless intrigue and suspense with surgical precision. If this is the introduction, POSE the central, captivating mystery that hooks the viewer immediately. If it's the development, strategically ADD cryptic clues and plant skillful false leads to deepen the enigma and maintain tension. If it's the conclusion, DELIVER the satisfying, revelatory answer that resolves the central mystery with a clear and impactful payoff.`;
            break;
        case 'twist':
            prompt += `\n\nNARRATIVE STYLE: For a 'Twist' narrative, you MUST meticulously establish a clear and convincing expectation throughout the script. Your core task is to build a solid foundation of assumptions in the viewer's mind. Then, in the climax or conclusion, you MUST deliver a dramatically unexpected subversion or revelation that completely recontextualizes the viewer's understanding, creating a powerful and unforgettable payoff.`;
            break;
        case 'underdog_victory':
            prompt += `\n\nNARRATIVE STYLE: For 'Underdog Victory', you MUST powerfully emphasize the protagonist's struggles, their severe lack of resources, and the immense, almost insurmountable odds they face. Your core objective is to forge a deep emotional connection, making the audience genuinely root for the underdog's triumph.`;
            break;
        case 'discovery_mentor':
            prompt += `\n\nNARRATIVE STYLE: For 'Underdog Victory', you MUST powerfully emphasize the protagonist's severe struggles, their critical lack of resources, and the overwhelming, near-insurmountable odds they face. Your primary directive is to forge an intense emotional bond, making the audience genuinely root for the underdog's ultimate triumph.`;
            break;
        case 'if_not_found_create':
            prompt += `\n\nNARRATIVE STYLE: For 'If Not Found, Create', you MUST tell the compelling origin story. Focus sharply on the protagonist's deep personal frustration, the exhaustive search for a solution, and the pivotal 'aha!' moment of creation.`;
            break;
        case 'pas':
            prompt += `\n\nNARRATIVE STYLE: Using 'Problem-Agitate-Solve', you MUST sharply define the core pain point (Problem), intensely amplify the associated negative emotions (Agitate), and then deliver the definitive, clear solution (Solve).`;
            break;
        case 'bab':
            prompt += `\n\nNARRATIVE STYLE: Using 'Before-After-Bridge', you MUST paint a vivid picture of the negative 'Before' state, the ideal 'After' state, or present the content as the crucial 'Bridge' that connects them.`;
            break;
    }

    let maxTokens = 2000;

    switch (sectionName) {
        case 'outline':
                prompt = `${baseContext}

Você é um MESTRE ROTEIRISTA e um ESTRATEGISTA DE CONTEÚDO DE ALTO NÍVEL. Sua tarefa é criar um "beat sheet" ou um esboço estratégico DETALHADO, ACIONÁVEL e PERFEITAMENTE ALINHADO com o contexto fornecido.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (ABSOLUTAMENTE INEGOCIÁVEIS):**
1.  **JSON PURO E PERFEITO:** Sua resposta inteira deve ser APENAS um objeto JSON válido, começando com \`{\` e terminando com \`}\`. NENHUM outro texto, comentário, metatexto ou explicação é permitido. Pense nisso como uma resposta de API pura e impecável.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar obrigatoriamente aspas duplas (\`"\`).
3.  **CHAVES EXATAS E OBRIGATÓRIAS:** O objeto DEVE conter EXATAMENTE estas cinco chaves: "introduction", "development", "climax", "conclusion", e "cta".
4.  **TIPOS EXATOS:** O valor de cada chave DEVE ser uma string.
5.  **CONTEÚDO DAS STRINGS (ACIONÁVEL E ESTRATÉGICO):** Cada string deve conter uma descrição CLARA, ESPECÍFICA e ACIONÁVEL do objetivo narrativo, emocional e estratégico daquela seção. Evite descrições vagas ou genéricas. Foque no QUE será feito e QUAL o impacto esperado.

**INSTRUÇÕES DETALHADAS PARA CADA SEÇÃO DO ESBOÇO:**
-   **"introduction" (Introdução com Impacto):** Defina com precisão o objetivo da introdução. Qual é o GANCHO inicial? Que PERGUNTA central ou emoção você quer instigar desde o início para prender a atenção?
-   **"development" (Desenvolvimento com Profundidade):** Liste e descreva os PONTOS PRINCIPAIS que serão abordados no desenvolvimento. Como a informação será ESTRUTURADA? Que ARGUMENTOS, EVIDÊNCIAS ou HISTÓRIAS serão usados para construir a narrativa?
-   **"climax" (Clímax com Tensão/Revelação):** Identifique qual é o MOMENTO DE MAIOR TENSÃO, REVELAÇÃO ou IMPACTO EMOCIONAL. O que o espectador DEVE SENTIR ou ENTENDER neste ponto crucial?
-   **"conclusion" (Conclusão com Takeaway):** Explique como a LIÇÃO PRINCIPAL será RESUMIDA e REFORÇADA. Qual TAKEAWAY ou INSIGHT você quer deixar gravado na mente do espectador?
-   **"cta" (Chamada para Ação com Propósito):** Defina qual é a CHAMADA PARA AÇÃO ESPECÍFICA e como ela se conecta com o conteúdo do vídeo. O que você quer que o espectador FAÇA após assistir? (Ex: Comentar, Compartilhar, Se Inscrever, Visitar um Link).

**EXEMPLO DE FORMATO PERFEITO E OBRIGATÓRIO (SIGA ESTE EXATO MODELO):**
{
  "introduction": "Começar com uma pergunta retórica chocante sobre a mortalidade para prender a atenção imediatamente e levantar a questão central da fé diante da finitude.",
  "development": "Construir a narrativa explorando o luto profundo das irmãs de Lázaro, estabelecendo a conexão humana com a história e desenvolvendo o contexto emocional e teológico.",
  "climax": "O momento de maior tensão no túmulo, quando Jesus chama Lázaro após quatro dias de morte, criando a expectativa máxima para o milagre e o ponto alto da narrativa.",
  "conclusion": "Resumir a lição central: o verdadeiro milagre não é desafiar a morte em si, mas demonstrar o poder absoluto da fé e da promessa divina, conectando ao tema central.",
  "cta": "Fazer uma chamada para ação suave, convidando o espectador a refletir sobre um momento em que sentiu a presença de Deus em meio às dificuldades e compartilhar nos comentários."
}

**AÇÃO FINAL:** Com base no contexto estratégico fornecido, crie AGORA o esboço JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE todas as regras, instruções e o exemplo acima. Responda APENAS com o objeto JSON.
`;
            maxTokens = 2000;
            break;


// =========================================================================
// >>>>> BLOCO 'intro' EVOLUÍDO E BLINDADO <<<<<
// =========================================================================
case 'intro':
    const shockingHook = document.getElementById('shockingEndingHook')?.value.trim();
    
    prompt += `\n\n**INSTRUÇÕES CRÍTICAS E ESTRATÉGICAS PARA A INTRODUÇÃO (ESTILO YOUTUBE VIRAL DE ALTO IMPACTO):**
Sua tarefa é escrever a **Introdução** do vídeo com o ÚNICO objetivo de criar um "hook" MAGNÉTICO e IRRESISTÍVEL que prenda a atenção do espectador nos CRUCIAIS primeiros 15-35 segundos.`;


    // <<< LÓGICA CONDICIONAL INTELIGENTE E BLINDADA >>>
    if (shockingHook) {
        prompt += `\n\n**REGRA DE HOOK PRIORITÁRIA ABSOLUTA (A ÚNICA E MAIS IMPORTANTE):**
1.  **INÍCIO OBRIGATÓRIO:** Você DEVE, SEM EXCEÇÕES, começar o roteiro EXATAMENTE com a frase fornecida no campo 'Desfecho Chocante'.
2.  **NADA ANTES:** É TERMINANTEMENTE PROIBIDO adicionar qualquer palavra, frase ou elemento antes desta frase obrigatória.
3.  **CONTEXTO E MISTÉRIO PÓS-HOOK:** Imediatamente após a frase obrigatória, sua tarefa é construir o restante da introdução de forma brilhante, criando um profundo MISTÉRIO e uma irresistível CURIOSIDADE sobre como a história chegou a esse ponto dramático.

        **REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (SIGA EXATAMENTE):**
1. **JSRO E PERFEITO:** Sua resposta inteira deve ser APENAS o texto escrito, sem nenhum comentário, preâmbulo ou metadado adicional.
2. **SEM ADIÇÕES INDESEJADAS:** NÃO ADICIONE NENHUN COMENTÁRIO FINAL, FEEDBACK OU OUTRO TEXTO QUE NÃO FAÇA PARTE DO CONTEÚDO PRINCIPAL.
3. **CLAREZA TOTAL:** Certifique-se de que a resposta contenha apenas o texto escrito, exatamente como solicitado.


**FRASE OBRIGATÓRIA A SER USADA EXATAMENTE NO INÍCIO:** "${shockingHook}"`;
    } else {
        prompt += `\n\n**REGRAS DE CONTEÚDO E CRIAÇÃO DE HOOK VIRAL (ESCOLHA A MAIS IMPACTANTE):**
1.  **PROIBIDO COMEÇO LENTO OU ÓBVIO:** É ABSOLUTAMENTE IMPERMISSÍVEL um início fraco. Você DEVE escolher, de forma estratégica, UMA das seguintes técnicas de gancho inicial:
    - **In Media Res (No Meio da Ação):** Mergulhe diretamente no momento de MÁXIMA ação, tensão ou emoção da história. Prenda o espectador instantaneamente no calor da ação.
    - **Estatística Chocante e Contra-Intuitiva:** Apresente um DADO surpreendente e extremamente difícil de acreditar, que desafie as expectativas do espectador e o force a prestar atenção.
    - **Pergunta Provocativa e Pessoal:** Faça uma PERGUNTA DIRETA, EMOCIONAL e que crie uma conexão IMEDIATA e PESSOAL com o espectador, fazendo-o refletir intensamente.
2.  **CRIAÇÃO OBRIGATÓRIA DE UM 'LOOP ABERTO' (Engajamento Garantido):**
    - Após o gancho inicial, você DEVE imediatamente introduzir uma promessa clara, uma revelação parcial ou uma pergunta INTRIGANTE.
    - Este 'loop aberto' deve ser tão cativante que o espectador SINTA A NECESSIDADE de assistir o vídeo inteiro para ter suas dúvidas respondidas ou ver o mistério resolvido.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (SIGA EXATAMENTE):**
1. **JSRO E PERFEITO:** Sua resposta inteira deve ser APENAS o texto escrito, sem nenhum comentário, preâmbulo ou metadado adicional.
2. **SEM ADIÇÕES INDESEJADAS:** NÃO ADICIONE NENHUN COMENTÁRIO FINAL, FEEDBACK OU OUTRO TEXTO QUE NÃO FAÇA PARTE DO CONTEÚDO PRINCIPAL.
3. **CLAREZA TOTAL:** Certifique-se de que a resposta contenha apenas o texto escrito, exatamente como solicitado.

    `;
    }

    prompt += `\n\n**REGRAS GERAIS E CRÍTICAS PARA A INTRODUÇÃO (SIGA EXATAMENTE):**
- **Concisão e Poder:** Seja EXTREMAMENTE conciso e direto. Use frases CURTAS, DINÂMICAS e com PODER MÁXIMO de impacto. Evite rodeios.
- **Foco Absoluto:** O foco ÚNICO e INQUESTIONÁVEL é criar CURIOSIDADE INTENSA e URGENTE para que o espectador NÃO TENHA DÚVIDA de que deve continuar assistindo.`;

    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
        prompt += `\n\n**IMPORTANTE E INEGOCIÁVEL: Todo o texto da introdução DEVE ser escrito em Português do Brasil (pt-br).**`;
    }

    maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 500;
    break;
// =========================================================================
// >>>>> FIM DO BLOCO 'intro' EVOLUÍDO <<<<<
// =========================================================================

// =========================================================================
// >>>>> BLOCO 'development' EVOLUÍDO E BLINDADO <<<<<
// =========================================================================
case 'development':
    prompt += `\n\n**INSTRUÇÕES CRÍTICAS E ESTRATÉGICAS PARA O DESENVOLVIMENTO (ESTILO YOUTUBE VIRAL DE MÁXIMA RETENÇÃO):**
Sua tarefa é escrever o **Desenvolvimento** do roteiro. Esta é a SEÇÃO MAIS LONGA E CRUCIAL, onde você aprofunda o tema com riqueza de detalhes. Seu OBJETIVO PRIMÁRIO e INQUESTIONÁVEL aqui é **manter a RETENÇÃO MÁXIMA** do espectador do início ao fim desta parte.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (SIGA EXATAMENTE):**
1. **JSRO E PERFEITO:** Sua resposta inteira deve ser APENAS o texto escrito, sem nenhum comentário, preâmbulo ou metadado adicional.
2. **SEM ADIÇÕES INDESEJADAS:** NÃO ADICIONE NENHUN COMENTÁRIO FINAL, FEEDBACK OU OUTRO TEXTO QUE NÃO FAÇA PARTE DO CONTEÚDO PRINCIPAL.
3. **CLAREZA TOTAL:** Certifique-se de que a resposta contenha apenas o texto escrito, exatamente como solicitado.

**REGRAS DE CONTEÚDO, RITMO E ESTRATÉGIA DE ENGAJAMENTO (SIGA EXATAMENTE):**
1.  **ESTRUTURA EM BLOCOS TEMÁTICOS CLAROS:** Apresente as informações de forma organizada em blocos temáticos distintos e logicamente conectados. Cada bloco deve explorar um aspecto específico e essencial do tema, avançando a narrativa de forma coesa.
2.  **INTEGRAÇÃO OBRIGATÓRIA DE GANCHOS DE RETENÇÃO:** Para evitar ABSOLUTAMENTE qualquer monotonia, densidade ou queda de atenção, você DEVE inserir, de forma ESTRATÉGICA, um "gancho de retenção" a cada 2 ou 3 parágrafos de informação pura. Estes ganchos são FUNDAMENTAIS para quebrar o padrão e re-engajar o espectador continuamente. Use uma das seguintes técnicas com maestria:
    - **Teaser / Mini Loop Aberto:** Crie um pequeno mistério ou promessa que será resolvida/emphasized em breve, gerando antecipação. (Ex: "...mas eles não sabiam que a parte mais difícil ainda estava por vir.", "E a solução aparentemente simples que ele encontrou é a razão pela qual esta empresa vale bilhões hoje.").
    - **Pergunta de Engajamento Direto:** Faça uma pergunta PESSOAL e RELEVANTE ao público, incentivando fortemente a participação ativa nos comentários. (Ex: "O que você teria feito nessa situação crítica? Deixa sua opinião aqui nos comentários.", "Você já se deparou com esse fato surpreendente? Conta aqui embaixo.").
3.  **EQUILÍBRIO PERFEITO ENTRE INFORMAÇÃO E NARRATIVA:** Mantenha um equilíbrio IMPECAVEL entre fornecer conteúdo valioso e densidade informativa, e manter a narrativa fluida, envolvente e cativante. SEMPRE conecte os dados, fatos e argumentos de volta à história principal ou ao ganho emocional/curiosidade estabelecido no início.`;

    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
        prompt += `\n\n**IMPORTANTE E INEGOCIÁVEL: Todo o texto do desenvolvimento DEVE ser escrito em Português do Brasil (pt-br).**`;
    }
    maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 1500;
    break;
// =========================================================================
// >>>>> FIM DO BLOCO 'development' EVOLUÍDO <<<<<
// =========================================================================
// =========================================================================
// >>>>> BLOCO 'titles_thumbnails' EVOLUÍDO E BLINDADO <<<<<
// =========================================================================
case 'titles_thumbnails':
    prompt = `${baseContext}
**TAREFA ESTRATÉGICA CRÍTICA: GERAR METADADOS DE MÁXIMO IMPACTO PARA YOUTUBE**
Você é uma API de geração de metadados de ALTO DESEMPENHO que retorna APENAS um objeto JSON, otimizado para cliques e engajamento máximo.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (ABSOLUTAMENTE INEGOCIÁVEIS):**
1.  **JSON PURO E PERFEITO:** Sua resposta inteira deve ser APENAS um objeto JSON válido, começando com \`{\` e terminando com \`}\`. NENHUM outro texto, comentário ou metadado deve ser incluído. Pense nisso como uma resposta de API pura e impecável.
2.  **ASPAS DUPLAS, SEMPRE E EXCLUSIVAMENTE:** TODAS as chaves e valores de texto DEVEM usar obrigatoriamente aspas duplas (\`"\`). É TERMINANTEMENTE PROIBIDO o uso de aspas simples (\`'\`) ou crases (\`\`) para delimitar QUALQUER string.
3.  **ESTRUTURA OBRIGATÓRIA E EXATA:** O objeto JSON DEVE conter EXATAMENTE duas chaves principais: "titles" e "thumbnails".
    - O valor de "titles" DEVE ser um array contendo EXATAMENTE 5 strings, cada uma sendo um título otimizado para CTR (Click-Through Rate).
    - O valor de "thumbnails" DEVE ser um array contendo EXATAMENTE 3 objetos.
    - CADA objeto dentro do array "thumbnails" DEVE ter EXATAMENTE duas chaves: "title" e "description".
4.  **PROIBIÇÃO ABSOLUTA DE ASPAS INTERNAS DUPLAS:** Dentro dos valores de string, especialmente nas descrições ("description"), É ESTRITAMENTE PROIBIDO o uso de aspas duplas internas. Se precisar dar ênfase ou citar algo, USE OBRIGATORIAMENTE aspas simples (\`'\`).

**DIRETRIZES ESTRATÉGICAS PARA CONTEÚDO DE MÁXIMO IMPACTO:**
- **Para "titles":** Gere títulos que sejam HIPNÓTICOS, provocando CURIOSIDADE INTENSA e prometendo valor único. Utilize técnicas comprovadas de otimização de títulos (números, urgência, benefício claro, perguntas retóricas, palavras-chave fortes). Cada título deve ser uma promessa específica e irresistível.
- **Para "thumbnails":** As descrições devem guiar a criação de imagens VISUALMENTE IMPACTANTES e CLARAMENTE compreensíveis. Foque em contraste, emoção facial, elementos visuais fortes, textos sugestivos e clareza absoluta. Cada ideia de thumbnail deve ser única e complementar um dos títulos gerados.

**EXEMPLO DE RESPOSTA PERFEITA E OBRIGATÓRIO (SIGA ESTE EXATO MODELO):**
{
  "titles": [
    "Título 1: Curto, direto e com um gancho irresistível",
    "Título 2: Com uma pergunta que o espectador precisa responder",
    "Título 3: Criando urgência e uma sensação de 'não posso perder'",
    "Título 4: Focado no benefício claro e transformador",
    "Título 5: Um pouco controverso para gerar curiosidade"
  ],
  "thumbnails": [
    { "title": "Ideia de Thumbnail 1", "description": "Close-up em um objeto misterioso com uma seta vermelha chamando atenção." },
    { "title": "Ideia de Thumbnail 2", "description": "Foto de uma pessoa com expressão de choque absoluto e texto em destaque: 'VOCÊ NÃO VAI ACREDITAR NO QUE ACONTECEU DEPOIS!'." },
    { "title": "Ideia de Thumbnail 3", "description": "Gráfico de 'Antes vs Depois' mostrando uma transformação dramática e inacreditável." }
  ]
}

**AÇÃO FINAL E CRÍTICA:** Com base no contexto estratégico fornecido, analise profundamente e gere AGORA o objeto JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE todas as regras, diretrizes e o exemplo acima. Responda APENAS com o objeto JSON.
`;
    maxTokens = 2000;
    break;
// =========================================================================
// >>>>> FIM DO BLOCO 'titles_thumbnails' EVOLUÍDO <<<<<
// =========================================================================
// =========================================================================
// >>>>> BLOCO 'description' EVOLUÍDO E BLINDADO <<<<<
// =========================================================================
case 'description':
    const languageName = new Intl.DisplayNames([selectedLanguage], { type: 'language' }).of(selectedLanguage);
    prompt = `${baseContext}
            
**TAREFA ESTRATÉGICA CRÍTICA: GERAR DESCRIÇÃO OTIMIZADA DE MÁXIMO IMPACTO PARA YOUTUBE E HASHTAGS ALVADAS PELO SUCESSO**
Sua tarefa é gerar uma descrição otimizada de ALTO IMPACTO para um vídeo do YouTube e um conjunto de hashtags RELEVANTES E ESTRATÉGICAS, no idioma ${languageName}.

**REGRAS DE FORMATAÇÃO E OTIMIZAÇÃO (ABSOLUTAMENTE INEGOCIÁVEIS):**
1.  **INÍCIO MAGNÉTICO (2-3 Frases):** Comece IMEDIATAMENTE com 2 ou 3 frases CONCISAS e PODEROSAS que RESUMEM o ESSENCIAL do vídeo e INTEGREM as PALAVRAS-CHAVE PRINCIPAIS do tema de forma NATURAL e ESTRATÉGICA. Este início deve AGARRAR a atenção de quem lê a descrição.
2.  **APROFUNDAMENTO VALIOSO (1 Parágrafo Rico):** Adicione UM ÚNICO parágrafo que APROFUNDE SIGNIFICATIVAMENTE o que o espectador APRENDERÁ, DESCobrirá ou GANHARÁ ao assistir o vídeo. Seja ESPECÍFICO sobre os insights, dicas ou revelações contidos no conteúdo.
3.  **CHAMADA PARA AÇÃO IRRESISTÍVEL (CTA Final):** Finalize a descrição com uma CHAMADA PARA AÇÃO CLARA, CONVINCENTE e IRRESISTÍVEL, incentivando ações como se inscrever, curtir, comentar, compartilhar ou visitar um link. Torne o CTA uma extensão natural e desejada da experiência do vídeo.
4.  **SEPARAÇÃO ESTRUTURAL OBRIGATÓRIA:** Após a descrição completa (incluindo o CTA), você DEVE adicionar uma LINHA EM BRANCO e então incluir EXATAMENTE a linha "Hashtags:".
5.  **LISTA DE HASHTAGS ESTRATÉGICA (10 Hashtags):** Liste EXATAMENTE 10 hashtags RELEVANTES. Estruture-as com LÓGICA: comece com 2-3 hashtags MAIS AMPLAS e POPULARES, seguidas por 4-5 hashtags de MÉDIO ALCANCE, e finalize com 2-3 hashtags ALTAMENTE ESPECÍFICAS e NICHO. Cada hashtag DEVE ser precedida pelo símbolo # e separada das demais por um espaço.

**AÇÃO FINAL E CRÍTICA:** Responda APENAS com a descrição otimizada (incluindo o CTA) e a lista de hashtags, conforme as regras acima. NENHUM outro texto, explicação ou metadado deve ser incluído na sua resposta.`;
    maxTokens = 700;
    break;
// =========================================================================
// >>>>> FIM DO BLOCO 'description' EVOLUÍDO <<<<<
// =========================================================================
    }
    
    return { prompt, maxTokens };
};

        /**
         * Faz uma chamada à API Groq através de uma função Netlify.
         * @param {string} prompt - O prompt a ser enviado para a IA.
         * @param {number} maxTokens - O número máximo de tokens para a resposta.
         * @returns {Promise<string>} A resposta bruta da IA.
         * @throws {Error} Se a chamada à API falhar.
         */
        const callGroqAPI = async (prompt, maxTokens) => {
            const proxyUrl = "/.netlify/functions/groq"; // Endpoint do proxy

            const payload = {
                prompt: prompt,
                maxTokens: maxTokens
            };

            const request = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetch(proxyUrl, request);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Erro desconhecido do servidor proxy.' } }));
                    throw new Error(`Erro na API via Proxy: ${errorData.error?.message || 'Erro do servidor'}`);
                }
                const result = await response.json();
                const rawContent = result.choices?.[0]?.message?.content;
                if (rawContent) { return rawContent; }
                else { throw new Error("Resposta inesperada da API Groq."); }
            } catch (error) {
                console.error("Fetch da API via Netlify Function falhou:", error);
                window.showToast(`Falha na API: ${error.message}`);
                throw error;
           }
        };

        /**
         * Valida os inputs essenciais antes de gerar conteúdo.
         * @returns {boolean} True se os inputs são válidos, caso contrário, false.
         */
             
        /**
         * Itera sobre todas as seções do roteiro na ordem correta,
         * renumera globalmente todas as cenas E recalcula o timestamp
         * com base na duração estimada pela IA para cada cena.
         */
        
    
        /**
         * Escapa um objeto JSON para ser usado com segurança dentro de um atributo onclick.
         * @param {object} idea - O objeto da ideia a ser escapado.
         * @returns {string} Uma string JSON segura para HTML.
         */
        const escapeIdeaForOnclick = (idea) => {
            // Primeiro, converte o objeto para uma string JSON
            const jsonString = JSON.stringify(idea);
            // Em seguida, substitui os caracteres que quebram o HTML
            // Escapa aspas duplas, aspas simples e barras invertidas
            return jsonString.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/\\/g, '&#92;');
        };

        // ==========================================================
        // ===== COLE ESTA FUNÇÃO FALTANTE NO SEU JAVASCRIPT =====
        // ==========================================================
        /**
         * Lida com a visibilidade da barra de ação flutuante com base na posição de rolagem.
         */
        window.handleFloatingActionBar = () => {
            const bar = document.getElementById('floatingActionBar');
            // O gatilho para a barra aparecer será a grade de inputs principais
            const triggerElement = document.getElementById('mainInputsTabs'); 

            if (!bar || !triggerElement) {
                return; // Sai da função se os elementos não existirem
            }

            // Ponto de gatilho: quando o final do 'mainInputsGrid' passar pelo topo da tela
            const triggerPoint = triggerElement.offsetTop + triggerElement.offsetHeight;

            if (window.scrollY > triggerPoint) {
                bar.classList.add('visible');
            } else {
                bar.classList.remove('visible');
            }
        };





        // =========================================================================
// >>>>> AÇÃO 1: SUBSTITUA A FUNÇÃO createScriptSectionPlaceholder COMPLETA <<<<<
// =========================================================================
/**
 * Cria e retorna o HTML de um placeholder para uma seção do roteiro.
 * @param {string} sectionId - O ID base da seção (ex: 'intro').
 * @param {string} title - O título da seção (ex: 'Introdução').
 * @param {string} buttonId - O ID do botão principal que gera esta seção (ex: 'generateIntroBtn').
 * @returns {string} O HTML do placeholder da seção.
 */


const createScriptSectionPlaceholder = (sectionId, title, buttonId, actionName) => {
    const containerId = `${sectionId}Section`;
    
    return `
        <div id="${containerId}" class="script-section card card-placeholder mb-4 animate-fade-in flex justify-between items-center">
            <h3 class="font-semibold text-lg text-gray-700 dark:text-gray-300">${title}</h3>
            <button id="${buttonId}" data-action="${actionName}" class="btn btn-primary">
                <i class="fas fa-magic mr-2"></i>Gerar
            </button>
        </div>
    `;
};



// =========================================================================
// >>>>> VERSÃO FINAL DE addDevelopmentChapter COM PROMPT "ANTI-ECO" <<<<<
// =========================================================================
/**
 * Adiciona um novo capítulo ao desenvolvimento, com prompt refinado para evitar repetição do título e "ecos".
 * @param {HTMLElement} button - O botão que foi clicado.
 */
// =========================================================================
// >>>>> VERSÃO FINAL E BLINDADA DE 'addDevelopmentChapter' <<<<<
// =========================================================================
/**
 * Adiciona um novo capítulo ao desenvolvimento, com prompt refinado para evitar repetição do título e "ecos".
 * @param {HTMLElement} button - O botão que foi clicado.
 */
window.addDevelopmentChapter = async (button) => {
    const devSection = document.getElementById('developmentSection');
    const contentWrapper = devSection?.querySelector('.generated-content-wrapper');
    const existingText = contentWrapper?.textContent.trim();

    if (!existingText) {
        window.showToast("Gere o desenvolvimento inicial primeiro.");
        return;
    }

    showButtonLoading(button);

    try {
        // >>>>> PROMPT BLINDADO PARA GERAÇÃO DE SUGESTÕES <<<<<
        const suggestionPrompt = `Você é um ESTRATEGISTA DE ROTEIRO DE ALTO NÍVEL especializado em continuidade narrativa. Sua tarefa é sugerir 3 temas distintos, coerentes e logicamente conectados ao fluxo narrativo existente para o PRÓXIMO CAPÍTULO do desenvolvimento.

**REGRAS CRÍTICAS DE SINTAXE E CONTEÚDO (SIGA EXATAMENTE):**
1.  **JSON PURO E PERFEITO:** Sua resposta inteira deve ser APENAS um array JSON válido, começando com \`[\` e terminando com \`]\`. NENHUM outro texto, comentário ou explicação é permitido.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as strings dentro do array DEVEM usar obrigatoriamente aspas duplas (\`"\`).
3.  **VÍRGULAS OBRIGATÓRIAS:** CADA string no array, EXCETO a ÚLTIMA, DEVE ser seguida por uma vírgula (\`,\`).
4.  **CONTEÚDO:** O array deve conter EXATAMENTE 3 strings. Cada string deve ser um título ou tema sugestivo e específico para um capítulo.
5.  **ORIGINALIDADE E RELEVÂNCIA:** Cada sugestão deve ser ORIGINAL, RELEVANTE para o contexto e avançar a narrativa de forma lógica. Evite temas vagos ou repetidos.

**ROTEIRO ATUAL (PARA ANÁLISE DE CONTINUIDADE):**
---
${existingText.slice(-2500)} // Aumentado levemente o contexto
---

**EXEMPLO DE FORMATO PERFEITO E OBRIGATÓRIO (SIGA ESTE EXATO MODELO):**
["A Batalha dos Números", "O Legado Fora de Campo", "Momentos Decisivos"]

**AÇÃO FINAL:** Com base no roteiro fornecido, gere AGORA o array JSON com as 3 sugestões, seguindo EXATAMENTE todas as regras acima.`;

        const rawSuggestions = await callGroqAPI(suggestionPrompt, 400); // Aumentado levemente o token limit
        const chapterSuggestions = cleanGeneratedText(rawSuggestions, true) || [];
        
        hideButtonLoading(button);

        // >>>>> INTERFACE DE USUÁRIO PARA ESCOLHA DO TEMA <<<<<
        const chapterTheme = await showInputDialog(
            'Adicionar Novo Capítulo',
            'Escolha uma sugestão da IA ou digite seu próprio tema abaixo.',
            'Ou crie um tema personalizado:',
            'Digite seu tema aqui...',
            chapterSuggestions
        );

        if (!chapterTheme) {
            window.showToast("Operação cancelada.");
            return;
        }

        showButtonLoading(button);

        // >>>>> PROMPT BLINDADO PARA GERAÇÃO DO CONTEÚDO DO CAPÍTULO <<<<<
        const basePrompt = getBasePromptContext();
        const continuationPrompt = `${basePrompt}
        
**TAREFA ESTRATÉGICA CRÍTICA: GERAR CONTEÚDO DE CAPÍTULO DE DOCUMENTÁRIO INVESTIGATIVO**
Você é um ROTEIRISTA DE DOCUMENTÁRIOS INVESTIGATIVOS de elite. Sua tarefa é escrever um NOVO CAPÍTULO CATIVANTE e INFORMAÇÃO-RIQUÍSSIMO para um roteiro existente.

**TEMA OBRIGATÓRIO E CENTRAL PARA ESTE CAPÍTULO:** "${chapterTheme}"

**INSTRUÇÕES CRÍTICAS E ESTRATÉGICAS DE CONTINUIDADE (SIGA EXATAMENTE):**
1.  **NÃO REPITA, NÃO ECOE:** O texto fornecido abaixo é o roteiro escrito até agora. É TERMINANTEMENTE PROIBIDO repetir ou parafrasear quaisquer informações, ideias, frases ou conceitos já contidos nele. O espectador já viu aquele conteúdo.
2.  **AVANCE A NARRATIVA ESPECIFICAMENTE:** Sua única função aqui é MOVER a história ou investigação PARA FRENTE, explorando EXCLUSIVAMENTE o tema "${chapterTheme}". Comece EXATAMENTE onde o texto anterior parou, como se estivesse escrevendo o próximo capítulo de um livro.
3.  **INTRODUZA NOVIDADE E PROFUNDIDADE:** Esta é sua chance de revelar novas informações, aprofundar significados ou explorar nuances específicas do tema "${chapterTheme}". Mantenha o momentum narrativo e investigativo.

**REGRAS DE FORMATAÇÃO E CONTEÚDO (INEGOCIÁVEIS):**
- **RESPOSTA PURA E LIMPA:** Sua resposta deve ser APENAS o texto do roteiro a ser falado. NENHUM outro conteúdo é permitido.
- **SEM TÍTULOS NO CONTEÚDO:** É ESTRITAMENTE PROIBIDO incluir o título do capítulo ("${chapterTheme}") ou qualquer outro subtítulo dentro do corpo do texto gerado. Apenas o conteúdo narrativo/investigativo a ser dito.
- **FOCO INVESTIGATIVO E FACTUAL:** Mantenha um tom rigorosamente **factual, investigativo e baseado em evidências** durante todo o capítulo. Seja preciso e objetivo.
- **CONCENTRAÇÃO TEMÁTICA ABSOLUTA:** Foque-se intensamente em apresentar informações, eventos, dados e a narrativa específica do tema "${chapterTheme}". Toda a escrita deve girar em torno deste eixo.
- **PROIBIÇÃO ABSOLUTA DE CONCLUSÕES GENÉRICAS:** É ESTRITAMENTE PROIBIDO adicionar conclusões gerais, opiniões pessoais, sermões, moralidades ou chamadas para ação genéricas no final do capítulo. Deixe as reflexões finais e as chamadas para mudança para a seção de conclusão do roteiro. O capítulo deve terminar com o desenvolvimento do tema, não com uma conclusão.

**ROTEIRO ESCRITO ATÉ AGORA (PARA CONTEXTO CRÍTICO E REFERÊNCIA):**
---
${existingText}
---

**AÇÃO FINAL E CRÍTICA:** Com base nestas instruções rigorosas, escreva AGORA o novo capítulo sobre "${chapterTheme}", garantindo que seja uma transição FLUÍDA, logicamente impecável, totalmente LIVRE de repetições e estritamente focado no tema. Responda APENAS com o texto do capítulo.
`;

        const rawResult = await callGroqAPI(continuationPrompt, 4000);
        const newChapter = removeMetaComments(rawResult.trim());
        
        // >>>>> PROCESSAMENTO E INSERÇÃO DO NOVO CONTEÚDO <<<<<
        if (!newChapter || newChapter.trim() === "") {
             throw new Error("A IA não retornou um conteúdo válido para o novo capítulo.");
        }

        const chapterTitleHtml = `<div class="font-bold text-lg mt-6 mb-3 pb-1 border-b border-gray-300 dark:border-gray-600">Capítulo: ${DOMPurify.sanitize(chapterTheme)}</div>`;
        
        const existingParagraphsCount = contentWrapper.querySelectorAll('div[id]').length;
        const newParagraphs = newChapter.split('\n').filter(p => p.trim() !== '');
        
        if (newParagraphs.length === 0) {
             throw new Error("O conteúdo do capítulo não pôde ser dividido em parágrafos.");
        }

        const newContentWithDivs = newParagraphs.map((p, index) => 
            `<div id="development-p-${existingParagraphsCount + index}">${DOMPurify.sanitize(p)}</div>`
        ).join('');

        contentWrapper.insertAdjacentHTML('beforeend', chapterTitleHtml + newContentWithDivs);
        
        // >>>>> INVALIDAÇÃO E ATUALIZAÇÃO DE COMPONENTES RELACIONADOS <<<<<
        invalidateAndClearPerformance(devSection);
        invalidateAndClearPrompts(devSection);
        updateAllReadingTimes();
        
        window.showToast("Novo capítulo adicionado com sucesso!");
        // Scroll para o novo título do capítulo para melhor UX
        contentWrapper.lastElementChild.previousElementSibling?.scrollIntoView({ behavior: 'smooth', block: 'center' });

    } catch (error) {
        console.error("Erro detalhado em addDevelopmentChapter:", error);
        window.showToast(`Falha ao adicionar capítulo: ${error.message}`);
    } finally {
        hideButtonLoading(button);
    }
};
// =========================================================================
// >>>>> FIM DA VERSÃO BLINDADA DE 'addDevelopmentChapter' <<<<<
// =========================================================================



        /**
         * Escapa uma string de texto plano para ser usada em um documento RTF,
         * lidando corretamente com caracteres non-ASCII e especiais.
         * @param {string} text - O texto a ser escapado.
         * @returns {string} O texto formatado para RTF.
         */
        const escapeRtf = (text) => {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                // Escapa caracteres especiais do RTF
                if (charCode === 92 || charCode === 123 || charCode === 125) { // Backslash, {, }
                    result += '\\' + text.charAt(i);
                }
                // Converte caracteres non-ASCII para o formato hexadecimal do RTF
                else if (charCode > 127) {
                    let hex = charCode.toString(16);
                    if (hex.length < 2) {
                        hex = '0' + hex;
                    }
                    result += "\\'" + hex;
                }
                // Mantém caracteres ASCII padrão
                else {
                    result += text.charAt(i);
                }
            }
            return result;
        };

        // ==========================================================
        // ================== FUNÇÕES PRINCIPAIS ====================
        // ==========================================================
        
            const handleSuggestionMouseOver = (event) => {
            const targetParagraph = event.currentTarget;
            const suggestionGroupText = targetParagraph.dataset.suggestionGroup;
            if (!suggestionGroupText) return;

            const contentWrapper = targetParagraph.closest('.generated-content-wrapper');
            if (!contentWrapper) return;
            
            // >>>>> AQUI ESTÁ A CORREÇÃO CRÍTICA <<<<<
            // Escapa as aspas duplas no texto da sugestão antes de usá-lo no seletor
            const safeSuggestionSelector = suggestionGroupText.replace(/"/g, '\\"');

            // Encontra todos os parágrafos com a mesma sugestão (usando o seletor seguro) e os destaca
            contentWrapper.querySelectorAll(`[data-suggestion-group="${safeSuggestionSelector}"]`).forEach(p => {
                p.classList.add('highlight-group');
            });
        };

        const handleSuggestionMouseOut = (event) => {
            const targetParagraph = event.currentTarget;
            const contentWrapper = targetParagraph.closest('.generated-content-wrapper');
            if (!contentWrapper) return;
            
            // Remove o destaque de todos os parágrafos
            contentWrapper.querySelectorAll('.highlight-group').forEach(p => {
                p.classList.remove('highlight-group');
            });
        };

window.analyzeSectionRetention = async (button, sectionId) => {
    const sectionElement = document.getElementById(sectionId);
    const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');

    if (!contentWrapper || !contentWrapper.textContent.trim()) {
        window.showToast("Gere o roteiro desta seção antes de analisar a retenção.");
        return;
    }

    const paragraphs = Array.from(contentWrapper.querySelectorAll('div[id]'));
    if (paragraphs.length === 0) {
        window.showToast("Não há parágrafos para analisar.");
        return;
    }

    showButtonLoading(button);

    try {
        const paragraphsWithIndexes = paragraphs.map((p, index) => ({ index: index, text: p.textContent.trim() }));
        
        // >>> PROMPT BLINDADO COM A NOVA REGRA DE ASPAS INTERNAS <<<
        const prompt = `Você é uma API de análise de retenção que retorna um array JSON.

**REGRAS CRÍTICAS DE SINTAXE (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON.
2.  **ESTRUTURA COMPLETA:** Sua resposta DEVE começar com um colchete de abertura \`[\` e, OBRIGATORIAMENTE, terminar com um colchete de fechamento \`]\`.
3.  **ASPAS DUPLAS EXTERNAS:** TODAS as chaves (ex: "suggestion") E todos os valores de texto (strings) DEVEM usar aspas duplas (\`"\`).
4.  **ASPAS SIMPLES INTERNAS (A REGRA MAIS IMPORTANTE):** Se você precisar usar aspas DENTRO de uma string de "suggestion", você DEVE, OBRIGATORIAMENTE, usar aspas simples (\`'\`). É estritamente proibido usar aspas duplas dentro de outra string.
5.  **VÍRGULA FINAL:** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último objeto.
6.  **OBJETO COMPLETO:** Cada objeto no array deve conter EXATAMENTE as três chaves: "paragraphIndex", "retentionScore" ("green", "yellow", ou "red"), e "suggestion" (em Português-Brasil).

**DADOS PARA ANÁLISE:**
${JSON.stringify(paragraphsWithIndexes, null, 2)}

Analise os dados e retorne o array JSON completo e sintaticamente perfeito.`;

        const rawResult = await callGroqAPI(prompt, 4000);
        let analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis)) throw new Error("Análise da IA em formato inválido.");

        // LÓGICA DE UNIFICAÇÃO (permanece a mesma)
        if (analysis.length > 0) {
            let currentGroup = [];
            for (let i = 0; i < analysis.length; i++) {
                const currentItem = analysis[i];
                const previousItem = i > 0 ? analysis[i - 1] : null;

                if (previousItem && currentItem.retentionScore === previousItem.retentionScore && currentItem.retentionScore !== 'green') {
                    currentGroup.push(currentItem);
                } else {
                    if (currentGroup.length > 1) {
                        const unifiedSuggestion = currentGroup[0].suggestion;
                        currentGroup.forEach(groupItem => groupItem.suggestion = unifiedSuggestion);
                    }
                    currentGroup = [currentItem];
                }
            }
            if (currentGroup.length > 1) {
                const unifiedSuggestion = currentGroup[0].suggestion;
                currentGroup.forEach(groupItem => groupItem.suggestion = unifiedSuggestion);
            }
        }

        const newParagraphs = paragraphs.map(p => {
            const newP = p.cloneNode(true);
            newP.className = '';
            newP.innerHTML = DOMPurify.sanitize(p.innerHTML.replace(/<div class="retention-tooltip">.*?<\/div>|<button class="retention-action-btn optimize-btn">.*?<\/button>/g, ''));
            p.parentNode.replaceChild(newP, p);
            return newP;
        });

        analysis.forEach((item, index) => {
            const p = newParagraphs[item.paragraphIndex];
            if (p) {
                p.classList.add('retention-paragraph-live', `retention-${item.retentionScore}`);
                p.dataset.suggestionGroup = item.suggestion;

                if (item.retentionScore === 'yellow' || item.retentionScore === 'red') {
                    const previousItem = index > 0 ? analysis[index - 1] : null;
                    if (!previousItem || item.suggestion !== previousItem.suggestion) {
                        const scoreLabels = { yellow: "PONTO DE ATENÇÃO", red: "PONTO DE RISCO" };
                        const tooltipTitle = scoreLabels[item.retentionScore] || 'ANÁLISE';

                        const suggestionTextEscaped = item.suggestion
                            .replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/`/g, '\\`');

                 const buttonsHtml = `
    <div class="flex gap-2 mt-3">
        <button class="flex-1 btn btn-primary btn-small py-1" 
                data-action="optimizeGroup" 
                data-suggestion-text="${suggestionTextEscaped}">
            <i class="fas fa-magic mr-2"></i> Otimizar
        </button>
        <button class="flex-1 btn btn-danger bg-red-600 hover:bg-red-700 btn-small py-1" 
                data-action="deleteParagraphGroup" 
                data-suggestion-text="${suggestionTextEscaped}">
            <i class="fas fa-trash-alt mr-2"></i> Deletar
        </button>
    </div>
`;
                        const tooltipHtml = `<div class="retention-tooltip"><strong>${tooltipTitle}:</strong> ${item.suggestion}${buttonsHtml}</div>`;
                        p.innerHTML += DOMPurify.sanitize(tooltipHtml);
                    }
                }
            }
        });

        newParagraphs.forEach(p => {
            if (p.dataset.suggestionGroup) {
                p.addEventListener('mouseover', handleSuggestionMouseOver);
                p.addEventListener('mouseout', handleSuggestionMouseOut);
            }
        });

        window.showToast("Análise de retenção concluída!");
    } catch (error) {
        console.error("Erro detalhado em analyzeSectionRetention:", error);
        window.showToast(`Falha na análise: ${error.message}`);
    } finally {
        hideButtonLoading(button);
    }
};

/**
         * Pega um parágrafo, otimiza com IA e substitui seu conteúdo.
         * (VERSÃO CORRIGIDA E ANEXADA AO 'WINDOW')
         */
        window.optimizeParagraph = async (paragraphId, suggestion) => {
            const paragraphElement = document.getElementById(paragraphId);
            if (!paragraphElement) return;

            const button = paragraphElement.querySelector('.retention-action-btn');
            if (button) {
                button.disabled = true;
                button.innerHTML = `<div class="loading-spinner" style="width:16px; height:16px; border-width: 2px;"></div>`;
            }

            const originalText = paragraphElement.firstChild.textContent.trim();
            const languageName = document.getElementById('languageSelect').options[document.getElementById('languageSelect').selectedIndex].text;
            const prompt = `You are an expert copywriter. Rewrite the "Original Paragraph" below based on the "Improvement Suggestion".
        
            **CRITICAL RULE: You MUST respond in ${languageName}.** Do not change the language.

             **Original Paragraph:**
             "${originalText}"

              **Improvement Suggestion:**
               "${suggestion}"

           Respond ONLY with the rewritten paragraph, in ${languageName}.`;

            try {
                const rewrittenText = await callGroqAPI(prompt, 1000);
                paragraphElement.firstChild.textContent = removeMetaComments(rewrittenText);
                
                // Feedback visual
                paragraphElement.classList.remove('retention-yellow', 'retention-red');
                paragraphElement.classList.add('retention-green');
                paragraphElement.querySelector('.retention-tooltip')?.remove();
                button?.remove();
                
                invalidateAndClearPrompts(paragraphElement.closest('.script-section'));
                invalidateAndClearPerformance(paragraphElement.closest('.script-section'));

                window.showToast("Parágrafo otimizado!");
            } catch (error) {
                window.showToast(`Falha ao otimizar: ${error.message}`);
                console.error("Erro detalhado em optimizeParagraph:", error);
                if (button) button.innerHTML = '⚠️'; // Ícone de erro
            }
        };
    
         // ==========================================================
        // >>>>> SUBSTITUA SUA FUNÇÃO suggestPerformance INTEIRA POR ESTA VERSÃO <<<<<
        // ==========================================================
        window.suggestPerformance = async (button, sectionId) => {
    const sectionElement = document.getElementById(sectionId);
    const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');
    const outputContainer = sectionElement?.querySelector('.section-performance-output');

    if (!contentWrapper || !contentWrapper.textContent.trim() || !outputContainer) {
        window.showToast("Gere o roteiro desta seção primeiro.");
        return;
    }

    showButtonLoading(button);
    outputContainer.innerHTML = `<div class="loading-spinner-small mx-auto my-4"></div>`;
    
    try {
        const paragraphElements = Array.from(contentWrapper.querySelectorAll('div[id]'));
        const originalParagraphs = paragraphElements.map(p => p.textContent.trim().replace(/\[.*?\]/g, '').trim());

        if (originalParagraphs.length === 0) { throw new Error("Não foram encontrados parágrafos estruturados para análise."); }

        const batchSize = 15;
        const apiPromises = [];

        for (let i = 0; i < originalParagraphs.length; i += batchSize) {
            const paragraphBatch = originalParagraphs.slice(i, i + batchSize);
            let promptContext = '';
            paragraphBatch.forEach((p, indexInBatch) => {
                const globalIndex = i + indexInBatch;
                promptContext += `Parágrafo ${globalIndex}: "${p}"\n\n`;
            });

            // ==========================================================
            // >>>>> INÍCIO DA MUDANÇA NO PROMPT <<<<<
            // ==========================================================
            const prompt = `Você é uma API de análise de roteiro. Sua resposta DEVE ser um array JSON.

**REGRAS DE FORMATAÇÃO (INEGOCIÁVEIS E CRÍTICAS):**
1.  Sua resposta final DEVE ser um array JSON válido, começando com \`[\` e terminando com \`]\`.
2.  Sua resposta NÃO PODE conter nenhum texto, comentário ou explicação antes ou depois do JSON.
3.  O array deve conter EXATAMENTE ${paragraphBatch.length} objetos.
4.  Cada objeto DEVE ter duas chaves: "general_annotation" (uma string) e "emphasis_words" (um array com no máximo 1 string).
5.  **REGRA DA VÍRGULA (A MAIS IMPORTANTE):** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último. Exemplo: \`[ { ... }, { ... } ]\`
6.  **VERIFICAÇÃO FINAL:** Antes de responder, verifique se cada objeto JSON \`{...}\` está completamente fechado com sua chave \`}\` antes da próxima vírgula ou do colchete final \`]\`.

**EXEMPLO DE RESPOSTA PERFEITA:**
[
  {
    "general_annotation": "[Tom de surpresa]",
    "emphasis_words": ["inacreditável"]
  },
  {
    "general_annotation": "[Tom de suspense]",
    "emphasis_words": ["segredo"]
  }
]

Analise os ${paragraphBatch.length} parágrafos a seguir e retorne o array JSON, seguindo TODAS as regras.

**ROTEIRO (LOTE ATUAL):**
${promptContext}`;
            // ==========================================================
            // >>>>> FIM DA MUDANÇA NO PROMPT <<<<<
            // ==========================================================

            apiPromises.push(callGroqAPI(prompt, 3000).then(res => cleanGeneratedText(res, true)));
        }

        const allBatchResults = await Promise.all(apiPromises);
        const annotations = allBatchResults.flat();

        if (!Array.isArray(annotations) || annotations.length !== originalParagraphs.length) { 
            console.error(`Falha na contagem: JS esperava ${originalParagraphs.length} anotações, mas a IA retornou ${annotations ? annotations.length : 0}.`);
            throw new Error("A IA não retornou o número correto de anotações após juntar os lotes."); 
        }
        
        let annotatedParagraphs = [];
        originalParagraphs.forEach((p, index) => {
            const annotationData = annotations[index];
            let annotatedParagraph = p;

            if (annotationData && annotationData.emphasis_words && Array.isArray(annotationData.emphasis_words) && annotationData.emphasis_words.length > 0) {
                annotationData.emphasis_words.forEach(word => {
                    const escapedWord = word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    const wordRegex = new RegExp(`\\b(${escapedWord})\\b`, 'gi');
                    annotatedParagraph = annotatedParagraph.replace(wordRegex, `[ênfase em '${word}']$1`);
                });
            }
            const finalParagraph = `${annotationData.general_annotation || ''}\n${annotatedParagraph}`;
            annotatedParagraphs.push(finalParagraph.trim());
        });

        const finalAnnotatedText = annotatedParagraphs.join('\n');
        
        const originalTextForAudit = originalParagraphs.join('\n');
        const { isValid } = auditGeneratedText(originalTextForAudit.replace(/\n/g, ' '), finalAnnotatedText.replace(/\n/g, ' '));

        if (!isValid) { throw new Error("Falha crítica na auditoria interna. O texto foi corrompido durante a montagem."); }
        
        const highlightedText = finalAnnotatedText.replace(/(\[.*?\])/g, '<span class="text-indigo-500 dark:text-indigo-400 font-semibold italic">$1</span>');

        outputContainer.innerHTML = `
            <div class="card-background p-4 mt-2 rounded-lg border-l-4 border-indigo-500">
                <h5 class="font-bold text-sm mb-2 text-gray-700 dark:text-gray-200">Sugestão de Performance:</h5>
                <div class="performance-output-scrollable">
                    <p class="text-gray-800 dark:text-gray-200 leading-relaxed whitespace-pre-wrap">${highlightedText}</p>
                </div>
            </div>`;

        if (sectionElement) { invalidateAndClearPrompts(sectionElement); }

    } catch (error) {
        outputContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao sugerir performance: ${error.message}</p>`;
        console.error("Erro detalhado em auditGeneratedText:", error);
    } finally {
        hideButtonLoading(button);
    }
};


// =========================================================================
// >>>>> SUBSTITUA A FUNÇÃO 'window.refineSectionStyle' INTEIRA POR ESTA VERSÃO SEGURA <<<<<
// =========================================================================

/**
 * Pega o texto de uma seção, pede para a IA refinar o estilo (remover repetições, melhorar fluidez)
 * e substitui o conteúdo original pelo texto refinado.
 * @param {HTMLElement} buttonElement - O botão "Refinar Estilo" que foi clicado.
 */
window.refineSectionStyle = async (buttonElement) => {
    showButtonLoading(buttonElement);

    const sectionElement = buttonElement.closest('.script-section');
    if (!sectionElement) {
        window.showToast("Erro: Seção do roteiro não encontrada.");
        hideButtonLoading(buttonElement);
        return;
    }

    const contentWrapper = sectionElement.querySelector('.generated-content-wrapper');
    const originalText = contentWrapper?.textContent.trim();

    if (!originalText) {
        window.showToast("Não há texto para refinar nesta seção.");
        hideButtonLoading(buttonElement);
        return;
    }

// =========================================================================
// >>>>> PROMPT FINAL E BLINDADO PARA 'refineSectionStyle' <<<<<
// =========================================================================
const prompt = `Você é um EDITOR DE ESTILO (Copy Editor) DE ALTO DESEMPENHO e um ESPECIALISTA EM FLUÍDEZ NARRATIVA. Sua tarefa é REESCREVER o texto fornecido para elevar drasticamente sua QUALIDADE, FLUÍDEZ, IMPACTO e ORIGINALIDADE, sem alterar o significado, o tom ou a mensagem central.

**TEXTO ORIGINAL (PARA REFINAMENTO):**
---
${originalText}
---

**REGRAS DE REFINAMENTO ESTRATÉGICAS E CRÍTICAS (SIGA EXATAMENTE):**
1.  **ELIMINAÇÃO RIGOROSA DE REPETIÇÕES E REDUNDÂNCIAS:**
    - **Identificação Profunda:** Analise cuidadosamente o texto para identificar NÃO APENAS palavras repetidas, mas também IDEIAS, CONCEITOS e ESTRUTURAS DE FRASE repetitivas ou muito semelhantes.
    - **Remoção/Apresentação Variada:** Elimine completamente as repetições ou, quando a ideia for essencial, reexpresse-a de forma TOTALMENTE DIFERENTE usando sinônimos, metáforas, mudanças de perspectiva ou reestruturação completa da frase.
    - **Variação Sintática:** Diversifique drasticamente o tamanho e a construção das frases. Alterne entre frases curtas e longas, simples e complexas, para criar ritmo.
2.  **OTIMIZAÇÃO MÁXIMA DA FLUÍDEZ E COESÃO:**
    - **Conectivos Inteligentes:** Use conectivos lógicos e transições sutis para ligar as ideias de forma IMPECAVEL, garantindo um fluxo narrativo suave e natural.
    - **Leitura Aloud:** Certifique-se de que o texto, quando lido em voz alta, soe NATURAL, RÍTMICO e CATIVANTE. Evite travas linguísticas ou estruturas desconfortáveis.
3.  **PRESERVAÇÃO ESTRITAMENTE FIEL DO CONTEÚDO ORIGINAL:**
    - **Intocável:** NÃO adicione novas informações, opiniões, interpretações ou altere o significado central do texto original.
    - **Foco em Polir:** Sua única função é POLIR, APRIMORAR e REESCREVER para maior clareza e impacto, NÃO recriar o conteúdo.
4.  **RESPOSTA PURA E LIMPA (SEM EXTRAS):**
    - **Apenas o Texto Refinado:** Sua resposta deve ser APENAS o texto refinado, completo. NENHUM preâmbulo, comentário, metatexto, explicação ou nota adicional deve ser incluída.
    - **Formato Puro:** Retorne APENAS o conteúdo textual final, pronto para substituir o texto original.

**AÇÃO FINAL:** Reescreva AGORA o texto fornecido, aplicando EXATAMENTE todas as regras acima para entregar uma versão significativamente mais refinada, fluida, impactante e livre de repetições. Responda APENAS com o texto final refinado.
`;
// =========================================================================
// >>>>> FIM DO PROMPT PARA 'refineSectionStyle' <<<<<
// =========================================================================

    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const refinedText = removeMetaComments(rawResult);

        const newParagraphs = refinedText.split('\n').filter(p => p.trim() !== '');
        const sectionId = sectionElement.id.replace('Section', '');
        
        // Constrói o novo HTML
        const newHtml = newParagraphs.map((p, index) => 
            `<div id="${sectionId}-p-${index}">${p}</div>`
        ).join('');

        // <<< AQUI ESTÁ A IMPLEMENTAÇÃO DE SEGURANÇA >>>
        // Sanitiza o HTML antes de inseri-lo no DOM
        contentWrapper.innerHTML = DOMPurify.sanitize(newHtml);

        // Invalida análises anteriores, pois o texto mudou
        invalidateAndClearPerformance(sectionElement);
        invalidateAndClearPrompts(sectionElement);
        const analysisOutput = sectionElement.querySelector('.section-analysis-output');
        if (analysisOutput) {
            analysisOutput.innerHTML = ''; // Limpa a análise de retenção
        }

        // Atualiza o tempo de leitura
        updateAllReadingTimes();

        window.showToast("Estilo do roteiro refinado com sucesso!");

    } catch (error) {
        console.error("Erro detalhado em refineSectionStyle:", error); // Adicionado log de erro
        window.showToast(`Falha ao refinar o estilo: ${error.message}`);
    } finally {
        hideButtonLoading(buttonElement);
    }
};



window.criterionMap = {
    'Introdução (Hook)': 'introSection',
    'Desenvolvimento (Ritmo e Retenção)': 'developmentSection',
    'Clímax': 'climaxSection',
    'Conclusão': 'conclusionSection',
    'CTA (Call to Action)': 'ctaSection'
};




// =========================================================================
// >>>>> SUBSTITUA A FUNÇÃO 'applySuggestion' INTEIRA POR ESTA VERSÃO <<<<<
// =========================================================================
window.applySuggestion = (button) => {
    const { criterionName, problematicQuote, rewrittenQuote } = button.dataset;

    // Limpamos o nome do critério para remover quaisquer caracteres invisíveis.
    const cleanCriterionName = criterionName.trim();

    const sectionId = (window.criterionMap || {})[cleanCriterionName];
    
    if (!sectionId) {
        window.showToast(`Erro fatal: Seção alvo para o critério '${cleanCriterionName}' não foi encontrada no mapa.`);
        return;
    }

    const sectionElement = document.getElementById(sectionId);
    const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');

    if (!contentWrapper) {
        window.showToast("Erro: Container de conteúdo do roteiro não encontrado.");
        return;
    }

    let replaced = false;
    const paragraphs = contentWrapper.querySelectorAll('div[id^="' + sectionId.replace('Section','') + '-p-"]');

    paragraphs.forEach(p => {
        if (replaced) return;
        const childNodes = Array.from(p.childNodes);

        for (const node of childNodes) {
            if (node.nodeType === Node.TEXT_NODE && node.textContent.includes(problematicQuote)) {
                
                if (node.parentElement.classList.contains('highlight-change')) {
                    replaced = true;
                    break;
                }
                
                const originalTextNode = node;
                const text = originalTextNode.textContent;
                const startIndex = text.indexOf(problematicQuote);

                const textBefore = text.substring(0, startIndex);
                const textAfter = text.substring(startIndex + problematicQuote.length);

                const highlightSpan = document.createElement('span');
                highlightSpan.textContent = rewrittenQuote;
                highlightSpan.className = 'highlight-change'; 

                const nodeBefore = document.createTextNode(textBefore);
                const nodeAfter = document.createTextNode(textAfter);

                const parent = originalTextNode.parentNode;
                
                parent.replaceChild(nodeAfter, originalTextNode);
                parent.insertBefore(highlightSpan, nodeAfter);
                parent.insertBefore(nodeBefore, highlightSpan);

                replaced = true;
                break;
            }
        }
    });

    if (!replaced) {
        window.showToast("Não foi possível aplicar a sugestão. O texto pode ter sido muito alterado.");
        return;
    }
    
    window.showToast("Sugestão aplicada com sucesso!");
    
    invalidateAndClearPerformance(sectionElement);
    invalidateAndClearPrompts(sectionElement);
    updateAllReadingTimes();

    button.disabled = true;
    button.innerHTML = '<i class="fas fa-check mr-2"></i>Aplicada!';
    button.classList.remove('btn-primary');
    button.classList.add('btn-success');

    setTimeout(() => {
        button.disabled = false;
        button.innerHTML = 'Aplicar';
        button.classList.remove('btn-success');
        button.classList.add('btn-primary');
    }, 20000);
};



// =========================================================================
// >>>>> PASSO 2: ADICIONE ESTA NOVA FUNÇÃO AO SEU SCRIPT <<<<<
// =========================================================================
const applyAllSuggestions = async (button) => {
    // Encontra todos os botões "Aplicar" que ainda não foram clicados (não estão desabilitados)
    const allApplyButtons = document.querySelectorAll('#analysisReportContainer button[data-action="applySuggestion"]:not(:disabled)');

    if (allApplyButtons.length === 0) {
        window.showToast("Nenhuma sugestão nova para aplicar.");
        return;
    }
    
    showButtonLoading(button);
    
    let appliedCount = 0;
    
    // Usamos um loop 'for...of' para poder usar 'await' e garantir que as aplicações não se sobreponham
    for (const applyBtn of allApplyButtons) {
        try {
            // Chama a nossa função já existente e robusta
            window.applySuggestion(applyBtn);
            appliedCount++;
            
            // Uma pequena pausa para o navegador respirar entre as aplicações
            await new Promise(resolve => setTimeout(resolve, 100)); 
        } catch (error) {
            console.error("Erro ao aplicar uma sugestão no modo 'Aplicar Todas':", error);
        }
    }
    
    hideButtonLoading(button);
    window.showToast(`${appliedCount} sugest${appliedCount > 1 ? 'ões' : 'ão'} aplicad${appliedCount > 1 ? 'as' : 'a'} com sucesso!`);
    
    // Desabilita o botão "Aplicar Todas" após o uso
    button.disabled = true;
    button.innerHTML = '<i class="fas fa-check mr-2"></i>Tudo Aplicado!';
};



// =========================================================================
// >>>>> PASSO 2: SUBSTITUA A FUNÇÃO 'window.enrichWithData' INTEIRA POR ESTA <<<<<
// =========================================================================

window.enrichWithData = async (buttonElement) => {
    const selection = window.getSelection();
    if (selection.rangeCount === 0 || selection.toString().trim() === '') {
        window.showToast("Por favor, selecione primeiro o trecho de texto que deseja enriquecer.");
        return;
    }
    
    userSelectionRange = selection.getRangeAt(0).cloneRange();
    const selectedText = selection.toString().trim();

    const newData = await showInputDialog(
        'Enriquecer com Dados',
        'Cole abaixo o dado, fonte ou exemplo que você quer adicionar ao trecho selecionado.',
        'Nova Informação:',
        'Ex: Fonte: Forbes 2023; Segundo o Dr. especialista...'
    );

    if (!newData) {
        window.showToast("Operação cancelada.");
        userSelectionRange = null;
        return;
    }

    showButtonLoading(buttonElement);
    const sectionElement = buttonElement.closest('.script-section');

    try {
   
  // =========================================================================
// >>>>> PROMPT FINAL E BLINDADO PARA INTEGRAR DADOS EXTERNOS <<<<<
// =========================================================================
const prompt = `Você é um EDITOR DE ROTEIRO DE ALTO DESEMPENHO e um ESPECIALISTA EM INTEGRAÇÃO DE INFORMAÇÕES. Sua tarefa ÚNICA, CRÍTICA e INEGOCIÁVEL é REESCREVER um trecho de texto para integrar uma NOVA INFORMAÇÃO de forma TOTALMENTE NATURAL, FLUÍDA e PROFISSIONAL, sem comprometer a integridade do texto original.

**TRECHO ORIGINAL DO ROTEIRO (PARA SER REESCRITO):**
---
${selectedText}
---

**NOVA INFORMAÇÃO A SER INTEGRADA (DADO EXTERNO):**
---
${newData}
---

**SUA TAREFA ESTRATÉGICA E CRÍTICA (A ÚNICA E MAIS IMPORTANTE):**
- REESCREVA o "Trecho Original do Roteiro" com o OBJETIVO PRIMÁRIO de TECER a "Nova Informação a ser Integrada" de forma PERFEITAMENTE NATURAL e FLUÍDA.
- O resultado final DEVE ser um ou mais parágrafos COESOS, BEM ESCRITOS e LOGICAMENTE INTEGRADOS.
- O texto reescrito DEVE manter o TOM, o RITMO e a MENSAGEM CENTRAL do texto original, agora ENRIQUECIDO e ATUALIZADO com o novo dado fornecido.
- A integração deve ser TÃO SUTIL que o leitor não perceba uma costura; deve soar como se a informação sempre tivesse estado lá.

**REGRAS ABSOLUTAMENTE INEGOCIÁVEIS (VIOLAÇÕES RESULTARÃO EM FALHA):**
1.  **RESPOSTA PURA E LIMPA:** Sua resposta deve ser APENAS o texto final reescrito. NENHUM outro conteúdo (preâmbulos, comentários, títulos, explicações, metadados) é permitido.
2.  **SEM AUTO-REFERÊNCIA:** É TERMINANTEMENTE PROIBIDO apresentar-se, falar sobre suas habilidades ou qualquer forma de metatexto.
3.  **SEM DESVIO DE TAREFA:** É ESTRITAMENTE PROIBIDO desviar-se da tarefa precisa de reescrever e integrar. Foque exclusivamente na fusão perfeita dos dois textos.
4.  **PRESERVAÇÃO DO CONTEXTO:** NÃO altere o significado central ou o tom do "Trecho Original". A nova informação deve se encaixar como uma peça complementar, não como uma substituição.

**AÇÃO FINAL:** Reescreva AGORA o trecho, integrando a nova informação com MÁXIMA habilidade e conformidade. Responda APENAS com o texto final reescrito e integrado.
`;
// =========================================================================
// >>>>> FIM DO PROMPT BLINDADO <<<<<
// =========================================================================

        const rawResult = await callGroqAPI(prompt, 1000);
        const enrichedText = removeMetaComments(rawResult);

        if (userSelectionRange) {
            selection.removeAllRanges();
            selection.addRange(userSelectionRange);
            document.execCommand('insertHTML', false, DOMPurify.sanitize(`<span class="highlight-change">${enrichedText}</span>`));
        }
        
        if (sectionElement) {
            invalidateAndClearPerformance(sectionElement);
            invalidateAndClearPrompts(sectionElement);
        }

        window.showToast("Texto enriquecido com sucesso!");

    } catch (error) {
        console.error("Erro detalhado em enrichWithData:", error);
        window.showToast(`Falha ao enriquecer o texto: ${error.message}`);
    } finally {
        hideButtonLoading(buttonElement);
        userSelectionRange = null;
    }
};

     
// =========================================================================
// >>>>> PASSO 1: SUBSTITUA A FUNÇÃO 'generateVideoIdeas' INTEIRA POR ESTA <<<<<
// =========================================================================
const generateVideoIdeas = async (button) => {
    const nicheDescription = document.getElementById('nicheDescription').value.trim();
    if (!nicheDescription) {
        window.showToast("Por favor, descreva o nicho do seu canal.");
        return;
    }

    const selectedLangCode = document.getElementById('languageSelect').value;
    const languageName = selectedLangCode === 'pt-br' ? 'Português do Brasil' : 'English';

    const outputContainer = document.getElementById('ideasOutput');
    outputContainer.innerHTML = DOMPurify.sanitize(`<div class="md:col-span-2 loading-spinner-small mx-auto my-4"></div>`);

    showButtonLoading(button);

// =========================================================================
// >>>>> PROMPT FINAL E BLINDADO PARA GERAÇÃO DE IDEIAS DE CONTEÚDO GERAL <<<<<
// =========================================================================
const prompt = `Você é uma API de Estratégia de Conteúdo Viral altamente especializada. Sua única função é gerar ideias de vídeo de EXCEPCIONAL qualidade e engajamento para canais do YouTube, baseando-se em um tema genérico fornecido.

**TAREFA PRINCIPAL:** Gerar 6 ideias de vídeo com POTENCIAL MÁXIMO de viralidade e relevância para o tema fornecido.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (ABSOLUTAMENTE INEGOCIÁVEIS):**
1.  **JSON PURO E PERFEITO:** Sua resposta inteira deve ser APENAS um array JSON válido, começando com \`[\` e terminando com \`]\`. NENHUM outro texto, comentário ou explicação é permitido. Pense nisso como uma resposta de API pura e impecável.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar obrigatoriamente aspas duplas (\`"\`).
3.  **VÍRGULA FINAL OBRIGATÓRIA:** CADA objeto JSON dentro do array DEVE ser seguido por uma vírgula (\`,\`), EXCETO o último objeto.
4.  **ESTRUTURA DO OBJETO EXATA:** Cada objeto no array DEVE conter EXATAMENTE estas cinco chaves: "title", "angle", "targetAudience", "viralityScore", e "videoDescription".
5.  **TIPOS DE DADOS EXATOS:**
    - "title": string.
    - "angle": string.
    - "targetAudience": string.
    - "viralityScore": NÚMERO (inteiro ou decimal) entre 0 e 10.
    - "videoDescription": string.
6.  **IDIOMA:** Lembre-se, todos os valores de texto devem estar em **${languageName}**.

**MANUAL DE CRIAÇÃO DE IDEIAS (SIGA ESTAS INSTRUÇÕES PARA CADA IDEIA):**
- **"title" (Título Explosivo):**
    - Deve ser HIPNÓTICO e provocar CURIOSIDADE INTENSA.
    - Use técnicas de "clickbait" inteligentes: promessas, números, urgência, contraste, perguntas retóricas.
    - Máximo de 70 caracteres. Seja CONCISO e DIRETO.
    - Ex: "99% dos Médicos IGNORAM Este Sinal... (E Pode Salvar Sua Vida)"
- **"angle" (Ângulo Único):**
    - Esta é a ESSENCIAL da ideia. Deve ser uma frase impactante que resume a ABORDAGEM DISTINTA do vídeo.
    - Foque em uma revelação, um insight contrário ao senso comum, ou uma conexão inesperada.
    - Deve soar intrigante e prometer valor único. Use linguagem forte e específica.
    - Ex: "Este vídeo revela como a 'Lei da Atração' está fundamentada em princípios quânticos reais, não em misticismo."
- **"targetAudience" (Público-Alvo Específico):**
    - Identifique um segmento CLARAMENTE definido que se beneficiaria MÁXIMO dessa ideia.
    - Evite generalidades como "todos" ou "pessoas". Seja específico (ex: "Jovens Profissionais com Ansiedade", "Pais de Crianças com TDAH", "Aposentados Interessados em Tecnologia").
- **"viralityScore" (Nota de Viralidade):**
    - Avalie honestamente o potencial de COMPARTILHAMENTO MASSIVO da ideia.
    - 0-3: Baixo (nicho muito específico, pouca emoção).
    - 4-6: Médio (interessante, mas convencional).
    - 7-10: Alto (choque, utilidade extrema, emoção forte, altamente compartilhável).
- **"videoDescription" (Descrição Rica):**
    - Uma sinopse detalhada de **8 a 10 frases substanciais**.
    - Comece prometendo resolver um problema ou responder uma pergunta central.
    - Liste 2-3 pontos-chave que serão abordados.
    - Termine com o insight ou takeaway principal.
    - Escreva como se estivesse otimizando para SEO e curiosidade do espectador. Use palavras-chave naturalmente.

**TEMA GENÉRICO PARA TRANSFORMAR EM CONTEÚDO VIRAL:**
"${nicheDescription}"

**AÇÃO FINAL:** Gere AGORA as 6 ideias de vídeo mais fortes, criativas e potencialmente virais possíveis, seguindo EXATAMENTE todas as regras, formatos e instruções acima. Responda APENAS com o array JSON perfeito.
`;

    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const ideas = cleanGeneratedText(rawResult, true);

        if (!ideas || !Array.isArray(ideas) || ideas.length === 0) {
            throw new Error("A IA não retornou ideias no formato esperado.");
        }

        outputContainer.innerHTML = '';

        ideas.forEach((idea, index) => {
            const title = idea.title || "Ideia sem título";
            const displayDescription = idea.videoDescription || idea.angle || "Descrição não disponível.";
            const viralityScore = idea.viralityScore || "N/A";

            const card = document.createElement('div');
            card.className = 'card-background p-4 rounded-lg shadow-md border-l-4 border-indigo-500 animate-fade-in flex flex-col justify-between min-h-[140px]';
            
            const escapedIdea = escapeIdeaForOnclick(idea);
            const cardContent = `
                <div>
                    <div class="flex justify-between items-start gap-4">
                        <h4 class="font-bold text-base text-gray-800 dark:text-gray-200 flex-grow">${index + 1}. ${DOMPurify.sanitize(title)}</h4>
                        <button class="btn btn-primary btn-small flex-shrink-0 py-1 px-3"
                                data-action="select-idea"
                                data-idea='${escapedIdea}'>
                            Usar
                        </button>
                    </div>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">"${DOMPurify.sanitize(displayDescription)}"</p>
                </div>
                <span class="font-bold text-sm text-indigo-500 bg-indigo-100 dark:bg-indigo-900 dark:text-indigo-300 py-1 px-2 rounded self-start mt-3">
                    Potencial: ${DOMPurify.sanitize(String(viralityScore))} / 10
                </span>
            `;
            card.innerHTML = DOMPurify.sanitize(cardContent, { ADD_ATTR: ['data-action', 'data-idea'] });
            outputContainer.appendChild(card);
        });

    } catch (error) {
        console.error("Erro detalhado em generateVideoIdeas:", error);
        if (error.message.includes("A IA não retornou um formato")) {
            outputContainer.innerHTML = DOMPurify.sanitize(`<p class="md:col-span-2 text-yellow-500 text-sm p-4 bg-yellow-900/20 rounded-md border-l-4 border-yellow-400">
                <strong>A IA se recusou a gerar conteúdo para este tema.</strong><br><br>
                Isso geralmente acontece com tópicos considerados sensíveis ou controversos. Tente reformular sua descrição.
            </p>`);
        } else {
            outputContainer.innerHTML = DOMPurify.sanitize(`<p class="md:col-span-2 text-red-500 text-sm">Falha ao gerar ideias: ${error.message}</p>`);
        }
    } finally {
        hideButtonLoading(button);
    }
};



// =========================================================================
// >>>>> VERSÃO BLINDADA DA FUNÇÃO 'unravelEnigmas' <<<<<
// =========================================================================
const unravelEnigmas = async (button) => {
    const nicheDescription = document.getElementById('nicheDescription').value.trim();
    if (!nicheDescription) {
        window.showToast("Por favor, descreva o nicho ou um tema bíblico para desvendar.");
        return;
    }

    const selectedLangCode = document.getElementById('languageSelect').value;
    const languageName = selectedLangCode === 'pt-br' ? 'Português do Brasil' : 'English';
    const outputContainer = document.getElementById('ideasOutput');
    outputContainer.innerHTML = DOMPurify.sanitize(`<div class="md:col-span-2 loading-spinner-small mx-auto my-4"></div>`);
    showButtonLoading(button);

// <<< PROMPT EVOLUÍDO PARA REFERÊNCIAS BÍBLICAS MAIS FORTES >>>
const prompt = `Você é um Teólogo Investigativo e um Mestre em Hermenêutica Bíblica para o canal "The Biblical Unveiling". Sua especialidade é desvendar os tesouros escondidos nas Escrituras e fazer conexões impactantes com o mundo moderno, sempre fundamentado na Palavra.

**Sua missão é gerar 6 ideias de vídeos que conectem o TEMA FORNECIDO PELO USUÁRIO com enigmas, símbolos e histórias da Bíblia, usando REFERÊNCIAS BÍBLICAS EXPLÍCITAS E CENTRAIS.**

**DIRETIVA PRINCIPAL: ANCORE-SE NA BÍBLIA.**
- **Exigência de Citação Primária:** Toda ideia DEVE iniciar com uma ou mais citações bíblicas diretas (livro, capítulo, versículo) que sejam o FUNDAMENTO da conexão. Ex: "João 3:16 não é apenas sobre salvação, mas também revela um princípio de 'investimento celestial'..."
- **Conexão Baseada em Texto:** A conexão entre o tema moderno e o conceito bíblico NÃO deve ser superficial. A passagem bíblica citada deve ser o ponto de partida lógico e hermenêutico da investigação.
- **Evite Generalizações:** Não diga apenas "a fé". Diga "a fé de Abraão em Gênesis 15" ou "a fé testada de Jó". Seja específico com o texto.
- **Contexto é Chave:** Ao citar, forneça contexto suficiente da passagem bíblica para entender a conexão proposta.

Para fundamentar essas ideias, você DEVE usar uma das seguintes **Técnicas Investigativas**:
1.  **Fio Oculto (Cross-Referencing)**: Conecte passagens aparentemente desconexas para revelar um tema unificador. (Ex: "O número 777 aparece em Gênesis, Êxodo e Apocalipse. O que isso diz sobre a perfeição do juízo divino?")
2.  **Lupa Lexical (Análise de Palavras)**: Aprofunde-se no significado original de uma palavra-chave hebraica ou grega. (Ex: "O que o grego 'Logos' em João 1:1 revela sobre a natureza da informação divina?")
3.  **O Espelho Tipológico (Tipologia)**: Mostre como uma pessoa, evento ou instituição do Antigo Testamento prefigura o Novo. (Ex: "Jonas é um 'tipo' de Cristo? Compare Jonas 1:17 com Mateus 12:40.")
4.  **Contexto Histórico Profundo**: Conecte um evento bíblico a uma prática cultural ou política da época. (Ex: "Como o sistema de 'Tributos' romano ilumina a parábola do 'Denário' em Mateus 22:15-22?")

**FORMATO DA RESPOSTA:**
Sua resposta DEVE ser um array JSON válido. Cada ideia no array deve ser um objeto com as seguintes chaves:
- "title": (String) Um título curioso, específico e cativante que prometa uma revelação baseada na Escritura.
- "enigma": (String) O mistério central em uma única frase intrigante, fundamentado em uma passagem bíblica.
- "synopsis": (String) Uma sinopse detalhada de **8 a 10 frases substanciais**. Esta sinopse DEVE incluir pelo menos UMA citação bíblica direta (ex: "(veja Gênesis 15:1)") e explicar como a passagem será usada para explorar o tema moderno.
- "investigative_method": (String) O nome exato da técnica usada.
- "hook_question": (String) Uma pergunta provocativa e intrigante para capturar a atenção nos primeiros 15 segundos, idealmente relacionada à passagem bíblica.

**REGRA DE CITAÇÃO (A MAIS IMPORTANTE):** Se precisar citar algo dentro de uma string (como um versículo ou uma frase), você DEVE, OBRIGATORIAMENTE, usar **aspas simples (' ')**. É terminantemente PROIBIDO usar aspas duplas (" ") dentro de outra string.

**REGRA CRÍTICA DE IDIOMA:** Todos os valores de texto (title, enigma, synopsis, hook_question) DEVEM ser gerados em **${languageName}**.

**Tema fornecido pelo usuário (para conectar com a Bíblia):** "${nicheDescription}"

**AÇÃO:** Agora, desvende conexões teológicas ousadas, **ancoradas em passagens bíblicas explícitas**, e gere as 6 ideias.
`;
    
    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const ideas = cleanGeneratedText(rawResult, true);

        if (!ideas || !Array.isArray(ideas) || ideas.length === 0) {
            throw new Error("A IA não retornou ideias de enigmas no formato esperado.");
        }

        outputContainer.innerHTML = '';

        ideas.forEach((idea, index) => {
            const card = document.createElement('div');
            card.className = 'card-background p-4 rounded-lg shadow-md border-l-4 border-purple-500 animate-fade-in flex flex-col justify-between';
            
            const escapedIdea = escapeIdeaForOnclick(idea);
            const cardContent = `
                <div>
                    <div class="flex justify-between items-start gap-4">
                        <h4 class="font-bold text-base text-gray-800 dark:text-gray-200 flex-grow">${index + 1}. ${DOMPurify.sanitize(idea.title)}</h4>
                        <button class="btn btn-primary btn-small flex-shrink-0 py-1 px-3"
                                data-action="select-enigma-idea" 
                                data-idea='${escapedIdea}'>
                            Usar
                        </button>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">${DOMPurify.sanitize(idea.synopsis || idea.enigma)}</p>
                    <p class="text-xs text-purple-600 dark:text-purple-400 font-semibold mt-3">Método: ${DOMPurify.sanitize(idea.investigative_method)}</p>
                </div>
            `;
            card.innerHTML = DOMPurify.sanitize(cardContent, { ADD_ATTR: ['data-action', 'data-idea'] });
            outputContainer.appendChild(card);
        });

    } catch (error) {
        console.error("Erro detalhado em unravelEnigmas:", error);
        outputContainer.innerHTML = DOMPurify.sanitize(`<p class="md:col-span-2 text-red-500 text-sm">Falha ao desvendar enigmas: ${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};



// =========================================================================
// >>>>> AÇÃO 1: ADICIONE A FUNÇÃO `selectIdea` QUE ESTAVA FALTANDO <<<<<
// =========================================================================
/**
 * Preenche os campos do formulário principal com a ideia de vídeo selecionada.
 * @param {object} idea - O objeto da ideia contendo título, descrição, etc.
 */
const selectIdea = (idea) => {
    // Garante que os campos sejam preenchidos de forma segura, mesmo se a IA não retornar um valor
    document.getElementById('videoTheme').value = idea.title || '';
    document.getElementById('videoDescription').value = idea.videoDescription || '';
    document.getElementById('targetAudience').value = idea.targetAudience || '';

    // Rola a página para que o usuário veja os campos que foram preenchidos
    const targetElement = document.getElementById('inputTabsNav');
    if (targetElement) {
        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    // Notifica o usuário que a ação foi bem-sucedida
    window.showToast("Ideia selecionada! Agora defina a estratégia completa.");
};



// =========================================================================
// >>>>> CLIMAX <<<<<
// =========================================================================
const handleGenerateSection = async (button, sectionName, sectionTitle, elementId, finalDirective = null) => {
    if (!validateInputs()) return;
    if (!strategicOutline && sectionName !== 'intro') {
        window.showToast("Crie o Esboço Estratégico primeiro!");
        return;
    }
    
    showButtonLoading(button);
    
    const targetSectionElement = document.getElementById(`${elementId}Section`);
    if (targetSectionElement) {
        const analysisOutput = targetSectionElement.querySelector('.section-analysis-output');
        const performanceOutput = targetSectionElement.querySelector('.section-performance-output');
        if (analysisOutput) analysisOutput.innerHTML = '';
        if (performanceOutput) performanceOutput.innerHTML = '';
    }

    try {
        let contextText = null;
        const previousSectionsContent = [];
        const requiredSections = {
            'development': ['introSection'],
            'climax': ['introSection', 'developmentSection'],
            'conclusion': ['introSection', 'developmentSection', 'climaxSection']
        };

        if (requiredSections[sectionName]) {
            for (const reqId of requiredSections[sectionName]) {
                const requiredWrapper = document.querySelector(`#${reqId} .generated-content-wrapper`);
                if (!requiredWrapper || !requiredWrapper.textContent.trim()) {
                    const reqTitle = document.querySelector(`#${reqId} h3`)?.textContent || reqId.replace('Section', '');
                    window.showToast(`Por favor, gere a seção "${reqTitle}" primeiro.`);
                    hideButtonLoading(button);
                    return;
                }
                previousSectionsContent.push(requiredWrapper.textContent.trim());
            }
            contextText = previousSectionsContent.join('\n\n---\n\n');
        }

        const keyMap = { intro: 'introduction', development: 'development', climax: 'climax', conclusion: 'conclusion', cta: 'cta' };
        const outlineKey = keyMap[sectionName];
        const directive = strategicOutline ? strategicOutline[outlineKey] : null;
        
        const { prompt, maxTokens } = constructScriptPrompt(sectionName, sectionTitle, directive, contextText, finalDirective);
        
        let rawResult = await callGroqAPI(prompt, maxTokens);
        let cleanedResult = removeMetaComments(rawResult.trim());

        const paragraphs = cleanedResult.split('\n').filter(p => p.trim() !== '');
        const contentWithDivs = paragraphs.map((p, index) => 
            `<div id="${elementId}-p-${index}">${DOMPurify.sanitize(p)}</div>`
        ).join('');
        
        if (targetSectionElement) {
            const sectionElement = generateSectionHtmlContent(elementId, sectionTitle, contentWithDivs);
            targetSectionElement.innerHTML = ''; 
            targetSectionElement.appendChild(sectionElement);
            targetSectionElement.classList.remove('card', 'card-placeholder', 'flex', 'justify-between', 'items-center');
        } else {
            console.error(`Elemento alvo com ID '${elementId}Section' não encontrado.`);
            window.showToast("Erro interno: Seção do roteiro não encontrada.");
            return;
        }
        
        if (projectState.hasOwnProperty(sectionName)) {
            projectState[sectionName] = true;
        }

        markButtonAsCompleted(button.id);
        updateButtonStates();

    } catch (error) {
        window.showToast(`Falha ao gerar ${sectionTitle}: ${error.message}`);
        console.error(`Error generating ${sectionTitle}.`, error);
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};





        /**
         * Re-gera o conteúdo de uma secção específica do roteiro.
         * @param {string} sectionName - O nome da secção (ex: 'intro').
         * @param {string} sectionTitle - O título da secção.
         * @param {string} elementId - O ID do elemento HTML da secção.
         */
        // ==========================================================
// FUNÇÃO DE RE-GERAÇÃO CORRIGIDA
// ==========================================================
window.regenerateSection = (fullSectionId) => {
            const sectionName = fullSectionId.replace('Section', '');
            
            const sectionMap = {
    'intro': { title: 'Introdução', elementId: 'intro' },
    'development': { title: 'Desenvolvimento', elementId: 'development' },
    'climax': { title: 'Clímax', elementId: 'climax' },
    'conclusion': { title: 'Conclusão', elementId: 'conclusion' }, // Título corrigido
    'cta': { title: 'Call to Action (CTA)', elementId: 'cta' } // <<< ADICIONADO
};

            const sectionInfo = sectionMap[sectionName];
            
            if (sectionInfo) {
                // Encontra o botão de re-gerar que foi clicado, em vez de um botão antigo
                const button = document.querySelector(`[data-action='regenerate'][data-section-id='${fullSectionId}']`);
                if (button) {
                     handleGenerateSection(button, sectionName, sectionInfo.title, sectionInfo.elementId);
                } else {
                    console.error(`Botão de re-gerar não encontrado para a seção: ${fullSectionId}`);
                }
            } else {
                console.error(`Informações da seção não encontradas para: ${sectionName}`);
            }
        };



// =========================================================================
// >>>>> VERSÃO FINAL E BLINDADA DE 'generatePromptsForSection' <<<<<
// =========================================================================

window.generatePromptsForSection = async (button, sectionElementId) => {
    const sectionElement = document.getElementById(sectionElementId);
    const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');
    const promptContainer = sectionElement?.querySelector('.prompt-container');

    if (!contentWrapper || !contentWrapper.textContent.trim() || !promptContainer) {
        window.showToast("Gere o conteúdo do roteiro desta seção primeiro.");
        return;
    }
    if (!window.emotionalMap || window.emotionalMap.length === 0) {
        window.showToast("Gere o Mapa Emocional primeiro para criar prompts contextuais.");
        return;
    }

    showButtonLoading(button);
    promptContainer.innerHTML = `<div class="loading-spinner-small mx-auto my-4"></div>`;

    try {
        // >>>>> PROCESSAMENTO ESTRUTURADO DO CONTEÚDO <<<<<
        const allChildren = Array.from(contentWrapper.children);
        const paragraphsWithContext = [];
        let currentChapterTitle = "Contexto Geral";
        allChildren.forEach(child => {
            if (child.classList.contains('font-bold') && child.textContent.includes('Capítulo:')) {
                currentChapterTitle = child.textContent.replace('Capítulo:', '').trim();
            } else if (child.id && child.id.includes('-p-')) {
                paragraphsWithContext.push({
                    text: child.textContent.trim().replace(/\[.*?\]/g, '').trim(),
                    chapter: currentChapterTitle,
                    originalId: child.id
                });
            }
        });

        if (paragraphsWithContext.length === 0) { throw new Error("Não foram encontrados parágrafos estruturados para análise."); }

        const baseIndexMatch = paragraphsWithContext[0]?.originalId.match(/-p-(\d+)$/);
        const baseIndex = baseIndexMatch ? parseInt(baseIndexMatch[1], 10) : 0;
        const batchSize = 3; // Processa em lotes para não sobrecarregar a API
        const apiPromises = [];

        // >>>>> DEFINIÇÃO DE PARÂMETROS DE ESTILO VISUAL <<<<<
        const visualPacing = document.getElementById('visualPacing').value;
        const durationMap = {
            'dinamico': '3 e 8',
            'normal': '8 e 15',
            'contemplativo': '15 e 25'
        };
        const durationRange = durationMap[visualPacing] || '3 e 8';

        // >>>>> GERAÇÃO DOS PROMPTS PARA A IA (EM LOTES) <<<<<
        for (let i = 0; i < paragraphsWithContext.length; i += batchSize) {
            const batch = paragraphsWithContext.slice(i, i + batchSize);
            let promptContextForAI = '';
            batch.forEach((item, indexInBatch) => {
                const globalIndex = i + indexInBatch;
                const mapIndex = baseIndex + globalIndex;
                const emotionalContext = window.emotionalMap[mapIndex] || { emotion: 'Neutro', pace: 'Normal' };
                promptContextForAI += `\nParágrafo ${globalIndex}:\n- Título do Capítulo (Guia Temático): "${item.chapter}"\n- Texto do Parágrafo: "${item.text}"\n- Contexto Emocional: (Emoção: ${emotionalContext.emotion}, Ritmo: ${emotionalContext.pace})`;
            });
            
            // >>>>> PROMPT FINAL E BLINDADO PARA GERAÇÃO DE PROMPTS DE IMAGEM <<<<<
            const prompt = `Você é uma API ESPECIALISTA em Criação de Prompts Visuais Cinematográficos para IAs de Geração de Imagem. Sua tarefa é analisar os parágrafos fornecidos e gerar prompts de imagem DESCritivos, RICOS EM DETALHES e TOTALMENTE ALINHADOS com o contexto narrativo e emocional.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA JSON (ABSOLUTAMENTE INEGOCIÁVEIS):**
1.  **JSON PURO E PERFEITO:** Sua resposta inteira deve ser APENAS um array JSON válido, começando com \`[\` e terminando com \`]\`. NENHUM outro texto, comentário ou metadado deve ser incluído. Pense nisso como uma resposta de API pura e impecável.
2.  **ASPAS DUPLAS, SEMPRE E EXCLUSIVAMENTE:** TODAS as chaves (ex: "imageDescription") E todos os valores de texto (strings) DEVEM usar obrigatoriamente aspas duplas (\`"\`). É TERMINANTEMENTE PROIBIDO o uso de aspas simples (\`'\`) ou crases (\`\`) para delimitar QUALQUER string.
3.  **PROIBIÇÃO ABSOLUTA DE ASPAS INTERNAS DUPLAS:** Dentro dos valores de "imageDescription", É ESTRITAMENTE PROIBIDO o uso de aspas duplas internas. Se precisar dar ênfase ou citar algo visualmente, USE OBRIGATORIAMENTE aspas simples (\`'\`).
4.  **REVISÃO FINAL OBRIGATÓRIA:** Antes de responder, revise sua própria saída com EXTREMA ATENÇÃO para garantir que cada string está corretamente aberta e fechada com aspas duplas (\`"\`) e que a sintaxe JSON está PERFEITA.

**MANUAL DE CONTEÚDO E CRIAÇÃO DE PROMPTS VISUAIS CINEMATOGRÁFICOS (SIGA EXATAMENTE CADA ITEM):**
1.  **CORRESPONDÊNCIA EXATA E OBRIGATÓRIA (PRECISÃO PERFEITA):**
    - Crie um, e apenas um, objeto JSON para CADA parágrafo fornecido na seção "DADOS PARA ANÁLISE". O array final deve ter EXATAMENTE ${batch.length} objetos. Nenhum parágrafo deve ser ignorado, e nenhum objeto extra deve ser criado. Esta é uma regra de correspondência um-para-um absoluta.
2.  **DESCRIÇÃO VISUAL HIPERDETALHADA E CINEMATOGRÁFICA (O CORAÇÃO DA TAREFA - CONTEÚDO DA CHAVE "imageDescription"):**
    Sua principal função é criar uma descrição visual INCRIVELMENTE RICA, VÍVIDA e CINEMATOGRÁFICA para cada parágrafo. Esta descrição será usada por uma IA de geração de imagem, então cada detalhe importa. Foque em criar uma imagem que encapsule a essência emocional e narrativa do parágrafo. Cada "imageDescription" deve conter os seguintes elementos obrigatórios, integrados de forma fluida e natural:
    - **Cenário e Ambiente (Onde?):** Descreva o local físico e o ambiente com riqueza sensorial. Qual é o cenário? (ex: "Interior de uma cabana de madeira, à meia-luz, com chamas tremulantes de uma lareira"). Inclua detalhes atmosféricos (ex: "fumaça leve subindo do fogo", "sombras dançando nas paredes de toras").
    - **Composição Visual (O Que e Como?):** Defina os ELEMENTOS PRINCIPAIS da imagem e como eles são ORGANIZADOS dentro do quadro. Quem ou o que está na cena? Onde estão posicionados? (ex: "Um homem idoso senta-se sozinho em uma poltrona desgastada, inclinado para frente, olhando fixamente para as chamas."). Descreva a ação ou pose central.
    - **Iluminação (Como é a Luz?):** Especifique a QUALIDADE, DIREÇÃO e TIPO de luz de forma precisa. Isso é crucial para o clima. (ex: "Iluminação quente e suave da lareira, criando sombras profundas e contrastantes no rosto do homem, com um fundo envolto em escuridão"). Evite termos genéricos como "boa iluminação".
    - **Paleta de Cores (Quais Cores?):** Indique as CORES DOMINANTES e o TOM GERAL da cena. As cores devem refletir a emoção. (ex: "Tons quentes de âmbar, laranja e vermelho das chamas contrastando com tons frios de preto e cinza escuro do ambiente"). Use nomes de cores específicos quando possível.
    - **Ângulo da Câmera e Perspectiva (De Onde Olhamos?):** Defina claramente o ÂNGULO e a PERSPECTIVA da tomada. Isso muda completamente a percepção. (ex: "Plano americano, filmado levemente por baixo (low angle) para enfatizar a solidão e a introspecção do sujeito"). Use termos cinematográficos se souber (plano geral, médio, close, cenital, contrapicado, etc.).
    - **Estilo Visual (Qual é a Estética?):** Sugira um ESTILO ARTÍSTICO ou FOTOGRÁFICO específico. Isso guia a "textura" da imagem. (ex: "Estilo cinematográfico realista, com textura granulada de filme 35mm, profundidade de campo rasa"). Outros exemplos: "Estilo hiper-realista de fotografia editorial", "Estilo pintura a óleo impressionista", "Estilo de fotografia analógica vintage".
    - **Foco e Profundidade de Campo (O Que Está Nítido?):** Indique claramente o que está em FOCO NÍTIDO e o efeito do DESFOQUE no fundo ou primeiro plano. (ex: "Fundo desfocado (bokeh suave), mantendo o rosto e as mãos do homem em foco nítido"). Isso ajuda a direcionar a atenção.
    - **Elementos Emocionais Visuais (O Que Sente?):** Integre ELEMENTOS VISUAIS que REFLETIAM e AMPLIEM a EMOÇÃO do parágrafo. Como a imagem transmite o sentimento? (ex: "Gotas de chuva visíveis no ar, refratando a luz da lareira, simbolizando a tristeza contida do personagem"). Procure metáforas visuais.
    - **Movimento e Ação (O Que se Move?):** Se houver movimento ou ação significativa no parágrafo, descreva-o EXPLICITAMENTE. Isso pode incluir movimento de câmera (pan, tilt, zoom, tracking), movimento de personagens ou objetos, ou mudanças sutis como folhas caindo. (ex: "Câmera faz um slow tracking lateral para a direita, acompanhando o personagem enquanto ele caminha em direção à porta."). Se a cena for estática, indique isso claramente.
    - **Expressões Faciais e Linguagem Corporal (Como Parecem?):** Se houver personagens humanos, detalhe EXPLICITAMENTE a EXPRESSÃO FACIAL e a LINGUAGEM CORPORAL. Esses detalhes são fundamentais para transmitir emoções. (ex: "Mulher jovem com expressão de choque e descrença, olhos arregalados e boca ligeiramente aberta, mãos levadas ao rosto em um gesto de surpresa."). Seja específico sobre microexpressões se relevante.
    - **Símbolos e Elementos Narrativos Chave (O Que é Importante?):** Identifique e INCORPORE ELEMENTOS VISUAIS ESPECÍFICOS mencionados ou fortemente sugeridos pelo texto do parágrafo. Isso pode incluir objetos simbólicos, documentos, roupas, marcas, ícones culturais ou elementos da natureza. (ex: "Uma antiga bússola dourada repousa aberta sobre a mesa de madeira, apontando para fora do quadro, simbolizando a busca por direção."). Foque nos elementos que impulsionam a narrativa.
    - **Texturas e Materiais (Como se Sente?):** Inclua DESCRIÇÕES DE TEXTURAS e MATERIAIS para elementos-chave da cena para aumentar a sensação de realismo e tactilidade. (ex: "Superfície áspera e rachada de tijolos antigos", "Tecido de veludo vermelho desgastado e desbotado", "Superfície metálica brilhante e refletiva."). Use adjetivos sensoriais.
    - **Profundidade e Escala (Como é o Espaço?):** Especifique elementos que criem uma sensação de PROFUNDIDADE e ESCALA na imagem. Use elementos de primeiro plano, meio e fundo. (ex: "Um longo corredor escuro se estende até um ponto de fuga distante, com silhuetas de portas alinhadas nas paredes laterais, criando uma forte perspectiva linear."). Isso evita composições planas.
    - **Elementos Temporais ou Climáticos (Quando e Como está o Tempo?):** Se o contexto do parágrafo implicar um momento específico do dia, clima ou estação, INCLUA ESSES DETALHES. (ex: "Cena noturna sob uma lua crescente, com névoa leve pairando sobre o lago.", "Interior abafado de uma cozinha no verão, com luz do sol forte entrando pelas janelas."). Isso define o "clima" da cena visual.
3.  **DURAÇÃO ESTIMADA REALISTA E CONTEXTUAL (CONTEÚDO DA CHAVE "estimated_duration"):**
    - O valor DEVE ser um NÚMERO INTEIRO (sem decimais) representando a duração em SEGUNDOS.
    - O número deve estar EXCLUSIVAMENTE dentro do intervalo definido: **entre ${durationRange} segundos**.
    - Esta duração deve ser uma ESTIMATIVA REALISTA baseada na COMPLEXIDADE da cena descrita e no RITMO EMOCIONAL indicado no contexto (ex: cenas contemplativas com muitos detalhes visuais podem exigir mais tempo, enquanto ações rápidas podem precisar de menos). Evite valores no limite inferior ou superior sem justificativa clara.

**DADOS PARA ANÁLISE E GERAÇÃO (LOTE ATUAL - ANALISE CADA PARÁGRAFO):**
---
${promptContextForAI}
---

**AÇÃO FINAL E CRÍTICA:** Com base nestas instruções rigorosas, analise AGORA cada parágrafo fornecido e gere AGORA o array JSON com os prompts visuais correspondentes, seguindo EXATAMENTE todas as regras, formatos e níveis de detalhe especificados. Responda APENAS com o array JSON perfeito.
`;

            apiPromises.push(callGroqAPI(prompt, 4000).then(res => cleanGeneratedText(res, true)));
        }

        // >>>>> PROCESSAMENTO DOS RESULTADOS <<<<<
        const allBatchResults = await Promise.all(apiPromises);
        let allGeneratedPrompts = allBatchResults.flat();

        if (!Array.isArray(allGeneratedPrompts) || allGeneratedPrompts.length < paragraphsWithContext.length) {
            throw new Error("A IA não retornou um prompt para cada parágrafo.");
        }

        const curatedPrompts = allGeneratedPrompts.map((promptData, index) => {
            return {
                scriptPhrase: paragraphsWithContext[index].text,
                imageDescription: promptData.imageDescription || "Falha ao gerar descrição. Tente re-gerar.",
                estimated_duration: promptData.estimated_duration || 5
            };
        });

        // >>>>> ARMAZENAMENTO E RENDERIZAÇÃO <<<<<
        allImagePrompts[sectionElementId] = curatedPrompts.map((p) => ({ ...p, styleBlock: CINEMATIC_STYLE_BLOCK }));
        promptPaginationState[sectionElementId] = 0;

        promptContainer.innerHTML = `
            <div class="prompt-pagination-wrapper space-y-4">
                <div class="prompt-nav-container flex items-center justify-center gap-4"></div>
                <div class="prompt-items-container space-y-4"></div>
            </div>
        `;
        renderPaginatedPrompts(sectionElementId);

    } catch (error) {
        promptContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar prompts: ${error.message}</p>`;
        console.error("Erro detalhado em generatePromptsForSection:", error);
    } finally {
        hideButtonLoading(button);
    }
};
// =========================================================================
// >>>>> FIM DA VERSÃO BLINDADA DE 'generatePromptsForSection' <<<<<
// =========================================================================



    
        /**
         * Sugere trilhas sonoras para uma secção específica do roteiro.
         * @param {string} sectionId - O ID do elemento HTML da secção (ex: 'introSection').
         */
        window.suggestSoundtrack = async (sectionId) => {
            const sectionElement = document.getElementById(sectionId);
            const scriptContent = sectionElement.querySelector('.generated-content-wrapper').textContent; 
            const soundtrackContainer = sectionElement.querySelector('.soundtrack-container');
            
            if (!scriptContent) {
                window.showToast("Gere o roteiro para esta secção primeiro.");
                return;
            }

            soundtrackContainer.innerHTML = `<div class="loading-spinner-small"></div>`; 

            const prompt = `Você é um especialista em prompts para IAs de geração de música (como Suno/Udio). Sua tarefa é analisar o seguinte trecho de roteiro e criar 3 prompts de texto distintos e detalhados.

            **REGRAS DE FORMATAÇÃO (NÃO NEGOCIÁVEIS):**1.  Sua resposta DEVE SER um array JSON válido.2.  O array deve conter EXATAMENTE 3 strings.3.  CADA string deve ser um parágrafo único, bem escrito e descritivo, pronto para ser colado em uma IA de música. NÃO use chaves, colchetes ou qualquer outra sintaxe de objeto DENTRO da string do prompt.

            **EXEMPLO DE RESPOSTA PERFEITA:**
            ["Generate an epic, cinematic orchestral piece in the style of Hans Zimmer... No vocals or percussion, focus on the emotional intensity of the strings and piano.","Create a contemplative, melancholic ambient track with a slow, mournful tempo... No bright or cheerful notes, focus on the darker, more introspective tones.","Craft an uplifting, inspirational electronic piece with a moderate tempo... avoid any jarring or harsh sounds, focusing on the soaring, inspirational quality of the melody."
            ]

                Agora, use o roteiro abaixo como inspiração para criar 3 prompts seguindo EXATAMENTE este formato.

            Trecho do roteiro para analisar:
                    ---
                ${scriptContent}

                ---`;
            
            try {
                const rawResult = await callGroqAPI(prompt, 500);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const suggestions = JSON.parse(cleanedResult);

                // Adiciona tratamento de erro para garantir que suggestions é um array de strings
                if (!Array.isArray(suggestions) || !suggestions.every(s => typeof s === 'string')) {
                    throw new Error("A IA retornou um formato de trilha sonora inesperado. Esperava um array de strings.");
                }

                soundtrackContainer.innerHTML = ''; // Limpa o spinner
                if (suggestions && suggestions.length > 0) {
                    // Agora envolvemos a lista em um div com as classes corretas para ter um fundo e padding.
                    let suggestionsHtml = '<div class="card-background p-4 rounded-lg shadow-inner">';
                    suggestionsHtml += '<ul class="soundtrack-list">';
                    suggestions.forEach(suggestion => {
                        suggestionsHtml += `<li>${suggestion}</li>`;
                    });
                    suggestionsHtml += '</ul>';
                    suggestionsHtml += '</div>'; 

                    soundtrackContainer.innerHTML = suggestionsHtml;
                } else {
                    soundtrackContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhuma sugestão de trilha sonora foi gerada.</p>';
                }
            } catch (error) {
                soundtrackContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar sugestões: ${error.message}</p>`;
                console.error("Erro detalhado em suggestSoundtrack:", error);
            }
        };

        /**
         * Copia a transcrição para a área de transferência e
         * inicia o download de um arquivo .rtf limpo e com a codificação correta.
         */
        const handleCopyAndDownloadTranscript = () => {
            const transcriptText = getTranscriptOnly();

            if (!transcriptText) {
                window.showToast("Nenhum roteiro para copiar. Gere as seções primeiro.");
                return;
            }

            copyTextToClipboard(transcriptText);
            window.showToast("Transcrição copiada! Download do arquivo .rtf iniciado.");

            const fileName = (document.getElementById('videoTheme').value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro') + '_transcricao.rtf';
            
            // **A CORREÇÃO ESTÁ AQUI:**
            // 1. Escapa o texto para o formato RTF.
            // 2. Substitui as quebras de linha pelo comando de parágrafo do RTF.
            const safeText = escapeRtf(transcriptText);
            const rtfContent = `{\\rtf1\\ansi\\deff0 {\\fonttbl{\\f0 Arial;}}\\f0\\fs24 ${safeText.replace(/\n/g, '\\par\r\n')}}`;
            
            const blob = new Blob([rtfContent], { type: 'application/rtf' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };
    
        /**
         * Gera títulos de vídeo e ideias de thumbnail.
         */
                const generateTitlesAndThumbnails = async (button) => {
            if (!validateInputs()) return;
            showButtonLoading(button);

            try {
                const { prompt, maxTokens } = constructScriptPrompt('titles_thumbnails');
                
                const finalPrompt = prompt + `\n\nCRITICAL RULE: Inside the 'description' strings, you MUST use single quotes ('') for any internal quotes, or properly escape double quotes (\\\"). Failure to do so will result in an invalid JSON. Example: "A text overlay that says 'Hope is Here'".`;
                
                const result = await callGroqAPI(finalPrompt, maxTokens);
                const cleanedResult = cleanGeneratedText(result, true);
                
                if (!cleanedResult) {
                    throw new Error("A IA não retornou um JSON válido.");
                }
                
                const parsedContent = cleanedResult;
                generatedTitlesAndThumbnails = parsedContent;


                if (!Array.isArray(parsedContent.titles) || !Array.isArray(parsedContent.thumbnails)) {
                    console.error("Formato de Títulos/Thumbnails inválido recebido da IA:", parsedContent);
                    throw new Error("A IA retornou os dados de títulos em um formato inesperado. Tente novamente.");
                }


                const targetContentElement = document.getElementById('titlesThumbnailsContent');
                if (targetContentElement) {
                    const titlesListHtml = parsedContent.titles.map((title, index) => `<p>${index + 1}. ${title}</p>`).join('');
                    const thumbnailsListHtml = parsedContent.thumbnails.map((thumb, index) => `
                        <div class="${index === 0 ? '' : 'thumbnail-item-separator'}"> 
                            <p class="font-semibold">"${thumb.title}"</p>
                            <p class="text-sm leading-tight">Descrição: ${thumb.description}</p>
                        </div>
                    `).join('');

                    targetContentElement.innerHTML = `
                        <div class="generated-output-box">
                            <div>
                                <h4 class="output-subtitle">Sugestões de Títulos:</h4>
                                <div class="output-content-block">${titlesListHtml}</div>
                                <div class="mt-3">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeTitles()">Analisar CTR</button>
                                    <div id="ctrAnalysisResult" class="mt-3"></div>
                                </div>
                            </div>
                            <div>
                                <h4 class="output-subtitle">Ideias de Thumbnail:</h4>
                                <div class="output-content-block">${thumbnailsListHtml}</div>
                                <div class="mt-3">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeThumbnails()">Analisar Thumbnails</button>
                                    <div id="thumbnailAnalysisResult" class="mt-3"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    markButtonAsCompleted(button.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar Títulos: ${error.message}`);
                console.error("Error generating Titles/Thumbnails.", error);
            } finally {
                hideButtonLoading(button);
                updateButtonStates();
            }
        };


// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO analyzeTitles INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
// =========================================================================

window.analyzeTitles = async () => {
    if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.titles || generatedTitlesAndThumbnails.titles.length === 0) {
        window.showToast("Gere os títulos primeiro!");
        return;
    }

    const resultContainer = document.getElementById('ctrAnalysisResult');
    resultContainer.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small"></div>`);

    const titlesString = generatedTitlesAndThumbnails.titles.join('\n');
    
    // >>> PROMPT BLINDADO COM REGRAS DE SINTAXE E ESTRUTURA EXPLÍCITAS <<<
    const prompt = `Você é uma API de análise de títulos do YouTube que retorna APENAS um array JSON.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`[\` e terminando com \`]\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar aspas duplas (\`"\`).
3.  **VÍRGULA FINAL:** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último objeto.
4.  **ESTRUTURA DO OBJETO:** Cada objeto no array DEVE conter EXATAMENTE estas três chaves: "titulo_original" (string), "nota_ctr" (um número de 0 a 10), e "sugestao_melhora" (string).

**EXEMPLO DE FORMATO PERFEITO E OBRIGATÓRIO:**
[
  {
    "titulo_original": "Título Exemplo 1",
    "nota_ctr": 8,
    "sugestao_melhora": "Adicionar um número ou um gatilho de curiosidade."
  },
  {
    "titulo_original": "Título Exemplo 2",
    "nota_ctr": 6,
    "sugestao_melhora": "Encurtar para ser mais direto e impactante."
  }
]

**Títulos para analisar:**
---
${titlesString}
---

Responda APENAS com o array JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE as regras acima.`;

    try {
        const rawResult = await callGroqAPI(prompt, 3000);
        const analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis)) {
            throw new Error("A IA não retornou uma análise de títulos em formato válido.");
        }

        let analysisHtml = '<div class="space-y-4">';
        analysis.forEach(item => {
            analysisHtml += `
                <div class="p-3 card-background rounded-md shadow-sm">
                    <p class="font-semibold text-gray-800 dark:text-gray-200">${DOMPurify.sanitize(item.titulo_original)}</p>
                    <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de CTR:</strong> <span class="text-indigo-500 font-bold">${DOMPurify.sanitize(String(item.nota_ctr))} / 10</span></p>
                    <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugestão:</strong> ${DOMPurify.sanitize(item.sugestao_melhora)}</p>
                </div>
            `;
        });
        analysisHtml += '</div>';
        resultContainer.innerHTML = DOMPurify.sanitize(analysisHtml);

    } catch (error) {
        console.error("Erro detalhado em analyzeTitles:", error);
        resultContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">Falha ao analisar os títulos: ${error.message}</p>`);
    }
};

// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO analyzeThumbnails INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
// =========================================================================

window.analyzeThumbnails = async () => {
    if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.thumbnails || generatedTitlesAndThumbnails.thumbnails.length === 0) {
        window.showToast("Gere as ideias de thumbnail primeiro!");
        return;
    }

    const resultContainer = document.getElementById('thumbnailAnalysisResult');
    resultContainer.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small"></div>`);

    const thumbnailsString = generatedTitlesAndThumbnails.thumbnails.map(t => `Título: ${t.title}, Descrição: ${t.description}`).join('\n---\n');
    
    // >>> PROMPT BLINDADO COM REGRAS DE SINTAXE E ESTRUTURA EXPLÍCITAS <<<
    const prompt = `Você é uma API de análise de thumbnails do YouTube que retorna APENAS um array JSON.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`[\` e terminando com \`]\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar aspas duplas (\`"\`).
3.  **VÍRGULA FINAL:** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último objeto.
4.  **ESTRUTURA DO OBJETO:** Cada objeto no array DEVE conter EXATAMENTE estas três chaves: "titulo" (string, contendo o título original da ideia analisada), "nota_visual" (um número de 0 a 10), e "sugestao_melhora" (string).

**EXEMPLO DE FORMATO PERFEITO E OBRIGATÓRIO:**
[
  {
    "titulo": "Ideia de Thumbnail 1",
    "nota_visual": 7,
    "sugestao_melhora": "Aumentar o contraste e usar uma fonte mais legível no texto."
  },
  {
    "titulo": "Ideia de Thumbnail 2",
    "nota_visual": 9,
    "sugestao_melhora": "Adicionar um contorno brilhante ao redor da pessoa para destacá-la do fundo."
  }
]

**Ideias para analisar:**
---
${thumbnailsString}
---

Responda APENAS com o array JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE as regras acima.`;

    try {
        const rawResult = await callGroqAPI(prompt, 2500);
        const analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis)) {
            throw new Error("A IA não retornou uma análise de thumbnails em formato válido.");
        }

        let analysisHtml = '<div class="space-y-4">';
        analysis.forEach(item => {
            analysisHtml += `
                <div class="p-3 card-background rounded-md shadow-sm">
                    <p class="font-semibold text-gray-800 dark:text-gray-200">"${DOMPurify.sanitize(item.titulo || 'Ideia Sem Título')}"</p>
                    <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de Potencial Visual:</strong> <span class="text-indigo-500 font-bold">${DOMPurify.sanitize(String(item.nota_visual))} / 10</span></p>
                    <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugestão:</strong> ${DOMPurify.sanitize(item.sugestao_melhora)}</p>
                </div>
            `;
        });
        analysisHtml += '</div>';
        resultContainer.innerHTML = DOMPurify.sanitize(analysisHtml);

    } catch (error) {
        console.error("Erro detalhado em analyzeThumbnails:", error);
        resultContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">Falha ao analisar as thumbnails: ${error.message}</p>`);
    }
};



        /**
         * Gera a descrição do vídeo e hashtags.
         */
            const generateVideoDescription = async (button) => {
            if (!validateInputs()) return;
            showButtonLoading(button);

            try {
                let result = await callGroqAPI(constructScriptPrompt('description').prompt, constructScriptPrompt('description').maxTokens);
                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);
                
                const targetContentElement = document.getElementById('videoDescriptionContent');
                if (targetContentElement) {
                    // >>> AQUI ESTÁ A MUDANÇA <<<
                    const sanitizedResult = DOMPurify.sanitize(`<div class="generated-output-box whitespace-pre-wrap">${result}</div>`);
                    targetContentElement.innerHTML = sanitizedResult;
                    markButtonAsCompleted(button.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar Descrição: ${error.message}`);
                console.error("Error generating Video Description.", error);
            } finally {
                hideButtonLoading(button);
                updateButtonStates();
            }
        };

// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO generateStrategicOutline INTEIRA <<<<<
// =========================================================================

const generateStrategicOutline = async (button) => {
    if (!validateInputs()) return;
    showButtonLoading(button);
    
    const outlineContentDiv = document.getElementById('outlineContent');
    if (outlineContentDiv) {
        outlineContentDiv.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small mx-auto"></div>`);
    } else {
        window.showToast("Erro: Container do esboço não encontrado.");
        hideButtonLoading(button);
        return;
    }

    try {
        const { prompt } = constructScriptPrompt('outline'); // Usamos o prompt blindado
        const rawResult = await callGroqAPI(prompt, 4000);
        
        strategicOutline = cleanGeneratedText(rawResult, true);

        if (!strategicOutline || typeof strategicOutline !== 'object' || !strategicOutline.introduction) {
            console.error("A IA retornou um esboço em formato inválido:", rawResult);
            throw new Error("A IA falhou em gerar um esboço válido.");
        }

        const titleTranslations = {
            'introduction': 'Introdução', 'development': 'Desenvolvimento',
            'climax': 'Clímax', 'conclusion': 'Conclusão', 'cta': 'CTA'
        };
        
        let outlineHtml = '<ul class="space-y-4 text-sm">';
        for (const key in strategicOutline) {
            if (Object.hasOwnProperty.call(strategicOutline, key)) {
                const translatedTitle = titleTranslations[key] || key;
                const contentValue = strategicOutline[key];
                
                outlineHtml += `<li><div><strong class="text-indigo-600 dark:text-indigo-400">${translatedTitle}:</strong>`;
                
                // <<< AQUI ESTÁ A NOVA LÓGICA INTELIGENTE DE RENDERIZAÇÃO >>>
                if (typeof contentValue === 'string') {
                    outlineHtml += ` <span class="text-gray-600 dark:text-gray-300">${DOMPurify.sanitize(contentValue)}</span>`;
                } else if (typeof contentValue === 'object' && contentValue !== null) {
                    outlineHtml += '<ul class="list-disc pl-5 mt-1 space-y-1">';
                    for (const subKey in contentValue) {
                        if(Array.isArray(contentValue[subKey])) { // Para o caso do Desenvolvimento ter seções
                             contentValue[subKey].forEach(section => {
                                outlineHtml += `<li><span class="font-semibold">${DOMPurify.sanitize(section.title || subKey)}:</span> ${DOMPurify.sanitize(section.description || '')}</li>`;
                             });
                        } else {
                            outlineHtml += `<li><span class="font-semibold">${DOMPurify.sanitize(subKey.replace(/_/g, ' '))}:</span> ${DOMPurify.sanitize(contentValue[subKey])}</li>`;
                        }
                    }
                    outlineHtml += '</ul>';
                }
                
                outlineHtml += '</div></li>';
            }
        }
        outlineHtml += '</ul>';
        
        outlineContentDiv.innerHTML = outlineHtml; // A sanitização já foi feita nos pedaços
        markButtonAsCompleted(button.dataset.action ? button.id : 'generateOutlineBtn');

        const scriptContainer = document.getElementById('scriptSectionsContainer');
        if (scriptContainer) {
            scriptContainer.innerHTML = ''; 
            scriptContainer.innerHTML += DOMPurify.sanitize(createScriptSectionPlaceholder('intro', 'Introdução', 'generateIntroBtn', 'generateIntro'));
            scriptContainer.innerHTML += DOMPurify.sanitize(createScriptSectionPlaceholder('development', 'Desenvolvimento', 'generateDevelopmentBtn', 'generateDevelopment'));
            scriptContainer.innerHTML += DOMPurify.sanitize(createScriptSectionPlaceholder('climax', 'Clímax', 'climaxBtn', 'generateClimax'));
        }

    } catch (error) {
        console.error("Erro detalhado em generateStrategicOutline:", error);
        window.showToast(`Falha ao gerar Esboço: ${error.message}`);
        // ... (resto do seu catch)
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};


        /**
         * Realiza o download do roteiro como PDF.
         */
        const downloadPdf = async () => {
            // 1. Criar um container temporário para a impressão
            let printContainer = document.createElement('div');
            printContainer.id = 'print-container';

            // 2. Coletar e formatar TODO o conteúdo que queremos imprimir
            let htmlToPrint = `<h1 style="text-align: center; font-size: 22pt; margin-bottom: 24px;">${elements.videoTheme.value}</h1>`;

            // Adicionar o esboço estratégico
            if (strategicOutline) {
                const titleTranslations = {
                    'introduction': 'Introdução',
                    'development': 'Desenvolvimento',
                    'climax': 'Clímax',
                    'conclusion': 'Conclusão',
                    'cta': 'CTA'
                };
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Esboço Estratégico</div>
                        <div class="print-section-content">
                            <ul style="list-style-type: disc; padding-left: 20px;">`;
                for (const key in strategicOutline) {
                    const translatedTitle = titleTranslations[key] || (key.charAt(0).toUpperCase() + key.slice(1));
                    htmlToPrint += `<li><strong>${translatedTitle}:</strong> ${strategicOutline[key]}</li>`;
                }
                htmlToPrint += `</ul></div></div>`;
            }

            // Adicionar o roteiro principal
            document.querySelectorAll('#scriptSectionsContainer .accordion-item').forEach(item => {
                const title = item.querySelector('h3')?.textContent;
                const content = item.querySelector('.generated-content-wrapper')?.textContent;
                if (title && content) {
                    htmlToPrint += `
                        <div class="print-section">
                            <div class="print-section-title">${title}</div>
                            <div class="print-section-content"><pre>${content}</pre></div>
                        </div>`;
                }
            });
            
            // Adicionar Descrição e Hashtags
            const videoDescriptionContent = document.getElementById('videoDescriptionContent');
            if (videoDescriptionContent && videoDescriptionContent.textContent.trim() !== 'Clique em \'Gerar\' para ver a descrição') {
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Descrição & Hashtags</div>
                        <div class="print-section-content">${videoDescriptionContent.innerHTML}</div>
                    </div>`;
            }

            // Adicionar Títulos e Thumbnails
            const titlesThumbnailsContent = document.getElementById('titlesThumbnailsContent');
            if (titlesThumbnailsContent && titlesThumbnailsContent.textContent.trim() !== 'Clique em \'Gerar\' para ver as sugestões') {
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Títulos & Thumbnails</div>
                        <div class="print-section-content">${titlesThumbnailsContent.innerHTML}</div>
                    </div>`;
            }

            // 3. Injetar o HTML no container e adicioná-lo ao body
            printContainer.innerHTML = htmlToPrint;
            document.body.appendChild(printContainer);

            // 4. Chamar a impressão
            window.print();

            // 5. Remover o container temporário após a impressão (com um pequeno atraso para garantir a renderização)
            setTimeout(() => {
                document.body.removeChild(printContainer);
            }, 500); // 500ms de atraso
        };



// =========================================================================
// >>>>> PASSO 4: SUBSTITUA A FUNÇÃO resetApplicationState INTEIRA POR ESTA <<<<<
// =========================================================================
const resetApplicationState = () => {
    projectState = {
        intro: false,
        development: false,
        climax: false,
        conclusion: false,
        cta: false
    };

    const safeReset = (elementId, value = '') => { /* ... */ };

    // ... (o resto da sua função de reset, que já está correta)
    
    // Apenas para garantir, o miolo da função deve ser este:
    safeReset('channelName', 'The Biblical Unveiling');
    safeReset('videoTheme');
    safeReset('videoDescription');
    safeReset('targetAudience', ''); 
    safeReset('languageSelect', 'en');
    safeReset('videoObjective', 'informar');
    safeReset('videoDuration', '');
    safeReset('speakingPace', 'moderate');
    safeReset('narrativeGoal', 'storytelling');
    safeReset('narrativeTheme');
    safeReset('narrativeTone', 'inspirador');
    safeReset('narrativeVoice');
    safeReset('centralQuestion');
    safeReset('emotionalArc');
    safeReset('shockingEndingHook');
    safeReset('imageDescriptionEngine');
    safeReset('imageStyleSelect', 'cinematic');
    safeReset('customImageStyle');
    safeReset('researchData');
    safeReset('emotionalHook');

    toggleCustomImageStyleVisibility();
    updateNarrativeStructureOptions();

    const nicheDesc = document.getElementById('nicheDescription');
    const ideasOut = document.getElementById('ideasOutput');
    if (nicheDesc) nicheDesc.value = '';
    if (ideasOut) ideasOut.innerHTML = '';

    strategicOutline = null;
    allImagePrompts = {};
    generatedTitlesAndThumbnails = null;
    totalScriptSeconds = 0;
    promptPaginationState = {};

    resetProjectOutputs();

    window.showToast("Pronto para um novo roteiro!");
    window.scrollTo({ top: 0, behavior: 'smooth' });
};
        

        /**
         * Exporta o estado atual do projeto para um ficheiro JSON.
         */
        const exportProject = () => {
            const projectData = {
                inputs: {},
                outputs: {},
                memory: {
                    allImagePrompts: allImagePrompts,
                    generatedTitlesAndThumbnails: generatedTitlesAndThumbnails,
                    strategicOutline: strategicOutline, // Exporta o esboço
                    promptPaginationState: promptPaginationState // Export pagination state
                }
            };

            // Salva o estado dos inputs
            for (const key in elements) {
                if (elements[key] && typeof elements[key].value !== 'undefined') {
                    projectData.inputs[key] = elements[key].value;
                }
            }
            // Salva o conteúdo gerado (HTML interno das secções)
            const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection']; // CTA is now part of conclusionSection
            scriptSectionIds.forEach(id => {
                const sectionElement = document.getElementById(id);
                if (sectionElement) {
                    projectData.outputs[id] = sectionElement.innerHTML;
                }
            });

            // Salva o conteúdo do esboço
            projectData.outputs.strategicOutlineContent = elements.outlineContent.innerHTML;

            // Salva o conteúdo dos cartões de recursos
            projectData.outputs.titlesThumbnailsContent = document.getElementById('titlesThumbnailsContent').innerHTML;
            projectData.outputs.videoDescriptionContent = document.getElementById('videoDescriptionContent').innerHTML;
            // Removed storyboardContent export
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            const fileName = elements.videoTheme.value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro_viral';
            downloadAnchorNode.setAttribute("download", `${fileName}_projeto.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            document.body.removeChild(downloadAnchorNode);
            downloadAnchorNode.remove();
            window.showToast("Projeto exportado com sucesso!");
        };

        /**
         * Renderiza os prompts de imagem para uma secção específica na UI.
         * Usado após carregar um projeto.
         * @param {string} sectionElementId - O ID do elemento HTML da secção.
         */
        const renderImagePromptsForSection = (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            if (!sectionElement) return;

            const promptContainer = sectionElement.querySelector('.prompt-container');
            if (!promptContainer) return;

            // Re-cria a estrutura de paginação se ela não existir
            if (!promptContainer.querySelector('.prompt-pagination-wrapper')) {
                promptContainer.innerHTML = `
                    <div class="prompt-pagination-wrapper space-y-4">
                        <div class="prompt-nav-container flex items-center justify-center gap-4">
                            <!-- Controles de navegação serão inseridos aqui -->
                        </div>
                        <div class="prompt-items-container space-y-4">
                            <!-- Os 4 prompts da página atual serão inseridos aqui -->
                        </div>
                    </div>
                `;
            }

            // Renderiza a página atual de prompts
            renderPaginatedPrompts(sectionElementId);
        };

        /**
         * Importa um projeto de um ficheiro JSON.
         * @param {Event} event - O evento de mudança do input de ficheiro.
         */
        const importProject = (event) => {
            const file = event.target.files[0];
            if (!file) { return; }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    
                    resetApplicationState();

                    // Restaura os inputs
                    const inputIds = [
                        'channelName', 'videoTheme', 'videoDescription', 'targetAudience', 
                        'languageSelect', 'videoObjective', 'videoDuration', 'speakingPace', 
                        'narrativeGoal', 'narrativeStructure', 'narrativeTheme', 'narrativeTone', 
                        'narrativeVoice', 'centralQuestion', 'emotionalArc', 'shockingEndingHook', 'imageDescriptionEngine', 
                        'imageStyleSelect', 'customImageStyle'
                    ];
                    inputIds.forEach(id => {
                        const element = document.getElementById(id);
                        if (element && projectData.inputs[id] !== undefined) {
                            element.value = projectData.inputs[id];
                        }
                    });
                    
                    const structureSelect = document.getElementById('narrativeStructure');
                    if (structureSelect && projectData.inputs['narrativeStructure']) {
                        structureSelect.value = projectData.inputs['narrativeStructure'];
                        // Ensure the tooltip is updated after setting the structure value
                        
                    }

                    // Restaura o conteúdo gerado
                    const outputIds = [
                        'introSection', 'developmentSection', 'climaxSection', 'conclusionSection', // CTA is now part of conclusionSection
                        'outlineContent', 'titlesThumbnailsContent', 'videoDescriptionContent'
                    ];
                    outputIds.forEach(id => {
                        const element = document.getElementById(id);
                        if (element && projectData.outputs[id]) {
                            element.innerHTML = projectData.outputs[id]; 
                        }
                    });
                    
                    strategicOutline = projectData.memory.strategicOutline || null;
                    allImagePrompts = projectData.memory.allImagePrompts || {};
                    generatedTitlesAndThumbnails = projectData.memory.generatedTitlesAndThumbnails || null;
                    promptPaginationState = projectData.memory.promptPaginationState || {}; // Load pagination state

                    // Renderiza os prompts de imagem paginados após carregar
                    const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection'];
                    scriptSectionIds.forEach(id => {
                        if (allImagePrompts[id] && allImagePrompts[id].length > 0) {
                            renderImagePromptsForSection(id);
                        }
                    });

                    updateButtonStates();
                    
                    if (elements.outlineContent.textContent.trim().length > 100) markButtonAsCompleted('generateOutlineBtn');
                    if (document.getElementById('introSection').innerHTML.trim()) markButtonAsCompleted('generateIntroBtn');
                    if (document.getElementById('developmentSection').innerHTML.trim()) markButtonAsCompleted('generateDevelopmentBtn');
                    if (document.getElementById('climaxSection').innerHTML.trim()) markButtonAsCompleted('climaxBtn');
                    if (document.getElementById('conclusionSection').innerHTML.trim()) markButtonAsCompleted('conclusionBtn');
                    if (document.getElementById('videoDescriptionContent').innerHTML.includes('Hashtags')) markButtonAsCompleted('generateDescriptionBtn');
                    if (document.getElementById('titlesThumbnailsContent').innerHTML.includes('Analisar CTR')) markButtonAsCompleted('generateTitlesAndThumbnailsBtn');

                    updateProgressBar(); 
                    
                    elements.projectDashboard.classList.remove('hidden');
                    window.showToast("Projeto importado com sucesso!");

                } catch (err) {
                    window.showToast("Erro: Ficheiro de projeto inválido ou corrompido.");
                    console.error("Erro ao importar projeto:", err);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        };



// =-==================================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A SUA FUNÇÃO suggestStrategy INTEIRA POR ESTA VERSÃO <<<<<
// =-==================================================================================

const suggestStrategy = async (button) => {
    if (document.querySelector('#scriptSectionsContainer .accordion-item')) {
        const userConfirmed = await showConfirmationDialog(
            "Sugerir Nova Estratégia?",
            "Isso limpará todo o roteiro e metadados já gerados para aplicar a nova sugestão. Deseja continuar?"
        );
        if (!userConfirmed) return;
    }

    resetProjectOutputs();

    const theme = document.getElementById('videoTheme')?.value.trim();
    const description = document.getElementById('videoDescription')?.value.trim();
    if (!theme || !description) {
        window.showToast("Preencha o Tema e a Descrição do Vídeo para receber sugestões.");
        return;
    }

    showButtonLoading(button);
    isSettingStrategy = true;

    const selectedLangCode = document.getElementById('languageSelect').value;
    const languageName = selectedLangCode === 'pt-br' ? 'Português (Brasil)' : 'English';

    const validOptions = {
        narrative_goal: `['${Array.from(document.getElementById('narrativeGoal').options).map(o => o.value).filter(Boolean).join("', '")}']`,
        narrative_tone: `['${Array.from(document.getElementById('narrativeTone').options).map(o => o.value).filter(Boolean).join("', '")}']`,
        language_style: `['${Array.from(document.getElementById('languageStyle').options).map(o => o.value).filter(Boolean).join("', '")}']`,
        video_objective: `['${Array.from(document.getElementById('videoObjective').options).map(o => o.value).filter(Boolean).join("', '")}']`,
        speaking_pace: `['${Array.from(document.getElementById('speakingPace').options).map(o => o.value).filter(Boolean).join("', '")}']`,
    };

// =========================================================================
// >>>>> PROMPT FINAL E BLINDADO PARA PREENCHIMENTO INICIAL <<<<<
// =========================================================================
const prompt = `Você é uma API de Estratégia de Conteúdo Viral altamente especializada. Sua única função é gerar um objeto JSON contendo uma estratégia de vídeo de EXCEPCIONAL qualidade com base em um tema e descrição fornecidos.

**TAREFA PRINCIPAL:** Analisar o tema e a descrição, e criar uma estratégia de vídeo completa, envolvente e com alto potencial de engajamento.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (ABSOLUTAMENTE INEGOCIÁVEIS):**
1.  **JSON PURO E PERFEITO:** Sua resposta inteira deve ser APENAS um objeto JSON válido, começando com \`{\` e terminando com \`}\`. NENHUM outro texto, comentário ou explicação é permitido. Pense nisso como uma resposta de API pura e impecável.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar obrigatoriamente aspas duplas (\`"\`).
3.  **PREENCHIMENTO TOTAL E EXATO:** Você DEVE preencher EXATAMENTE as chaves listadas no "MANUAL DE PREENCHIMENTO" abaixo. Nenhuma chave pode estar faltando, e nenhuma chave extra deve ser adicionada.
4.  **TIPOS DE DADOS EXATOS:**
    - Todas as chaves e valores devem ser strings.
    - Para campos com escolhas pré-definidas (como "narrative_goal", "narrative_structure", etc.), você DEVE escolher EXATAMENTE um dos valores permitidos listados.
5.  **IDIOMA:** Lembre-se, todos os valores de texto devem estar em **${languageName}**.

**MANUAL DE PREENCHIMENTO (SIGA ESTAS INSTRUÇÕES PARA CADA CAMPO):**
-   **"target_audience" (Público-Alvo Específico):** Defina um segmento CLARAMENTE caracterizado que se beneficiará MÁXIMO deste vídeo. Evite generalidades. Seja demográfico, psicográfico ou comportamental. (Ex: "Jovens em transição de carreira buscando propósito", "Pais de adolescentes com dificuldades escolares")
-   **"narrative_goal" (Objetivo Narrativo Central):** Escolha EXATAMENTE UM valor de: ${validOptions.narrative_goal}. Justifique sua escolha com base no tema.
-   **"narrative_structure" (Estrutura Narrativa Ideal):** Com base no "narrative_goal" escolhido, selecione uma estrutura compatível:
    -   Se 'storytelling', escolha de: ["documentary", "heros_journey", "pixar_spine", "mystery_loop", "twist"].
    -   Se 'storyselling', escolha de: ["underdog_victory", "discovery_mentor", "if_not_found_create", "pas", "bab"].
    Explique brevemente por que esta estrutura se encaixa.
-   **"narrative_theme" (Tema Principal Profundo):** Defina o tema central de forma concisa, mas com profundidade. Vá além do tópico óbvio. (Ex: "Não é sobre 'produtividade', é sobre 'recuperar o controle do próprio tempo'")
-   **"narrative_tone" (Tom Emocional do Vídeo):** Escolha EXATAMENTE UM valor de: ${validOptions.narrative_tone}. Este tom deve guiar toda a narrativa.
-   **"narrative_voice" (Personalidade do Narrador):** Descreva a voz do narrador de forma vívida. Quem está falando com o espectador? (Ex: "Um mentor sábio e compassivo", "Um amigo curioso e um pouco sarcástico")
-   **"central_question" (A Pergunta que Tudo Conecta):** Formule uma pergunta poderosa e envolvente que será o fio condutor lógico e emocional do vídeo. Esta pergunta deve ser respondida ao longo do conteúdo.
-   **"emotional_arc" (Jornada Emocional do Espectador):** Descreva a jornada emocional em 3 atos: Como o espectador deve se SENTIR no início, no meio e no clímax do vídeo? (Ex: "Início: Curioso e um pouco ansioso. Meio: Empático e intrigado. Clímax: Inspirado e determinado.")
-   **"emotional_hook" (História Pessoal Cativante):** Crie uma história pessoal (real ou fictícia, mas plausível) que servirá como fio condutor emocional. Esta história deve ilustrar a "central_question".
-   **"shocking_ending_hook" (Frase de Impacto Inicial):** Crie uma frase curta, impactante e intrigante para ser usada como gancho inicial (hook) do vídeo. Deve prender a atenção imediatamente.
-   **"language_style" (Estilo Linguístico):** Escolha EXATAMENTE UM valor de: ${validOptions.language_style}. Este estilo deve ser consistente em todo o roteiro.
-   **"video_objective" (Objetivo Final do Vídeo):** Escolha EXATAMENTE UM valor de: ${validOptions.video_objective}. Qual é o resultado desejado no espectador após assistir?
-   **"speaking_pace" (Ritmo da Narração):** Escolha EXATAMENTE UM valor de: ${validOptions.speaking_pace}. Este ritmo deve refletir o "narrative_tone" e o "video_objective".
-   **"image_description_engine" (Palavras-Chave Visuais):** Sugira 3-5 palavras-chave que definam o estilo visual e os elementos principais para as imagens/animções do vídeo.
-   **"research_data" (Diretrizes de Pesquisa):** Liste 2-3 pontos ESPECÍFICOS de dados, estatísticas ou informações que DEVEM ser pesquisados para embasar o roteiro. NÃO invente dados; apenas direcione a pesquisa.

**DADOS DE ENTRADA PARA ANALISAR E ESTRATEGIZAR:**
- **Tema do Vídeo:** "${theme}"
- **Descrição:** "${description}"

**AÇÃO FINAL:** Gere AGORA o objeto JSON completo e sintaticamente PERFEITO, preenchendo todas as chaves com valores criativos, estratégicos e totalmente alinhados com o tema e descrição fornecidos. Responda APENAS com o objeto JSON.
`;
    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const strategy = cleanGeneratedText(rawResult, true);

        if (!strategy || typeof strategy !== 'object') {
            throw new Error("A IA não retornou uma resposta em formato JSON válido.");
        }

        // Lógica de preenchimento dos campos (permanece a mesma)
        const narrativeGoalSelect = document.getElementById('narrativeGoal');
        const narrativeStructureSelect = document.getElementById('narrativeStructure');
        if (narrativeGoalSelect && strategy.narrative_goal) {
            narrativeGoalSelect.value = strategy.narrative_goal;
            updateNarrativeStructureOptions();
        }
        if (narrativeStructureSelect && strategy.narrative_structure) {
            setTimeout(() => {
                if ([...narrativeStructureSelect.options].some(option => option.value === strategy.narrative_structure)) {
                    narrativeStructureSelect.value = strategy.narrative_structure;
                } else {
                    narrativeStructureSelect.selectedIndex = 0;
                    console.warn(`A estrutura '${strategy.narrative_structure}' não foi encontrada. Usando fallback.`);
                }
                updateMainTooltip();
            }, 50);
        }
        
        const keyToElementIdMap = {
            'target_audience': 'targetAudience', 'narrative_theme': 'narrativeTheme',
            'narrative_tone': 'narrativeTone', 'narrative_voice': 'narrativeVoice',
            'central_question': 'centralQuestion', 'emotional_arc': 'emotionalArc',
            'emotional_hook': 'emotionalHook', 'shocking_ending_hook': 'shockingEndingHook',
            'language_style': 'languageStyle', 'video_objective': 'videoObjective',
            'speaking_pace': 'speakingPace', 'image_description_engine': 'imageDescriptionEngine',
            'research_data': 'researchData'
        };
        for (const key in keyToElementIdMap) {
            if (strategy[key]) {
                const element = document.getElementById(keyToElementIdMap[key]);
                if (element) { element.value = strategy[key]; }
            }
        }

        window.showToast("Estratégia sugerida pela IA! Revise e edite como desejar.");
        document.querySelector('[data-tab="input-tab-estrategia"]')?.click();

    } catch (error) {
        console.error("Erro detalhado em suggestStrategy:", error);
        window.showToast(`Falha ao sugerir estratégia: ${error.message}`);
    } finally {
        isSettingStrategy = false;
        hideButtonLoading(button);
    }
};


/**
 * Valida os inputs essenciais e avança para o painel de criação do roteiro.
 * Não utiliza a IA, apenas libera a próxima etapa.
 */
const startCrafting = () => {
    // Valida apenas os campos mais essenciais para garantir que há uma base para o roteiro.
    if (!validateInputs()) { // Reutilizamos a validação que já obriga os campos da aba "Básico"
        return;
    }
    
    const dashboard = document.getElementById('projectDashboard');
    if (dashboard) {
        dashboard.classList.remove('hidden');
        dashboard.scrollIntoView({ behavior: 'smooth', block: 'start' });
        window.showToast("Estratégia definida! Pronto para criar o esboço.");
    }
};

// =========================================================================
// >>>>> SUBSTITUA O SEU LISTENER DOMContentLoaded INTEIRO POR ESTE <<<<<
// =========================================================================
document.addEventListener('DOMContentLoaded', () => {
    // --- 1. MAPEAMENTO INICIAL DE ELEMENTOS ---
    document.querySelectorAll('[id]').forEach(el => {
        if (el.tagName === 'BUTTON') { buttons[el.id] = el; } 
        else { elements[el.id] = el; }
    });

    // --- 2. INICIALIZAÇÃO DE FUNÇÕES DA INTERFACE ---
    setupInputTabs();
    updateProgressBar();
    updateButtonStates();
    updateNarrativeStructureOptions();
    updateGoalPopover();

    // --- 3. EVENT LISTENERS ESPECÍFICOS ---
    const goalSelect = document.getElementById('narrativeGoal');
    if (goalSelect) { goalSelect.addEventListener('change', updateNarrativeStructureOptions); }

    const structureSelect = document.getElementById('narrativeStructure');
    if (structureSelect) { structureSelect.addEventListener('change', updateMainTooltip); }
    
    const imageStyleSelect = document.getElementById('imageStyleSelect');
    if (imageStyleSelect) { imageStyleSelect.addEventListener('change', toggleCustomImageStyleVisibility); }
    
    const importInput = document.getElementById('importFileInput');
    if (importInput) { importInput.addEventListener('change', importProject); }
    
    const darkModeToggle = document.getElementById('darkModeToggle');
    if (darkModeToggle) {
        darkModeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark');
            const isDarkMode = document.body.classList.contains('dark');
            document.getElementById('moonIcon').classList.toggle('hidden', isDarkMode);
            document.getElementById('sunIcon').classList.toggle('hidden', !isDarkMode);
            localStorage.setItem('darkMode', isDarkMode ? 'enabled' : 'disabled');
        });
    }

    if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark');
        const moonIcon = document.getElementById('moonIcon');
        const sunIcon = document.getElementById('sunIcon');
        if(moonIcon) moonIcon.classList.add('hidden');
        if(sunIcon) sunIcon.classList.remove('hidden');
    }

    const speakingPaceSelect = document.getElementById('speakingPace');
    if (speakingPaceSelect) { speakingPaceSelect.addEventListener('change', updateAllReadingTimes); }
    

    // --- 4. O "GERENTE DE CLIQUES" (versão completa e corrigida) ---


// =========================================================================
// >>>>> PASSO 3: SUBSTITUA O OBJETO 'actions' INTEIRO POR ESTA VERSÃO <<<<<
// =========================================================================
const actions = {
    'suggestStrategy': (btn) => suggestStrategy(btn, null),
    'referenceStrategy': (btn) => getReferenceStrategy(btn),
    'startCrafting': (btn) => startCrafting(),
    'generateIdeas': (btn) => generateVideoIdeas(btn),
    'unravelEnigmas': (btn) => unravelEnigmas(btn),
    'generateOutline': (btn) => generateStrategicOutline(btn),
    'mapEmotions': (btn) => mapEmotionsAndPacing(btn),
    'generateDescription': (btn) => generateVideoDescription(btn),
    'generateTitlesAndThumbnails': (btn) => generateTitlesAndThumbnails(btn),
    'generateSoundtrack': (btn) => generateSoundtrack(btn),
    'generateIntro': (btn) => handleGenerateSection(btn, 'intro', 'Introdução', 'intro'),
    'generateDevelopment': (btn) => handleGenerateSection(btn, 'development', 'Desenvolvimento', 'development'),
    'generateClimax': (btn) => handleGenerateSection(btn, 'climax', 'Clímax', 'climax'),
    'generateConclusion': (btn) => generateConclusion(btn),
    'generateCta': (btn) => generateStrategicCta(btn),
    'suggestFinalStrategy': (btn) => suggestFinalStrategy(btn),
    'applySuggestion': (btn) => window.applySuggestion(btn),
    'applyAllSuggestions': (btn) => applyAllSuggestions(btn),
    'applyHookSuggestion': (btn) => applyHookSuggestion(btn),
    'insertViralSuggestion': (btn) => insertViralSuggestion(btn),
    'exportProject': () => exportProject(),
    'exportPdf': () => downloadPdf(),
    'exportTranscript': () => handleCopyAndDownloadTranscript(),
    'resetProject': async () => {
        const confirmed = await showConfirmationDialog("Começar um Novo Projeto?","Isso limpará todos os campos e o trabalho realizado. Esta ação não pode ser desfeita. Deseja continuar?");
        if (confirmed) { resetApplicationState(); }
    },
    'addDevelopmentChapter': (btn) => window.addDevelopmentChapter(btn),
    'select-idea': (btn) => {
        const ideaString = btn.dataset.idea;
        if (ideaString) {
            try {
                const ideaObject = JSON.parse(ideaString.replace(/"/g, '"'));
                document.getElementById('videoTheme').value = ideaObject.title || '';
                document.getElementById('videoDescription').value = ideaObject.videoDescription || ideaObject.angle || '';
                document.getElementById('targetAudience').value = ideaObject.targetAudience || '';
                window.showToast("Ideia selecionada! Estratégia pré-preenchida.");
                document.getElementById('inputTabsNav').scrollIntoView({ behavior: 'smooth', block: 'center' });
            } catch (e) { console.error("Falha ao processar dados da ideia:", e); }
        }
    },
    'select-enigma-idea': (btn) => {
        const ideaString = btn.dataset.idea;
        if (ideaString) {
            try {
                const ideaObject = JSON.parse(ideaString.replace(/"/g, '"'));
                document.getElementById('videoTheme').value = ideaObject.title || '';
                document.getElementById('videoDescription').value = ideaObject.synopsis || ideaObject.enigma || '';
                document.getElementById('centralQuestion').value = ideaObject.hook_question || '';
                window.showToast("Enigma selecionado! Estratégia pré-preenchida.");
                document.getElementById('inputTabsNav').scrollIntoView({ behavior: 'smooth', block: 'center' });
            } catch (e) { console.error("Falha ao processar dados da ideia de enigma:", e); }
        }
    },
    'regenerate': (btn) => window.regenerateSection(btn.dataset.sectionId),
    'copy': (btn) => {
        const content = btn.closest('.accordion-item')?.querySelector('.generated-content-wrapper');
        if (content) { window.copyTextToClipboard(content.textContent); window.showCopyFeedback(btn); }
    },
    'generate-prompts': (btn) => window.generatePromptsForSection(btn, btn.dataset.sectionId),
    'analyzeRetention': (btn) => window.analyzeSectionRetention(btn, btn.dataset.sectionId),
    'refineStyle': (btn) => window.refineSectionStyle(btn),
    'enrichWithData': (btn) => window.enrichWithData(btn),
    'suggestPerformance': (btn) => window.suggestPerformance(btn, btn.dataset.sectionId),
    'optimizeGroup': (btn) => {
        const suggestionText = btn.dataset.suggestionText;
        if (suggestionText) window.optimizeGroup(btn, suggestionText);
    },
    'deleteParagraphGroup': (btn) => {
        const suggestionText = btn.dataset.suggestionText;
        if (suggestionText) window.deleteParagraphGroup(btn, suggestionText);
    },
    'analyzeScript': (btn) => analyzeFullScript(btn),
    'analyzeHooks': (btn) => analyzeRetentionHooks(btn),
    'suggestViralElements': (btn) => suggestViralElements(btn)
};

    document.addEventListener('click', function(event) {
        // Lógica do Acordeão
        const accordionHeader = event.target.closest('.accordion-header');
        if (accordionHeader && !event.target.closest('.header-buttons')) {
            const body = accordionHeader.nextElementSibling;
            const arrow = accordionHeader.querySelector('.accordion-arrow');
            if (body && arrow) { body.classList.toggle('open'); arrow.classList.toggle('open'); }
        }

        // Lógica dos Botões de Ação
        const button = event.target.closest('button[data-action]');
        if (!button) return;

        const actionName = button.dataset.action;
        const action = actions[actionName];

        if (action) {
            event.preventDefault();
            action(button);
        }
    });

    const toneMenu = document.getElementById('tone-variation-menu');

    document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText.length > 10 && selection.anchorNode.parentElement.closest('.generated-content-wrapper')) {
            userSelectionRange = selection.getRangeAt(0).cloneRange();
            const rect = userSelectionRange.getBoundingClientRect();
            
            toneMenu.style.left = `${rect.left + window.scrollX}px`;
            toneMenu.style.top = `${rect.bottom + window.scrollY + 5}px`;
            toneMenu.classList.add('visible');
        } else {
            if (!toneMenu.contains(document.activeElement)) {
                 toneMenu.classList.remove('visible');
            }
        }
    });

    toneMenu.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-tone]');
        if (button) {
            const tone = button.dataset.tone;
            varyTone(tone);
        }
    });

    const strategicInputIds = ['videoTheme', 'videoDescription', 'videoDuration', 'speakingPace', 'visualPacing', 'narrativeGoal', 'narrativeStructure', 'narrativeTheme', 'narrativeTone', 'narrativeVoice', 'centralQuestion', 'emotionalArc', 'shockingEndingHook', 'imageDescriptionEngine', 'imageStyleSelect', 'researchData', 'emotionalHook'];
    
    strategicInputIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            const eventType = (element.tagName === 'SELECT' || element.tagName === 'TEXTAREA') ? 'change' : 'input';
            element.addEventListener(eventType, (e) => {
                if (!isSettingStrategy) {
                    resetGeneratedScriptContent(e.target.id);
                }
            });
        }
    });
});

</script>
</body>
</html>