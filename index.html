<!DOCTYPE html>
<html lang="pt-br">
<head>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🚀</text></svg>">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Roteiros Virais v3.7</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>

    <style>
    /* ================================================================= */
    /* =================== ARQUITETURA DE DESIGN (THEME) ================= */
    /* ================================================================= */
    :root {
        --primary: #6366f1;
        --primary-dark: #4f46e5;
        --secondary: #8FBC8F;
        --accent: #228B22;
        --success: #10b981;
        --danger: #ef4444;
        --dark-bg: #f8fafc;
        --dark-surface: #ffffff;
        --dark-border: #e2e8f0;
        --dark-text-header: #1e293b;
        --dark-text-body: #334155;
        --dark-text-muted: #64748b;
        --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        --transition: all 0.2s ease-in-out;
    }

    .dark {
        --primary: #818cf8;
        --primary-dark: #6366f1;
        --secondary: #3CB371;
        --accent: #006400;
        --dark-bg: #0f172a;
        --dark-surface: #1e293b;
        --dark-border: #334155;
        --dark-text-header: #f1f5f9;
        --dark-text-body: #cbd5e1;
        --dark-text-muted: #94a3b8;
    }

    /* ================================================================= */
    /* ======================= ESTILOS GLOBAIS ======================= */
    /* ================================================================= */
    body { 
        font-family: 'Inter', sans-serif; 
        background-color: var(--dark-bg); 
        color: var(--dark-text-body); 
        transition: var(--transition); 
    }
    .container { 
        max-width: 1024px; 
        margin: 0 auto; 
    }
    h1, h2, h3, h4, h5, h6 { 
        color: var(--dark-text-header); 
    }

    /* ================================================================= */
    /* ======================= COMPONENTES DA UI ======================= */
    /* ================================================================= */

    /* --- Cards e Seções --- */
    .card { 
        background-color: var(--dark-surface); 
        border: 1px solid var(--dark-border); 
        border-radius: 12px; 
        box-shadow: var(--shadow); 
        padding: 1.5rem; 
        transition: var(--transition); 
    }
    .section-title { 
        position: relative; 
        padding-bottom: 0.75rem; 
        margin-bottom: 1.5rem; 
        border-bottom: 1px solid var(--dark-border); 
    }
    .section-title h2 { 
        font-size: 1.25rem; 
        font-weight: 700; 
    }
    .section-title::after { 
        content: ''; 
        position: absolute; 
        bottom: -1px; 
        left: 0; 
        width: 70px; 
        height: 2px; 
        background: var(--primary); 
        transition: var(--transition); 
    }

    /* --- Botões --- */
    .btn { 
        display: inline-flex; 
        align-items: center; 
        justify-content: center; 
        gap: 0.5rem; 
        padding: 0.65rem 1.25rem; 
        border-radius: 8px; 
        font-weight: 600; 
        cursor: pointer; 
        transition: var(--transition); 
        border: none; 
        white-space: nowrap; 
    }
    .btn-primary { 
        background-color: var(--primary); 
        color: white; 
    }
    .btn-primary:hover { 
        background-color: var(--primary-dark); 
        transform: translateY(-2px); 
    }
    .btn-secondary { 
        background-color: var(--secondary); 
        color: white; 
    }
    .btn-secondary:hover { 
        background-color: #7c3aed; 
    }
    .dark .btn-secondary:hover { 
        background-color: #9333ea; 
    }
    .btn-small { 
        padding: 0.5rem 1rem; 
        font-size: 0.875rem; 
    }

    /* --- Formulários e Inputs --- */
    .input-group { 
        margin-bottom: 1rem; 
    }
    .input-group label { 
        display: block; 
        margin-bottom: 0.5rem; 
        font-weight: 600; 
        font-size: 0.875rem; 
        color: var(--dark-text-header); 
    }
    .input-group input, .input-group select, .input-group textarea { 
        width: 100%; 
        padding: 0.75rem; 
        border-radius: 8px; 
        border: 1px solid var(--dark-border); 
        background: var(--dark-surface); 
        transition: var(--transition); 
        color: var(--dark-text-body); 
    }
    .input-group input::placeholder, .input-group textarea::placeholder { 
        color: var(--dark-text-muted); 
        opacity: 1; 
    }
    .input-group input:focus, .input-group select:focus, .input-group textarea:focus { 
        outline: none; 
        border-color: var(--primary); 
        box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); 
    }

    /* --- Botões de Rádio Personalizados --- */
    .radio-label {
        display: inline-flex;
        align-items: center;
        cursor: pointer;
        padding: 0.75rem 1.25rem;
        border-radius: 8px;
        border: 2px solid var(--dark-border);
        background-color: var(--dark-surface);
        transition: var(--transition);
    }
    .radio-label:hover {
        border-color: var(--secondary);
    }
    .radio-label input[type="radio"] {
        display: none;
    }
    .radio-label input[type="radio"]:checked + span {
        color: var(--primary);
        font-weight: 600;
    }
    .radio-label:has(input:checked) {
        border-color: var(--primary);
        background-color: color-mix(in srgb, var(--primary) 10%, transparent);
    }
    .radio-label.opacity-50 {
        cursor: not-allowed;
        color: var(--dark-text-muted);
    }
    
    /* --- Abas (Tabs) --- */
    .tab-button { 
        padding: 0.5rem 0.25rem; 
        margin-bottom: 0.5rem; 
        border-bottom: 3px solid transparent; 
        color: var(--dark-text-muted); 
        font-weight: 500; 
        transition: var(--transition); 
        background: none; 
        border-radius: 0; 
    }
    .tab-button:hover { 
        color: var(--primary); 
    }
    .tab-active { 
        border-bottom-color: var(--primary); 
        color: var(--primary); 
        font-weight: 600; 
    }
    .tab-pane.hidden { 
        display: none; 
    }

    /* --- Acordeão --- */
    .accordion-item { 
        border-bottom: 1px solid var(--dark-border); 
    }
    .accordion-header { 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        padding: 1rem 1.5rem; 
        cursor: pointer; 
        transition: var(--transition); 
    }
    .accordion-header:hover { 
        background-color: color-mix(in srgb, var(--dark-surface) 95%, var(--dark-text-muted)); 
    }
    .header-title-group { 
        display: flex; 
        align-items: center; 
        gap: 0.75rem; 
        flex-grow: 1; 
    }
    .header-title-group h3 { 
        font-weight: 600; 
        font-size: 1.1rem; 
    }
    .header-title-group .text-xs { 
        color: var(--dark-text-muted); 
        font-size: 0.75rem; 
        white-space: nowrap; 
    }
    .header-actions-group { 
        display: flex; 
        align-items: center; 
        gap: 1rem; 
    }
    .header-buttons { 
        display: flex; 
        align-items: center; 
        gap: 0.75rem; 
    }
    .header-buttons button { 
        background: none; 
        border: none; 
        padding: 0.25rem; 
        color: var(--dark-text-muted); 
        cursor: pointer; 
        transition: var(--transition); 
    }
    .header-buttons button:hover { 
        color: var(--primary); 
    }
    .accordion-arrow { 
        transition: transform 0.3s; 
        transform-origin: center; 
    }
    .accordion-arrow.open { 
        transform: rotate(180deg); 
    }
    .accordion-body { 
        padding: 0 1.5rem 1.5rem 1.5rem; 
        display: none; 
    }
    .accordion-body.open { 
        display: block; 
    }
    .accordion-body > div > div { 
        padding-top: 1.5rem; 
        padding-bottom: 1.5rem; 
        border-top: 1px dashed var(--dark-border); 
    }
    .accordion-body > div > div:first-child { 
        border-top: none; 
        padding-top: 0; 
    }
    .accordion-body h5 { 
        font-size: 1rem; 
        font-weight: 700; 
        color: var(--dark-text-header); 
        margin-bottom: 0.25rem; 
    }
    .accordion-body p.text-xs { 
        font-size: 0.8rem; 
        color: var(--dark-text-muted); 
        margin-bottom: 1rem; 
    }

    /* --- Elementos de Feedback --- */
    .toast { 
        position: fixed; 
        bottom: 1.5rem; 
        right: 1.5rem; 
        background-color: var(--dark-surface); 
        color: var(--dark-text-header); 
        padding: 1rem 1.5rem; 
        border-radius: 8px; 
        box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1); 
        z-index: 1000; 
        opacity: 0; 
        transform: translateY(100%); 
        transition: all 0.4s cubic-bezier(0.21, 1.05, 0.51, 1.04); 
        border-left: 4px solid var(--primary); 
    }
    .toast.show { 
        opacity: 1; 
        transform: translateY(0); 
    }
    .loading-spinner { 
        width: 24px; 
        height: 24px; 
        border: 3px solid color-mix(in srgb, var(--primary) 20%, transparent); 
        border-top-color: var(--primary); 
        border-radius: 50%; 
        animation: spin 1s linear infinite; 
    }
  @keyframes fade-out-highlight {
  from {
    background-color: color-mix(in srgb, var(--primary) 25%, transparent) !important;
    outline: 2px solid var(--primary) !important;
  }
  to {
    background-color: transparent !important;
    outline: 2px solid transparent !important;
  }
}
    .progress-bar { 
        height: 8px; 
        background: var(--dark-border); 
        border-radius: 4px; 
        overflow: hidden; 
    }
    .progress-fill { 
        height: 100%; 
        background: var(--primary); 
        border-radius: 4px; 
        transition: width 0.3s ease; 
    }
    
    /* --- Popover da Estrutura Específica --- */
    .popover-bg {
        background-color: var(--dark-bg);
    }

    /* --- Ícone de Troca de Tema --- */
    .theme-toggle {
        background-color: transparent;
        border: none;
        padding: 0.5rem;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
    }
    .theme-toggle:hover {
        background-color: color-mix(in srgb, var(--dark-border) 50%, transparent);
    }

    /* ================================================================= */
    /* ================== ESTILOS DE CONTEÚDO GERADO =================== */
    /* ================================================================= */
    .generated-content-wrapper, .generated-output-box, .emotional-map-item, .prompt-item { 
        background-color: color-mix(in srgb, var(--dark-bg) 50%, var(--dark-surface)); 
        border-left: 4px solid var(--primary); 
        padding: 1rem 1.5rem; 
        border-radius: 8px; 
        line-height: 1.6; 
    }
    .prompt-item { 
        border-left-color: var(--secondary); 
    }
    .generated-content-wrapper { 
        margin-bottom: 1.5rem; 
    }
    .generated-output-box .output-subtitle { 
        font-size: 1rem; 
        font-weight: 700; 
        color: var(--dark-text-header); 
        margin-bottom: 0.75rem; 
        padding-bottom: 0.5rem; 
        border-bottom: 1px dashed var(--dark-border); 
    }
    .generated-output-box .output-content-block { 
        margin-bottom: 1.5rem; 
    }
    .generated-output-box .thumbnail-idea { 
        margin-bottom: 1rem; 
    }
    .generated-output-box .thumbnail-idea h4 { 
        font-weight: 600; 
        font-size: 0.9rem; 
    }
    .generated-output-box .thumbnail-idea p { 
        font-size: 0.85rem; 
        color: var(--dark-text-muted); 
    }
    .soundtrack-list { 
        list-style-type: disc; 
        padding-left: 1.5rem; 
    }
    .paragraph-preview { 
        font-style: italic; 
        color: var(--dark-text-muted); 
        margin-bottom: 0.75rem; 
        font-size: 0.9rem; 
        border-bottom: 1px dashed var(--dark-border); 
        padding-bottom: 0.75rem; 
    }
    .analysis-tags, .prompt-header { 
        display: flex; 
        flex-wrap: wrap; 
        gap: 0.5rem; 
    }
    .prompt-header { 
        margin-bottom: 0.75rem; 
        padding-bottom: 0.75rem; 
        border-bottom: 1px dashed var(--dark-border); 
    }
    .tag { 
        display: inline-flex; 
        align-items: center; 
        padding: 0.25rem 0.75rem; 
        border-radius: 9999px; 
        font-size: 0.75rem; 
        font-weight: 600; 
    }
    .tag-emotion { 
        background-color: color-mix(in srgb, var(--primary) 20%, transparent); 
        color: var(--primary); 
    }
    .tag-pace { 
        background-color: color-mix(in srgb, var(--secondary) 20%, transparent); 
        color: var(--secondary); 
    }
    .tag-scene { 
        background-color: color-mix(in srgb, var(--accent) 20%, transparent); 
        color: var(--accent); 
    }
    .tag-time { 
        background-color: color-mix(in srgb, var(--dark-text-muted) 20%, transparent); 
        color: var(--dark-text-muted); 
    }

    /* ================================================================= */
    /* =================== MÓDULOS DE ANÁLISE E AJUDA ================== */
    /* ================================================================= */

    /* --- Análise de Retenção --- */
    .retention-paragraph-live { 
        position: relative; 
        padding: 0.5rem; 
        border-radius: 6px; 
        transition: background-color 0.3s; 
        cursor: default; 
    }
    .retention-green { 
        background-color: color-mix(in srgb, var(--success) 10%, transparent); 
    }
    .retention-yellow { 
        background-color: color-mix(in srgb, #f59e0b 15%, transparent); 
    }
    .retention-red { 
        background-color: color-mix(in srgb, var(--danger) 15%, transparent); 
    }
    .retention-tooltip { 
        position: absolute; 
        bottom: 100%; 
        left: 0; 
        transform: translateY(-10px); 
        background-color: var(--dark-surface); 
        color: var(--dark-text-body); 
        padding: 0.75rem; 
        border-radius: 8px; 
        box-shadow: 0 4px 12px rgba(0,0,0,0.2); 
        width: 90%; 
        z-index: 10; 
        font-size: 0.8rem; 
        border: 1px solid var(--dark-border); 
        opacity: 0; 
        visibility: hidden; 
        transition: opacity 0.3s, transform 0.3s; 
    }
    .retention-tooltip .optimize-btn { 
        display: block; 
        width: 100%; 
        margin-top: 0.75rem; 
        padding: 0.5rem; 
        border: none; 
        background-color: var(--primary); 
        color: white; 
        font-weight: 600; 
        border-radius: 6px; 
        cursor: pointer; 
        transition: var(--transition); 
    }
    .retention-tooltip .optimize-btn:hover { 
        background-color: var(--primary-dark); 
    }
    .retention-paragraph-live:hover .retention-tooltip { 
        opacity: 1; 
        visibility: visible; 
        transform: translateY(-5px); 
    }
    .highlight-group { 
        outline: 2px solid var(--primary); 
        outline-offset: 2px; 
        box-shadow: 0 0 15px color-mix(in srgb, var(--primary) 30%, transparent); 
    }

    /* --- Tooltips de Ajuda dos Ícones (i) --- */
    .help-icon {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: var(--dark-border);
        color: var(--dark-text-muted);
        font-size: 11px;
        font-weight: 700;
        cursor: help;
        margin-left: 8px;
        transition: var(--transition);
    }
    .help-icon:hover {
        background-color: var(--primary);
        color: white;
    }
    .help-icon .tooltip-text {
        visibility: hidden;
        opacity: 0;
        width: 300px;
        background-color: var(--dark-bg);
        color: var(--dark-text-header);
        text-align: left;
        border-radius: 8px;
        padding: 1rem;
        position: absolute;
        z-index: 1001;
        bottom: 150%;
        left: 50%;
        transform: translateX(-50%);
        box-shadow: var(--shadow);
        border: 1px solid var(--dark-border);
        transition: opacity 0.3s;
        pointer-events: none;
        font-size: 0.875rem;
        font-weight: 500;
        line-height: 1.6;
    }
    .help-icon .tooltip-text::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: var(--dark-bg) transparent transparent transparent;
    }
    .help-icon:hover .tooltip-text {
        visibility: visible;
        opacity: 1;
    }
    .help-icon .tooltip-text strong {
        font-weight: 700;
        color: var(--primary);
    }

    /* ========================================================== */
/*     PASSO 1: ADICIONE ESTE NOVO BLOCO AO SEU CSS           */
/* ========================================================== */

#tone-variation-menu {
    position: absolute;
    /* <<< MUDANÇA DE COR AQUI >>> */
    background-color: var(--dark-bg); /* Cor de fundo principal, mais escura */
    border: 1px solid var(--dark-border);
    border-radius: 8px;
    box-shadow: var(--shadow);
    padding: 0.5rem;
    z-index: 1002;
    display: flex;
    gap: 0.5rem;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, transform 0.2s;
    transform: translateY(10px);
}

#tone-variation-menu.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

#tone-variation-menu button {
    background-color: transparent;
    border: none;
    color: var(--primary);
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    border-radius: 6px;
    font-weight: 600;
    white-space: nowrap;
}

#tone-variation-menu button:hover {
    background-color: var(--dark-border);
    color: var(--dark-text-header);

</style>



</head>
<body class="bg-gray-50 dark:bg-gray-900">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow-sm">
            <div class="container mx-auto px-4 py-4 flex justify-between items-center">
                <h1 class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">
                    <i class="fas fa-video mr-2"></i>Gerador de Roteiros Virais v3.7
                </h1>
                <div class="flex items-center space-x-4">
                    <button id="darkModeToggle" class="theme-toggle">
                        <i id="moonIcon" class="fas fa-moon text-gray-700 dark:text-gray-300"></i>
                        <i id="sunIcon" class="fas fa-sun text-gray-700 dark:text-gray-300 hidden"></i>
                    </button>
                </div>
            </div>
        </header>

        <!-- Progress Bar -->
        <div class="container mx-auto px-4 py-4">
            <div class="mb-6">
                <div class="flex justify-between text-sm mb-1">
                    <span>Progresso do Projeto</span>
                    <span id="progressText">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <main class="container mx-auto px-4 pb-20">
            <!-- Estratégia Section -->


<!-- SEÇÃO 0: INSPIRAÇÃO (BRAINSTORM) -->
<section id="inspirationSection" class="mb-12">
    <div class="text-center mb-8">
        <h2 class="text-2xl font-bold mb-2">Precisa de Inspiração?</h2>
        <p class="text-gray-600 dark:text-gray-400">Comece por aqui. Descreva o nicho ou os temas gerais do seu canal e deixe a IA sugerir vídeos com alto potencial.</p>
    </div>
    <div class="card">
        <div class="input-group">
            <label for="nicheDescription">Nicho do Canal ou Temas de Interesse:</label>
            <textarea id="nicheDescription" rows="4" placeholder="Ex: Arqueologia Bíblica e mistérios não resolvidos; Finanças pessoais para jovens cristãos; Análise de sermões e teologia prática..."></textarea>
        </div>
<div class="text-center mt-6 flex flex-wrap justify-center gap-4">
    <!-- Botão Antigo (Generalista) -->
    <button id="generateIdeasBtn" data-action="generateIdeas" class="btn btn-primary">
        <i class="fas fa-lightbulb mr-2"></i>Gerar Ideias (Geral)
    </button>
    <!-- Nosso Novo Botão (Especialista) -->
    <button id="unravelEnigmasBtn" data-action="unravelEnigmas" class="btn btn-secondary">
        <i class="fas fa-scroll mr-2"></i>Desvendar Enigmas (Bíblico)
    </button>
</div>
        
        <!-- Container para a saída das ideias -->
        <div id="ideasOutput" class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- As ideias geradas pela IA aparecerão aqui -->
        </div>
    </div>
</section>

<!-- Linha divisória -->
<div class="relative flex py-5 items-center">
    <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
    <span class="flex-shrink mx-4 text-gray-400 dark:text-gray-500 font-semibold">OU COMECE DIRETAMENTE AQUI</span>
    <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
</div>


<!-- ================================================================= -->
<!-- SUBSTITUA SUA SEÇÃO 1 INTEIRA POR ESTE BLOCO CORRIGIDO -->
<!-- ================================================================= -->

<!-- SEÇÃO 1: DEFINIR ESTRATÉGIA -->
<section class="mb-10">
    <div class="section-title">
        <h2 class="text-xl font-bold">1. Definir Estratégia</h2>
    </div>
    
    <!-- A navegação das abas (continua a mesma) -->
    <div class="border-b border-gray-200 dark:border-gray-700 mb-6">
        <nav id="inputTabsNav" class="-mb-px flex flex-wrap md:flex-nowrap space-x-6" aria-label="Tabs">
            <button data-tab="input-tab-basico" class="tab-button tab-active">
                <i class="fas fa-info-circle mr-2"></i> Básico
            </button>
            <button data-tab="input-tab-estrategia" class="tab-button">
                <i class="fas fa-lightbulb mr-2"></i> Estratégia Narrativa
            </button>
            <button data-tab="input-tab-tecnicos" class="tab-button">
                <i class="fas fa-sliders-h mr-2"></i> Detalhes Técnicos
            </button>
        </nav>
    </div>
    
    <!-- O conteúdo das abas (AGORA CORRIGIDO) -->
    <div id="inputTabContent" class="card">
        
        <!-- Aba 1: Básico -->

<div id="input-tab-basico" class="tab-pane active-pane">
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="input-group"><label for="channelName">Nome do Canal:</label><input type="text" id="channelName" value="The Biblical Unveiling"></div>
        <div class="input-group"><label for="videoTheme">Tema do Vídeo:</label><input type="text" id="videoTheme" placeholder="Ex: A Arca da Aliança Foi Encontrada?"></div>
        <div class="input-group"><label for="languageSelect">Idioma do Roteiro:</label><select id="languageSelect"><option value="pt-br">Português (Brasil)</option><option value="en" selected>English</option></select></div>
        
        <!-- Duração e Ritmo agora ficam lado a lado -->
        <div class="input-group">
            <label for="videoDuration">Duração Desejada:</label>
            <select id="videoDuration">
                <option value="">-- Selecione --</option>
                <option value="short">Curto (~1-3 min)</option>
                <option value="medium">Médio (~4-7 min)</option>
                <option value="long">Longo (~8-12 min)</option>
            </select>
        </div>

        <div class="input-group">
    <label for="visualPacing">Ritmo Visual (Cenas):</label>
    <select id="visualPacing">
        <option value="" selected>-- Selecione --</option> <!-- Adicionado 'selected' aqui -->
        <option value="dinamico">Dinâmico (3-8s)</option> <!-- Removido 'selected' daqui -->
        <option value="normal">Normal (8-15s)</option>
        <option value="contemplativo">Contemplativo (15-25s)</option>
    </select>
</div>

        <div class="input-group md:col-span-2"><label for="videoDescription">Descrição do Vídeo (para inspiração):</label><textarea id="videoDescription" rows="4" placeholder="Cole uma breve descrição do vídeo aqui..."></textarea></div>
    </div>
</div>


        <!-- Aba 2: Estratégia Narrativa -->
<!-- Aba 2: Estratégia Narrativa (COM ORDEM REFINADA) -->
<div id="input-tab-estrategia" class="tab-pane hidden">
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">

        <!-- Bloco 1: O Que e Para Quem -->
        <div class="input-group md:col-span-2"><label for="targetAudience">Público-Alvo:</label><input type="text" id="targetAudience" placeholder="Quem você quer que assista? Descreva seu espectador ideal."></div>
        <div class="input-group md:col-span-2"><label for="narrativeTheme">3. Tema Principal:</label><input type="text" id="narrativeTheme" placeholder="Qual é a 'grande ideia'? A única mensagem que seu público deve lembrar?"></div>
        <div class="input-group md:col-span-2"><label for="centralQuestion">Pergunta Central (Opcional):</label><textarea id="centralQuestion" rows="2" placeholder="Qual mistério ou 'coceira mental' você vai criar e prometer resolver?"></textarea></div>

        <!-- Bloco 2: A Estrutura e a Alma -->
        <div class="input-group"><label for="narrativeGoal">1. Objetivo da Narrativa:</label><select id="narrativeGoal"><option value="storytelling">Storytelling</option><option value="storyselling">Storyselling</option></select></div>
        <div class="relative group">
            <div class="input-group">
                <div class="flex items-center gap-2 mb-2"><label for="narrativeStructure">2. Estrutura Específica:</label></div>
                <select id="narrativeStructure"></select>
            </div>
            <div id="structurePopover" class="card popover-bg absolute bottom-full left-0 mb-2 w-[400px] opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-300 z-20 pointer-events-none group-hover:pointer-events-auto">
                <h4 id="popoverTitle" class="font-bold text-lg text-indigo-400 mb-2"></h4>
                <p id="popoverDescription" class="text-sm leading-relaxed"></p>
            </div>
        </div>
        <div class="input-group md:col-span-2"><label for="emotionalHook">História Pessoal / Gancho Emocional (Opcional):
    <span class="help-icon">i
        <span class="tooltip-text">
            <strong>Dê uma alma para sua história.</strong> Este é o 'fio condutor' humano. A IA usará esta pequena história para conectar os grandes fatos a uma experiência pessoal, tornando o roteiro muito mais impactante.
        </span>
    </span>
</label><textarea id="emotionalHook" rows="3" placeholder="Qual rosto humano dará alma à sua história? Ex: a jornada de um indivíduo, uma memória pessoal, um arquétipo (o azarão, o mentor)..."></textarea></div>

        <!-- Bloco 3: O Tom e a Jornada -->
        <div class="input-group"><label for="narrativeTone">4. Tom da Narração:</label><select id="narrativeTone"><option value="inspirador" selected>Inspirador</option><option value="serio">Sério</option><option value="emocional">Emocional</option></select></div>
        <div class="input-group"><label for="narrativeVoice">5. Voz do Narrador:</label><input type="text" id="narrativeVoice" placeholder="Se seu canal fosse uma pessoa, como ela falaria? Confiante? Engraçada? Misteriosa?"></div>
        <div class="input-group md:col-span-2"><label for="emotionalArc">Arco Emocional Desejado (Opcional):</label><textarea id="emotionalArc" rows="2" placeholder="Ex: Curiosidade -> Tensão -> Surpresa"></textarea></div>
        <div class="input-group md:col-span-2"><label for="shockingEndingHook">O Desfecho Chocante (Hook Opcional):
    <span class="help-icon">i
        <span class="tooltip-text">
            <strong>A técnica do 'loop aberto' reverso.</strong> Coloque a frase final e mais chocante da sua história aqui. A IA usará esta frase como a PRIMEIRA linha do vídeo, criando um mistério instantâneo que prende o espectador até o final.
        </span>
    </span>
</label><input type="text" id="shockingEndingHook" placeholder="Ex: ...e foi por isso que a Arca nunca deveria ser encontrada."></div>

    </div>
</div>

        <!-- Aba 3: Detalhes Técnicos -->
<div id="input-tab-tecnicos" class="tab-pane hidden"> <!-- A classe 'hidden' é importante -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">

        <div class="input-group"><label for="languageStyle">Estilo de Linguagem:</label><select id="languageStyle"><option value="inspirador" selected>Inspirador</option><option value="formal">Formal</option></select></div>
        <div class="input-group"><label for="videoObjective">Objetivo do Vídeo:</label><select id="videoObjective"><option value="informar" selected>Informar</option><option value="emocionar">Emocionar</option></select></div>
        <div class="input-group"><label for="speakingPace">Ritmo de Fala:</label><select id="speakingPace"><option value="moderate" selected>Moderado</option><option value="slow">Lento</option><option value="fast">Rápido</option></select></div>

<div class="input-group md:col-span-2">

    <label for="researchData">Fontes e Dados de Pesquisa (Opcional):
    <span class="help-icon">i
        <span class="tooltip-text">
            <strong>Aumente a credibilidade.</strong> Cole aqui nomes, datas, estatísticas, ou citações. A IA irá tecer essas informações na narrativa.

Ex: 'Fonte: Estudo de Harvard; Dr. João da Silva, especialista...'
        </span>
    </span>
</label>

    <textarea id="researchData" rows="4" placeholder="Para aumentar a credibilidade, cole aqui dados, fontes, nomes e links que a IA deve citar e contextualizar no roteiro. Ex: Fonte: Atlas da Violência 2023; Maria da Silva, coordenadora do Instituto Odara..."></textarea>
</div>

        <div class="input-group md:col-span-2"><label for="imageDescriptionEngine">Motor de Descrição de Imagem:</label><textarea id="imageDescriptionEngine" rows="2" placeholder="Ex: 'fotografias reais', 'close-up emocional'"></textarea></div>
        <div class="input-group md:col-span-2"><label for="imageStyleSelect">Motor de Qualidade de Imagem:</label><select id="imageStyleSelect"><option value="cinematic" selected>Cinematográfico</option><option value="custom">Personalizado</option><option value="none">Nenhum</option></select></div>
        <!-- O campo que estava faltando, agora na posição correta -->
        <div id="customImageStyleContainer" class="input-group md:col-span-2" style="display: none;">
            <label for="customImageStyle">Estilo de Imagem Personalizado:</label>
            <textarea id="customImageStyle" rows="3" placeholder="Descreva o seu estilo de imagem aqui... Ex: 'estilo de arte de Van Gogh', 'preto e branco com alto contraste'..."></textarea>
        </div>
    </div>
</div>
    
    <!-- O botão final (continua o mesmo) -->
    <div class="mt-6 text-center">
        <div class="mt-6 flex flex-col sm:flex-row items-center justify-center gap-4">
    <!-- Botão Opcional para ajuda da IA -->
    <button id="suggestStrategyBtn" data-action="suggestStrategy" class="btn btn-secondary w-full sm:w-auto">
        <i class="fas fa-magic mr-2"></i> Sugerir Estratégia com IA
    </button>
    <!-- Botão Principal para avançar -->
    <button id="startCraftingBtn" data-action="startCrafting" class="btn btn-primary w-full sm:w-auto">
        <i class="fas fa-arrow-right mr-2"></i> Iniciar Criação do Roteiro
    </button>
</div>


    </div>
</section>

<!-- PAINEL DO PROJETO (inicialmente escondido) -->
<div id="projectDashboard" class="hidden mt-12">

    <!-- SEÇÃO 2: CRIAR ROTEIRO -->
    <section class="mb-10">
        <div class="section-title"><h2 class="text-xl font-bold">2. Criar Roteiro</h2></div>
        
        <!-- Card do Esboço Estratégico -->
        <div id="strategicOutlineCard" class="card card-placeholder mb-6"> <!-- CLASSE ADICIONADA AQUI -->
            <div class="flex justify-between items-center mb-3">
                <h3 class="font-semibold text-lg">Esboço Estratégico</h3>
                <button id="generateOutlineBtn" data-action="generateOutline" class="btn btn-secondary btn-small">Criar Esboço</button>
            </div>
            <div id="outlineContent"><div class="asset-card-placeholder">Clique para gerar o esboço.</div></div>
        </div>
        
        <!-- Container onde os placeholders do roteiro (Introdução, etc.) serão injetados -->
        <div id="scriptSectionsContainer" class="space-y-4"></div>
    </section>

    <!-- SEÇÃO 3: RECURSOS E METADADOS -->
    <section>
        <div class="section-title"><h2 class="text-xl font-bold">3. Recursos e Metadados</h2></div>
        
        <!-- Mapa Emocional -->
        <div class="card card-placeholder mb-6"> <!-- CLASSE ADICIONADA AQUI -->
             <div class="flex justify-between items-center mb-3">
                <h3 class="font-semibold text-lg">Mapa Emocional</h3>
                <button id="mapEmotionsBtn" data-action="mapEmotions" class="btn btn-secondary btn-small">Mapear</button>
            </div>
            <div id="emotionalMapContent"><div class="asset-card-placeholder">Gere o roteiro completo para habilitar.</div></div>
        </div>

        <!-- Grid para os outros recursos -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            
            <!-- Títulos & Thumbnails -->
            <div class="card card-placeholder"> <!-- CLASSE ADICIONADA AQUI -->
                <div class="flex justify-between items-center mb-3">
                    <h3 class="font-semibold text-lg">Títulos & Thumbnails</h3>
                    <button id="generateTitlesAndThumbnailsBtn" data-action="generateTitlesAndThumbnails" class="btn btn-secondary btn-small">Gerar</button>
                </div>
                <div id="titlesThumbnailsContent"><div class="asset-card-placeholder">Gere o roteiro para habilitar.</div></div>
            </div>

            <!-- Descrição & Hashtags -->
            <div class="card card-placeholder"> <!-- CLASSE ADICIONADA AQUI -->
                <div class="flex justify-between items-center mb-3">
                    <h3 class="font-semibold text-lg">Descrição & Hashtags</h3>
                    <button id="generateDescriptionBtn" data-action="generateDescription" class="btn btn-secondary btn-small">Gerar</button>
                </div>
                <div id="videoDescriptionContent"><div class="asset-card-placeholder">Gere o roteiro para habilitar.</div></div>
            </div>

            <!-- Trilha Sonora -->
            <div class="card card-placeholder md:col-span-2"> <!-- CLASSE ADICIONADA AQUI -->
                <div class="flex justify-between items-center mb-3">
                    <h3 class="font-semibold text-lg">Trilha Sonora</h3>
                    <button id="generateSoundtrackBtn" data-action="generateSoundtrack" class="btn btn-secondary btn-small">Gerar</button>
                </div>
                <div id="soundtrackContent"><div class="asset-card-placeholder">Gere o roteiro para habilitar.</div></div>
            </div>
        </div>


            <!-- MÓDULO DE ESTRATÉGIA DA CONCLUSÃO (inicialmente escondido) -->
<!-- ========================================================== -->
<!--     PASSO 1: SUBSTITUA O SEU MÓDULO DE CONCLUSÃO POR ESTE      -->
<!-- ========================================================== -->

<div id="conclusionStrategyModule" class="card mb-6 hidden">
    <div class="text-center mb-4">
        <h3 class="text-lg font-bold">Qual é o objetivo final do seu vídeo?</h3>
        <!-- <<< NOSSO NOVO BOTÃO DE AJUDA AQUI >>> -->
        <button id="suggestFinalStrategyBtn" data-action="suggestFinalStrategy" class="btn btn-secondary btn-small mt-2">
            <i class="fas fa-magic mr-2"></i> Sugerir Estratégia Final
        </button>
    </div>
    <div class="flex justify-center flex-wrap gap-4 mb-6">
        <label class="radio-label">
            <input type="radio" name="conclusionType" value="lesson" checked>
            <span><i class="fas fa-graduation-cap mr-2"></i>Deixar uma Lição / Reflexão</span>
        </label>
        <label class="radio-label">
            <input type="radio" name="conclusionType" value="answer">
            <span><i class="fas fa-question-circle mr-2"></i>Responder uma Pergunta Central</span>
        </label>
        <label class="radio-label">
            <input type="radio" name="conclusionType" value="cliffhanger">
            <span><i class="fas fa-bolt mr-2"></i>Criar um Gancho / Mistério Contínuo</span>
        </label>
    </div>
    <div id="conclusionInputContainer" class="input-group">
        <label for="conclusionSpecifics">Detalhes para a Conclusão:</label>
        <textarea id="conclusionSpecifics" rows="3" placeholder="Qual sentimento ou ideia final você quer deixar com o espectador? Esperança? Indignação? Uma nova perspectiva?"></textarea>
    </div>
    <div class="input-group mt-4">
        <label for="ctaSpecifics">Detalhes para o Call to Action (CTA) Específico (Opcional):</label>
        <textarea id="ctaSpecifics" rows="2" placeholder="Qual ação específica você quer que o espectador tome? Ex: Visitar um site, apoiar uma causa, comprar um produto..."></textarea>
    </div>
    <div class="text-center mt-6">
        <button id="generateConclusionBtn" data-action="generateConclusion" class="btn btn-primary">
            <i class="fas fa-pen-fancy mr-2"></i>Gerar Conclusão
        </button>
        <button id="generateCtaBtn" data-action="generateCta" class="btn btn-primary hidden">
            <i class="fas fa-bullhorn mr-2"></i>Gerar CTA Estratégico
        </button>
    </div>
</div>


    </section>



    <!-- SEÇÃO 5: ANÁLISE DE ROTEIRO COMPLETO -->
<section id="scriptAnalysisSection" class="mt-10 hidden">
    <div class="section-title">
        <h2 class="text-xl font-bold">5. Análise de Roteiro (Beta)</h2>
    </div>
    <div class="card text-center">
        <p class="mb-4 text-gray-600 dark:text-gray-400">Pronto para receber um feedback de nível profissional? Nossa IA analisará seu roteiro completo em busca de pontos fortes e oportunidades de melhoria.</p>
        <button id="analyzeScriptBtn" data-action="analyzeScript" class="btn btn-primary">
            <i class="fas fa-search-plus mr-2"></i> Analisar Roteiro Completo
        </button>
        <!-- O relatório da análise será injetado aqui -->
        <div id="analysisReportContainer" class="mt-6 text-left"></div>
    </div>
</section>



<!-- ========================================================== -->
<!--     NOVA SEÇÃO 4: GERENCIAMENTO DO PROJETO (EXPORTAR/IMPORTAR)     -->
<!-- ========================================================== -->
<section class="mt-10">
    <div class="section-title">
        <h2 class="text-xl font-bold">4. Gerenciamento do Projeto</h2>
    </div>
    <div class="card">
        <div class="flex flex-wrap items-center justify-center gap-4">
            <!-- Botão para Importar Projeto -->
            <label for="importFileInput" class="btn btn-secondary cursor-pointer">
                <i class="fas fa-upload mr-2"></i> Importar Projeto
            </label>
            <input type="file" id="importFileInput" class="hidden" accept=".json">

            <!-- Botão para Exportar Projeto -->
            <button id="exportProjectBtn" data-action="exportProject" class="btn btn-secondary">
                <i class="fas fa-download mr-2"></i> Exportar Projeto
            </button>

            <!-- >>> NOSSO NOVO BOTÃO AQUI <<< -->
            <button id="exportPdfBtn" data-action="exportPdf" class="btn btn-secondary">
            <i class="fas fa-file-pdf mr-2"></i> Exportar PDF
            </button>

            <!-- >>> Exportar Transcrição <<< -->
            <button id="exportTranscriptBtn" data-action="exportTranscript" class="btn btn-secondary">
            <i class="fas fa-file-alt mr-2"></i> Exportar Transcrição (.rtf)
            </button>
            
            <!-- Botão para Resetar -->
            <button id="resetProjectBtn" data-action="resetProject" class="btn bg-red-600 hover:bg-red-700 text-white">
                <i class="fas fa-sync-alt mr-2"></i> Novo Projeto (Resetar)
            </button>
        </div>
    </div>
</section>


</div>
        </main>


        <div id="tone-variation-menu" class="">
        <button data-tone="emotion">Mais Emoção</button>
        <button data-tone="impact">Mais Urgência</button>
        <button data-tone="clarity">Mais Clareza</button>
        <button data-tone="humor">Mais Humor</button>
        </div>

        <!-- Floating Action Bar -->
        <div class="floating-action-bar">
            <button class="theme-toggle bg-indigo-500 text-white">
                <i class="fas fa-save"></i>
            </button>
        </div>

        <!-- Toast Notification -->
        <div id="toast" class="toast">
            <span id="toastMessage">Mensagem de notificação</span>
        </div>
    </div>

    <!-- Confirmation Dialog Overlay -->
        <div id="confirmationDialogOverlay" style="display: none; position: fixed; inset: 0; background-color: rgba(0,0,0,0.7); z-index: 2000; align-items: center; justify-content: center;">
            <div class="card max-w-sm w-full animate-fade-in">
                <h3 id="confirmationTitle" class="text-xl font-bold mb-4">Título da Confirmação</h3>
                <p id="confirmationMessage" class="mb-6">Deseja limpar o trabalho já realziado?</p>
                <div class="flex justify-end gap-4">
                    <button id="confirmBtnNo" class="btn btn-secondary">Não</button>
                    <button id="confirmBtnYes" class="btn btn-primary">Sim</button>
                </div>
            </div>
        </div>

<!-- ========================================================== -->
<!--     MODAL ATUALIZADO COM ÁREA PARA SUGESTÕES         -->
<!-- ========================================================== -->
<div id="inputDialogOverlay" style="display: none; position: fixed; inset: 0; background-color: rgba(0,0,0,0.7); z-index: 2000; align-items: center; justify-content: center;">
    <div class="card max-w-md w-full animate-fade-in">
        <h3 id="inputDialogTitle" class="text-xl font-bold mb-4">Título do Diálogo</h3>
        <p id="inputDialogMessage" class="text-sm text-gray-500 dark:text-gray-400 mb-4">Mensagem de ajuda.</p>
        
        <!-- Container para as sugestões da IA -->
        <div id="inputDialogSuggestions" class="space-y-2 mb-4">
            <!-- As sugestões (botões) serão injetadas aqui pelo JavaScript -->
        </div>

        <!-- Divisor opcional -->
        <div class="relative flex py-2 items-center">
            <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
            <span class="flex-shrink mx-4 text-xs text-gray-400">OU</span>
            <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
        </div>
        
        <div class="input-group mt-2">
            <label id="inputDialogLabel" for="inputDialogField">Label do Campo</label>
            <textarea id="inputDialogField" rows="2" placeholder="Placeholder..." class="!text-[var(--dark-text-body)]"></textarea>
        </div>

        <div class="flex justify-end gap-4 mt-6">
            <button id="inputBtnCancel" class="btn btn-secondary">Cancelar</button>
            <button id="inputBtnConfirm" class="btn btn-primary">Usar Tema Personalizado</button>
        </div>
    </div>
</div>


    <script type="module">

        // ==========================================================
        // ==================== SETUP INICIAL =======================
        // ==========================================================
        // Variáveis de estado globais
        let generatedTitlesAndThumbnails = null;
        let allImagePrompts = {}; 
        let strategicOutline = null;
    let projectState = {
    intro: false,
    development: false,
    climax: false,
    conclusion: false,
    cta: false
};
        let elements = {};
        let buttons = {};
        let totalScriptSeconds = 0;
        let promptPaginationState = {};
        let isSettingStrategy = false; // <-- NOSSO NOVO SINALIZADOR
        let userSelectionRange = null; // <<< ADICIONE ESTA NOVA LINHA
    
        // Bloco de estilo cinematográfico para prompts de imagem
        const CINEMATIC_STYLE_BLOCK = `
Ultra-realistic, high-resolution photographic image. Captured with natural lighting and cinematic composition. Rich textures and fine surface details — visible skin pores, fabric fibers, weathered materials, realistic reflections, and organic imperfections. Sharp focus with subtle depth of field. True-to-life colors with refined tonal range. Every element should look authentic, physical, and believable — as if taken with a high-end DSLR camera. No exaggerated features, no artificial smoothness — only pure, grounded realism.`;
        // Labels para descrição de imagem em diferentes idiomas
        const imageDescriptionLabels = { 'pt-br': 'Descrição da Imagem:', 'pt-pt': 'Descrição da Imagem:', 'en': 'Image Description:' };

// ==========================================================
        // NOVO: MAPA DE CONTAGEM DE PALAVRAS PARA CONTROLAR DURAÇÃO
        // ==========================================================
        const wordCountMap = {
            // ~2.5 min @ 150 WPM = ~375 palavras
            'short': {
                intro: 60,
                development: 190,
                climax: 75,
                conclusion: 50
            },
            // ~5.5 min @ 150 WPM = ~825 palavras
            'medium': {
                intro: 120,
                development: 420,
                climax: 165,
                conclusion: 120
            },
            // ~10 min @ 150 WPM = ~1500 palavras
            'long': {
                intro: 225,
                development: 750,
                climax: 300,
                conclusion: 225
            },
            // ~16 min @ 150 WPM = ~2400 palavras
            'extra-long': {
                intro: 360,
                development: 1200,
                climax: 480,
                conclusion: 360
            },
            // ~30 min @ 150 WPM = ~4500 palavras
            'documentary': {
                intro: 450,
                development: 2700,
                climax: 900,
                conclusion: 450
            }
        };


        // ==========================================================
        // ================== FUNÇÕES DE UTILIDADE ==================
        // ==========================================================
        /**
         * Exibe uma notificação toast na parte inferior da tela.
         * @param {string} message - A mensagem a ser exibida.
         */
        window.showToast = (message) => {
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');
    if (!toast || !toastMessage) return;
    toastMessage.textContent = message;
    toast.classList.add('show');
    setTimeout(() => { toast.classList.remove('show'); }, 8000);
};


// =========================================================================
        // PASSO 2: ADICIONE ESTA NOVA FUNÇÃO INTELIGENTE AO SEU SCRIPT
        // =========================================================================
        window.optimizeGroup = async (button, suggestionText) => {
            const safeSelector = suggestionText.replace(/"/g, '\\"');
            const paragraphsToOptimize = document.querySelectorAll(`[data-suggestion-group="${safeSelector}"]`);

            if (paragraphsToOptimize.length === 0) {
                window.showToast("Erro: parágrafos para otimizar não encontrados.");
                return;
            }

            const originalButtonText = button.innerHTML;
            button.innerHTML = '<div class="loading-spinner" style="width:16px; height:16px; border-width: 2px; margin: auto;"></div>';
            button.disabled = true;

            try {
                const originalBlock = Array.from(paragraphsToOptimize).map(p => p.textContent.trim()).join('\n\n');
                const prompt = `Você é um Roteirista especialista em reescrita. Sua tarefa é pegar um bloco de parágrafos e reescrevê-lo para corrigir um problema específico, mantendo a mensagem central.
                
                **PROBLEMA A SER CORRIGIDO (Sugestão):** "${suggestionText}"
                **BLOCO DE TEXTO ORIGINAL:**
                ---
                ${originalBlock}
                ---

                **REGRAS:**
                1. Reescreva o bloco de texto inteiro para que ele flua melhor e resolva o problema apontado na sugestão.
                2. Você pode juntar parágrafos, dividi-los ou reordená-los se isso melhorar a clareza e o impacto.
                3. Responda APENAS com o novo bloco de texto reescrito. Sem comentários ou introduções.`;

                const rawResult = await callGroqAPI(prompt, 2000);
                const newContent = removeMetaComments(rawResult.trim());
                const newParagraphs = newContent.split('\n').filter(p => p.trim() !== '');

                const firstParagraph = paragraphsToOptimize[0];
                const contentWrapper = firstParagraph.parentElement;
                
                firstParagraph.textContent = newParagraphs[0] || '';
                firstParagraph.className = 'retention-paragraph-live retention-green highlight-change';
                firstParagraph.removeAttribute('data-suggestion-group');

                let lastElement = firstParagraph;
                for (let i = 1; i < newParagraphs.length; i++) {
                    const newDiv = document.createElement('div');
                    newDiv.textContent = newParagraphs[i];
                    newDiv.className = 'retention-paragraph-live retention-green highlight-change';
                    contentWrapper.insertBefore(newDiv, lastElement.nextSibling);
                    lastElement = newDiv;
                }

                for (let i = 1; i < paragraphsToOptimize.length; i++) {
                    paragraphsToOptimize[i].remove();
                }

                // >>>>> AQUI ESTÁ A CORREÇÃO QUE FALTAVA <<<<<
                // 1. Encontra o elemento da seção pai, a partir do primeiro parágrafo.
                const sectionElement = firstParagraph.closest('.script-section');

                // 2. Invalida os resultados de Performance e Prompts, pois o texto mudou.
                if (sectionElement) {
                    invalidateAndClearPerformance(sectionElement);
                    invalidateAndClearPrompts(sectionElement);
                }
                // >>>>> FIM DA CORREÇÃO <<<<<

                window.showToast("Bloco de parágrafos otimizado!");

            } catch (error) {
                window.showToast(`Falha ao otimizar: ${error.message}`);
                console.error("Erro detalhado em optimizeGroup:", error);
                button.innerHTML = 'Erro!';
            }
        };



// =========================================================================
// >>>>> AÇÃO 2: SUBSTITUA A FUNÇÃO 'analyzeFullScript' INTEIRA POR ESTA <<<<<
// =========================================================================
const analyzeFullScript = async (button) => {
    showButtonLoading(button);
    const reportContainer = document.getElementById('analysisReportContainer');
    reportContainer.innerHTML = DOMPurify.sanitize(`<div class="my-4"><div class="loading-spinner-small mx-auto"></div><p class="text-sm mt-2">Analisando... Isso pode levar um momento.</p></div>`);

    try {
        const introText = document.querySelector('#introSection .generated-content-wrapper')?.textContent.trim();
        const devText = document.querySelector('#developmentSection .generated-content-wrapper')?.textContent.trim();
        const climaxText = document.querySelector('#climaxSection .generated-content-wrapper')?.textContent.trim();
        const conclusionText = document.querySelector('#conclusionSection .generated-content-wrapper')?.textContent.trim();
        const ctaText = document.querySelector('#ctaSection .generated-content-wrapper')?.textContent.trim();

        if (!introText || !devText || !climaxText || !conclusionText || !ctaText) {
            throw new Error("Todas as 5 seções do roteiro (Intro, Dev, Clímax, Conclusão e CTA) devem ser geradas primeiro.");
        }

        // <<< USANDO Promise.allSettled PARA RESILIÊNCIA >>>
        const results = await Promise.allSettled([
            analyzeScriptPart('Introdução (Hook)', introText, `Analise este hook...`),
            analyzeScriptPart('Desenvolvimento (Ritmo e Retenção)', devText, `Analise este desenvolvimento...`),
            analyzeScriptPart('Clímax', climaxText, `Analise este clímax...`),
            analyzeScriptPart('Conclusão', conclusionText, `Analise esta conclusão...`),
            analyzeScriptPart('CTA (Call to Action)', ctaText, `Analise este CTA...`)
        ]);

        reportContainer.innerHTML = '';

        results.forEach(result => {
            if (result.status === 'fulfilled') {
                reportContainer.appendChild(createReportSection(result.value));
            } else {
                console.error("Uma micro-análise falhou:", result.reason);
                // A função analyzeScriptPart já retorna um objeto de erro formatado,
                // então podemos simplesmente renderizá-lo.
                reportContainer.appendChild(createReportSection(result.reason));
            }
        });

        window.showToast("Análise do roteiro concluída!");

    } catch (error) {
        console.error("Erro detalhado em analyzeFullScript:", error);
        window.showToast(`Falha na análise: ${error.message}`);
        reportContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};




// =========================================================================
// >>>>> PASSO 1: SUBSTITUA A FUNÇÃO 'analyzeScriptPart' INTEIRA POR ESTA <<<<<
// =========================================================================
const analyzeScriptPart = async (criterion, text, instruction) => {
    const prompt = `Você é uma API de Análise de Roteiro que atua como um editor de linha e um estrategista de conteúdo para YouTube. Sua resposta DEVE ser um objeto JSON.

**TAREFA:** Analise o "Trecho de Roteiro" fornecido com base no "Critério de Análise". Sua análise deve ser crítica, profissional e, acima de tudo, acionável.

**Critério de Análise:** ${instruction}

**Trecho de Roteiro:**
---
${text.slice(0, 7000)}
---

**REGRAS CRÍTICAS DE RESPOSTA (JSON ESTRITO):**
Sua resposta DEVE ser um objeto JSON com EXATAMENTE estas chaves:
- "criterion_name": (String) O nome do critério (ex: "${criterion}").
- "score": (Número) Uma nota de 0 a 10.
- "positive_points": (String) Um parágrafo resumindo os pontos fortes.
- "improvement_points": (Array) Um array de objetos, onde cada objeto DEVE ter QUATRO chaves:
    - "problematic_quote": (String) A frase ou trecho EXATO do roteiro original que representa a maior oportunidade de melhoria.
    - "critique": (String) Uma crítica construtiva explicando POR QUE este trecho é um ponto fraco.
    - "suggestion_text": (String) Uma explicação GERAL da sugestão (ex: 'Tente usar uma linguagem mais ativa.').
    - "rewritten_quote": (String) A nova frase, JÁ REESCRITA, pronta para substituir a original.
- **ASPAS INTERNAS:** Se precisar citar algo, use aspas simples (' '). É proibido usar aspas duplas dentro de outra string.

Responda APENAS com o objeto JSON.`;

    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const analysisData = cleanGeneratedText(rawResult, true);

        if (!analysisData) {
            throw new Error("A IA retornou uma resposta nula ou vazia.");
        }
        const requiredKeys = ['criterion_name', 'score', 'positive_points', 'improvement_points'];
        for (const key of requiredKeys) {
            if (!(key in analysisData)) {
                throw new Error(`A chave '${key}' está ausente na resposta JSON da IA.`);
            }
        }
        if (!Array.isArray(analysisData.improvement_points)) {
            throw new Error("A chave 'improvement_points' deveria ser um array.");
        }

        return analysisData;

    } catch (error) {
        console.error(`Erro ao analisar a parte '${criterion}':`, error);
        return { 
            criterion_name: criterion, 
            score: 'Erro', 
            positive_points: 'Não foi possível analisar esta seção.', 
            improvement_points: [{
                critique: 'Erro da API',
                suggestion_text: `A análise falhou: ${error.message}`,
                problematic_quote: 'N/A',
                rewritten_quote: 'N/A'
            }]
        };
    }
};



// =========================================================================
// >>>>> PASSO 2: SUBSTITUA A FUNÇÃO 'createReportSection' INTEIRA POR ESTA <<<<<
// =========================================================================
const createReportSection = (analysisData) => {
    const sectionDiv = document.createElement('div');
    sectionDiv.className = 'p-4 border rounded-lg mb-4 bg-gray-50 dark:bg-gray-800 animate-fade-in';

    if (!analysisData || typeof analysisData.score === 'undefined') {
        const errorName = analysisData ? analysisData.criterion_name : 'Seção de Análise';
        sectionDiv.innerHTML = DOMPurify.sanitize(`
            <h4 class="font-bold text-lg text-red-500">${errorName}</h4>
            <p class="text-red-500 text-sm mt-2">Falha ao processar a análise para esta seção. A resposta da IA pode estar em um formato inesperado.</p>
        `);
        return sectionDiv;
    }

    let improvementHtml = '';
    if (analysisData.improvement_points && analysisData.improvement_points.length > 0) {
        improvementHtml = analysisData.improvement_points.map(point => {
            const problematicQuoteEscaped = (point.problematic_quote || '').replace(/"/g, '"');
            const rewrittenQuoteEscaped = (point.rewritten_quote || '').replace(/"/g, '"');

            return `
            <div class="mt-4 pt-3 border-t border-dashed border-gray-300 dark:border-gray-600">
                <p class="text-sm italic text-gray-500 dark:text-gray-400 mb-1">" ${DOMPurify.sanitize(point.problematic_quote || '')} "</p>
                <p class="text-sm"><strong class="text-yellow-600 dark:text-yellow-400">Crítica:</strong> ${DOMPurify.sanitize(point.critique || '')}</p>
                <div class="flex items-center justify-between gap-2 mt-2">
                    <p class="text-sm flex-1"><strong class="text-green-600 dark:text-green-400">Sugestão:</strong> ${DOMPurify.sanitize(point.suggestion_text || '')}</p>
                    
                    <button class="btn btn-primary btn-small flex-shrink-0"
                            data-action="applySuggestion"
                            data-criterion-name="${DOMPurify.sanitize(analysisData.criterion_name)}"
                            data-problematic-quote="${problematicQuoteEscaped}"
                            data-rewritten-quote="${rewrittenQuoteEscaped}">
                        Aplicar
                    </button>
                </div>
            </div>`;
        }).join('');
    }

    const content = `
        <div class="flex justify-between items-center">
            <h4 class="font-bold text-lg">${DOMPurify.sanitize(analysisData.criterion_name)}</h4>
            <span class="font-bold text-xl text-primary">${analysisData.score}/10</span>
        </div>
        <div class="mt-2">
            <p class="text-sm"><strong class="text-indigo-500">Pontos Fortes:</strong> ${DOMPurify.sanitize(analysisData.positive_points)}</p>
            ${improvementHtml}
        </div>
    `;
    sectionDiv.innerHTML = content;
    return sectionDiv;
};



// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO 'varyTone' INTEIRA POR ESTA VERSÃO <<<<<
// =========================================================================

const varyTone = async (tone) => {
    if (!userSelectionRange) {
        window.showToast("Erro: Seleção de texto perdida.");
        return;
    }
    const selectedText = userSelectionRange.toString();
    const toneMenu = document.getElementById('tone-variation-menu');
    toneMenu.classList.remove('visible');

    // <<< AQUI ESTÁ A CORREÇÃO: Lemos o idioma selecionado >>>
    const selectedLangCode = document.getElementById('languageSelect').value;
    const languageName = selectedLangCode === 'pt-br' ? 'Português do Brasil' : 'English';

    const toneInstructions = {
        emotion: "injete linguagem mais emotiva, focada em sentimentos, vulnerabilidade e impacto pessoal. Use palavras mais fortes e analogias sensoriais.",
        impact: "use frases mais curtas, palavras de ação e uma estrutura que crie um senso de velocidade, urgência e importância.",
        clarity: "atue como um 'tradutor de complexidade'. Remova jargões, simplifique conceitos e reescreva a ideia da forma mais clara e direta possível.",
        humor: "reescreva o trecho com uma pitada de ironia, sarcasmo leve ou uma analogia engraçada, alinhada com a voz geral do roteiro."
    };

    // <<< O PROMPT AGORA INCLUI A REGRA DE IDIOMA >>>
    const prompt = `Você é um Editor de Roteiro especialista em tom narrativo. Sua tarefa é reescrever o 'Texto Original' para que ele transmita um novo sentimento, mantendo a informação central.

**Texto Original:**
---
${selectedText}
---

**Nova Intenção (Tom):**
Você deve reescrever o texto para que ele tenha **mais ${tone}**. Para isso, ${toneInstructions[tone]}

**REGRAS CRÍTICAS (INEGOCIÁVEIS):**
1.  **IDIOMA:** A sua resposta DEVE, OBRIGATORIAMENTE, estar em **${languageName}**.
2.  **Mantenha a Essência:** A informação e o significado do texto original devem ser preservados.
3.  **RESPOSTA LIMPA:** Responda APENAS com o texto reescrito. Sem comentários ou explicações.`;

    try {
        const rawResult = await callGroqAPI(prompt, 1000);
        const variedText = removeMetaComments(rawResult);
        
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(userSelectionRange);
        document.execCommand('insertHTML', false, DOMPurify.sanitize(`<span class="highlight-change">${variedText}</span>`));
        
        const sectionElement = userSelectionRange.startContainer.parentElement.closest('.script-section');
        if (sectionElement) {
            invalidateAndClearPerformance(sectionElement);
            invalidateAndClearPrompts(sectionElement);
        }
        
        window.showToast(`Texto reescrito com '${tone}'!`);
    } catch(error) {
        console.error(`Erro ao variar o tom para ${tone}:`, error);
        window.showToast(`Falha ao reescrever o texto: ${error.message}`);
    } finally {
        userSelectionRange = null;
    }
};


// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO 'suggestFinalStrategy' INTEIRA POR ESTA <<<<<
// =========================================================================

const suggestFinalStrategy = async (button) => {
    showButtonLoading(button);

    // LÓGICA DE RESET INTELIGENTE
    const conclusionContainer = document.getElementById('conclusionSection');
    const ctaContainer = document.getElementById('ctaSection');
    if (conclusionContainer) conclusionContainer.innerHTML = '';
    if (ctaContainer) ctaContainer.innerHTML = '';

    document.querySelectorAll('input[name="conclusionType"]').forEach(radio => radio.disabled = false);
    const conclusionSpecifics = document.getElementById('conclusionSpecifics');
    const ctaSpecifics = document.getElementById('ctaSpecifics');
    conclusionSpecifics.disabled = false;
    ctaSpecifics.disabled = false;
    document.querySelector('#conclusionInputContainer').classList.remove('opacity-50');
    ctaSpecifics.parentElement.classList.remove('opacity-50');

    document.getElementById('generateConclusionBtn').classList.remove('hidden');
    document.getElementById('generateCtaBtn').classList.add('hidden');
    
    projectState.conclusion = false;
    projectState.cta = false;

    const fullContext = getTranscriptOnly();
    if (!fullContext) {
        window.showToast("Gere o roteiro principal primeiro para receber sugestões.");
        hideButtonLoading(button);
        return;
    }

    // O NOVO PROMPT, MAIS DIRETO E MENOS "PESSOAL"
    const prompt = `Sua única função é analisar um roteiro e retornar um objeto JSON com sugestões para o final.

**ROTEIRO COMPLETO (PARA CONTEXTO):**
---
${fullContext}
---

**REGRAS CRÍTICAS DE RESPOSTA (JSON ESTRITO):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON.
2.  **ESTRUTURA OBRIGATÓRIA:** O objeto DEVE conter EXATAMENTE duas chaves: "conclusion_suggestion" e "cta_suggestion".
3.  **CONTEÚDO:** O valor de "conclusion_suggestion" deve ser uma lição poderosa. O valor de "cta_suggestion" deve ser um Call to Action criativo e engajador.
4.  **IDIOMA:** Ambos os textos devem estar no mesmo idioma do roteiro.

Responda APENAS com o objeto JSON.`;

    try {
        const rawResult = await callGroqAPI(prompt, 1000);
        const suggestions = cleanGeneratedText(rawResult, true);

        if (suggestions && suggestions.conclusion_suggestion && suggestions.cta_suggestion) {
            conclusionSpecifics.value = suggestions.conclusion_suggestion;
            ctaSpecifics.value = suggestions.cta_suggestion;
            window.showToast("Sugestões para Conclusão e CTA preenchidas!");
        } else {
            throw new Error("A IA não retornou sugestões no formato esperado.");
        }

    } catch (error) {
        console.error("Erro detalhado em suggestFinalStrategy:", error);
        window.showToast(`Falha ao sugerir estratégia final: ${error.message}`);
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};

// =========================================================================
// >>>>> ADICIONE ESTA NOVA FUNÇÃO AO SEU SCRIPT <<<<<
// =========================================================================
/**
 * Encontra e deleta todos os parágrafos pertencentes a um mesmo grupo de sugestão,
 * usando o modal de confirmação personalizado da aplicação.
 * @param {HTMLElement} button - O botão de deletar que foi clicado.
 * @param {string} suggestionText - O texto da sugestão que identifica o grupo.
 */
window.deleteParagraphGroup = async (button, suggestionText) => {
    // 1. CHAMA O NOSSO MODAL PERSONALIZADO e aguarda a resposta (true/false).
    const userConfirmed = await showConfirmationDialog(
        'Confirmar Deleção',
        'Tem certeza que deseja deletar este bloco de parágrafos? Esta ação não pode ser desfeita.'
    );

    // 2. Se o usuário clicou em "Não" (ou fechou), a função para aqui.
    if (!userConfirmed) {
        return;
    }

    // 3. O resto da lógica continua exatamente como antes.
    const safeSelector = suggestionText.replace(/"/g, '\\"');
    const paragraphsToDelete = document.querySelectorAll(`[data-suggestion-group="${safeSelector}"]`);

    if (paragraphsToDelete.length === 0) {
        window.showToast("Erro: Parágrafos para deletar não encontrados.");
        return;
    }

    const sectionElement = paragraphsToDelete[0].closest('.script-section');

    paragraphsToDelete.forEach(p => p.remove());

    if (sectionElement) {
        invalidateAndClearPerformance(sectionElement);
        invalidateAndClearPrompts(sectionElement);
        updateAllReadingTimes();
    }

    window.showToast("Bloco de parágrafos deletado com sucesso!");
};



// =========================================================================
// >>>>> PASSO 2: SUBSTITUA A FUNÇÃO showInputDialog COMPLETA <<<<<
// =========================================================================
/**
 * Exibe uma caixa de diálogo com um campo de texto e sugestões, e aguarda a entrada do usuário.
 * @param {string} title - O título da caixa de diálogo.
 * @param {string} message - A mensagem de ajuda/descrição.
 * @param {string} label - A label para o campo de texto.
 * @param {string} placeholder - O placeholder para o campo de texto.
 * @param {string[]} suggestions - (NOVO) Um array de strings para criar botões de sugestão.
 * @returns {Promise<string|null>} - Retorna o texto escolhido ou null se cancelar.
 */
const showInputDialog = (title, message, label, placeholder, suggestions = []) => {
    return new Promise(resolve => {
        // Mapeia todos os elementos do DOM necessários para o diálogo
        const overlay = document.getElementById('inputDialogOverlay');
        const titleEl = document.getElementById('inputDialogTitle');
        const messageEl = document.getElementById('inputDialogMessage');
        const labelEl = document.getElementById('inputDialogLabel');
        const fieldEl = document.getElementById('inputDialogField');
        const btnConfirm = document.getElementById('inputBtnConfirm');
        const btnCancel = document.getElementById('inputBtnCancel');
        const suggestionsContainer = document.getElementById('inputDialogSuggestions');

        // Garante que todos os elementos existem antes de continuar para evitar erros
        if (!overlay || !titleEl || !messageEl || !labelEl || !fieldEl || !btnConfirm || !btnCancel || !suggestionsContainer) {
            console.error("Elementos do pop-up de input não foram encontrados no HTML.");
            resolve(null); // Resolve como nulo para não travar a aplicação
            return;
        }

        // Limpa o conteúdo de interações anteriores
        suggestionsContainer.innerHTML = '';
        fieldEl.value = '';

        // Preenche os textos do diálogo com os parâmetros recebidos
        titleEl.textContent = title;
        messageEl.textContent = message;
        labelEl.textContent = label;
        fieldEl.placeholder = placeholder;
        
        // Função centralizada para fechar o diálogo e resolver a Promise
        const closeDialog = (result) => {
            overlay.style.display = 'none';
            // Remove os event listeners para evitar chamadas duplicadas em futuras aberturas
            btnConfirm.onclick = null;
            btnCancel.onclick = null;
            resolve(result);
        };

        // Cria e adiciona os botões de sugestão, se houver sugestões
        if (suggestions && suggestions.length > 0) {
            suggestions.forEach(suggestionText => {
                const suggestionBtn = document.createElement('button');
                suggestionBtn.className = 'btn btn-secondary hover:bg-purple-600 dark:hover:bg-purple-700 w-full text-left justify-start';
                suggestionBtn.textContent = suggestionText;
                // Ao clicar em um botão de sugestão, fecha o diálogo e retorna o texto da sugestão
                suggestionBtn.onclick = () => {
                    closeDialog(suggestionText);
                };
                suggestionsContainer.appendChild(suggestionBtn);
            });
        }

        // Configura o botão de confirmação (para o texto personalizado)
        btnConfirm.onclick = () => {
            const customText = fieldEl.value.trim();
            if (customText) {
                // Se o usuário digitou algo, fecha o diálogo e retorna o texto digitado
                closeDialog(customText);
            } else {
                // Se o campo estiver vazio, avisa o usuário
                window.showToast("Por favor, digite um tema ou escolha uma das sugestões.");
            }
        };

        // Configura o botão de cancelar
        btnCancel.onclick = () => closeDialog(null);

        // Exibe o diálogo
        overlay.style.display = 'flex';
        fieldEl.focus(); // Coloca o foco no campo de texto para facilitar a digitação
    });
};



// =========================================================================
// >>>>> VERSÃO FINAL DE updateAllReadingTimes COM O SELETOR CORRIGIDO <<<<<
// =========================================================================
/**
 * Percorre todas as seções de roteiro geradas e atualiza o tempo de leitura exibido.
 */
const updateAllReadingTimes = () => {
    // Pega todas as seções de roteiro que já foram geradas
    const scriptSections = document.querySelectorAll('#scriptSectionsContainer .accordion-item');
    
    scriptSections.forEach(item => {
        const contentWrapper = item.querySelector('.generated-content-wrapper');
        
        // >>>>> A CORREÇÃO ESTÁ AQUI: Trocamos '.header-content' por '.header-title-group' <<<<<
        const timeDisplay = item.querySelector('.header-title-group .text-xs');

        if (contentWrapper && timeDisplay) {
            // Recalcula o tempo de leitura com base no conteúdo atualizado
            const newTime = calculateReadingTime(contentWrapper.textContent);
            // Atualiza o texto do elemento span com o novo tempo
            timeDisplay.textContent = newTime;
        }
    });
}


    // ==========================================================
// >>>>> SUBSTITUA A FUNÇÃO validateInputs INTEIRA POR ESTA <<<<<
// ==========================================================
const validateInputs = () => {
    const channelName = document.getElementById('channelName')?.value.trim();
    const videoTheme = document.getElementById('videoTheme')?.value.trim();
    const videoDescription = document.getElementById('videoDescription')?.value.trim();
    const videoDuration = document.getElementById('videoDuration')?.value;
    // Adicionamos a leitura do novo campo
    const visualPacing = document.getElementById('visualPacing')?.value;

    if (!channelName) {
        window.showToast("Por favor, insira o nome do canal.");
        return false;
    }
    if (!videoTheme) {
        window.showToast("Por favor, insira o tema do vídeo.");
        return false;
    }
    if (!videoDescription) {
        window.showToast("Por favor, insira a descrição do vídeo (para inspiração).");
        return false;
    }
    if (!videoDuration || videoDuration === "") {
        window.showToast("Por favor, selecione a Duração Desejada do vídeo.");
        return false;
    }
    
    // ==========================================================
    // >>>>> AQUI ESTÁ A NOVA VALIDAÇÃO <<<<<
    // ==========================================================
    if (!visualPacing || visualPacing === "") {
        window.showToast("Por favor, selecione o Ritmo Visual do vídeo.");
        return false;
    }
    
    return true;
};



// =========================================================================
// >>>>> AÇÃO 4: SUBSTITUA AS FUNÇÕES DE RESET COMPLETAS <<<<<
// =========================================================================
const resetProjectOutputs = () => {
    console.log("Resetando outputs do projeto para nova estratégia...");

    // Zera o nosso "painel de controle".
    projectState = { intro: false, development: false, climax: false, conclusion: false };

    // O resto da sua função continua o mesmo...
    strategicOutline = null;
    allImagePrompts = {};
    generatedTitlesAndThumbnails = null;
    totalScriptSeconds = 0;
    promptPaginationState = {};
    window.emotionalMap = null;

    const contentContainers = ['scriptSectionsContainer', 'outlineContent', 'titlesThumbnailsContent', 'videoDescriptionContent', 'soundtrackContent', 'emotionalMapContent'];
    
    contentContainers.forEach(id => {
        const container = document.getElementById(id);
        if (container) {
            if (id === 'scriptSectionsContainer') {
                container.innerHTML = `
                    <div id="introSection" class="script-section"></div>
                    <div id="developmentSection" class="script-section"></div>
                    <div id="climaxSection" class="script-section"></div>
                    <div id="conclusionSection" class="script-section"></div>
                    <div id="ctaSection" class="script-section hidden"></div> 
                `;
            } else {
                const placeholderText = {
                    'outlineContent': "Clique em 'Criar Esboço' para a IA planejar a estrutura do roteiro.",
                    'titlesThumbnailsContent': "Clique em 'Gerar' para ver as sugestões",
                    'videoDescriptionContent': "Clique em 'Gerar' para ver a descrição",
                    'soundtrackContent': "Clique em 'Gerar' para criar sugestões de trilha para o roteiro completo.",
                    'emotionalMapContent': "Clique em 'Mapear' para a IA analisar a jornada emocional do roteiro."
                };
                container.innerHTML = `<div class="asset-card-placeholder">${placeholderText[id] || ''}</div>`;
            }
        }
    });

    resetCompletionIcons();
    updateProgressBar();
    
    const conclusionModule = document.getElementById('conclusionStrategyModule');
    if(conclusionModule) conclusionModule.classList.add('hidden');
};







        /**
         * Exibe uma caixa de diálogo de confirmação e aguarda a resposta do usuário.
         * @param {string} title - O título da caixa de diálogo.
         * @param {string} message - A mensagem de confirmação.
         * @returns {Promise<boolean>} - Retorna true se o usuário clicar "Sim", false caso contrário.
         */
        const showConfirmationDialog = (title, message) => {
            return new Promise(resolve => {
                const overlay = document.getElementById('confirmationDialogOverlay');
                const titleEl = document.getElementById('confirmationTitle');
                const messageEl = document.getElementById('confirmationMessage');
                const btnYes = document.getElementById('confirmBtnYes');
                const btnNo = document.getElementById('confirmBtnNo');

                // Garante que todos os elementos existem antes de continuar
                if (!overlay || !titleEl || !messageEl || !btnYes || !btnNo) {
                    console.error("Elementos do pop-up de confirmação não foram encontrados no HTML.");
                    resolve(false); // Resolve como 'false' para não travar a aplicação
                    return;
                }

                titleEl.textContent = title;
                messageEl.textContent = message;
                overlay.style.display = 'flex';

                // Função para limpar e fechar o diálogo
                const closeDialog = (result) => {
                    overlay.style.display = 'none';
                    // Remove os listeners para evitar chamadas duplicadas
                    clonedBtnYes.replaceWith(btnYes);
                    clonedBtnNo.replaceWith(btnNo);
                    resolve(result);
                };

                // TRUQUE PARA GARANTIR LISTENERS LIMPOS:
                // Clonamos os botões para remover quaisquer event listeners antigos
                const clonedBtnYes = btnYes.cloneNode(true);
                const clonedBtnNo = btnNo.cloneNode(true);

                // Adicionamos os novos listeners aos clones
                clonedBtnYes.addEventListener('click', () => closeDialog(true));
                clonedBtnNo.addEventListener('click', () => closeDialog(false));

                // Substituímos os botões originais pelos clones com os novos listeners
                btnYes.replaceWith(clonedBtnYes);
                btnNo.replaceWith(clonedBtnNo);
            });
        };

        /**
         * Compara um texto gerado pela IA (com anotações) com o texto original
         * para garantir que o conteúdo não foi alterado.
         * @param {string} originalText - O texto base.
         * @param {string} annotatedText - O texto com anotações gerado pela IA.
         * @returns {{isValid: boolean, cleanTextFromAI: string}} - Retorna se é válido e o texto da IA sem anotações.
         */
        const auditGeneratedText = (originalText, annotatedText) => {
            // Remove todas as anotações [em colchetes] do texto da IA
            const cleanTextFromAI = annotatedText.replace(/\[.*?\]/g, '').trim();
            
            // Remove múltiplos espaços e quebras de linha para uma comparação mais justa
            const normalizedOriginal = originalText.replace(/\s+/g, ' ').trim();
            const normalizedCleanAI = cleanTextFromAI.replace(/\s+/g, ' ').trim();

            // Compara os dois textos normalizados
            const isValid = normalizedOriginal === normalizedCleanAI;
            
            return { isValid, cleanTextFromAI };
        };


        /**
         * Copia um texto para a área de transferência.
         * @param {string} text - O texto a ser copiado.
         */
        window.copyTextToClipboard = async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                window.showToast('Copiado!');
            } catch (err) {
                // Fallback para navegadores mais antigos ou contextos restritos (ex: iframes)
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                document.body.appendChild(ta);
                ta.focus();
                ta.select();
                try {
                    document.execCommand('copy');
                    window.showToast('Copiado!');
                } finally {
                    document.body.removeChild(ta);
                }
            }
        };

        /**
         * Fornece feedback visual em um botão após uma ação de cópia.
         * @param {HTMLElement} buttonElement - O elemento do botão que foi clicado.
         */
        window.showCopyFeedback = (buttonElement) => {
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = 'Copiado!';
            buttonElement.classList.add('btn-success');
            buttonElement.disabled = true; // Desabilita o botão temporariamente

            setTimeout(() => {
                buttonElement.innerHTML = originalText;
                buttonElement.classList.remove('btn-success');
                buttonElement.disabled = false;
            }, 2000); // Reverte após 2 segundos
        };



        // ==========================================================
        // >>>>> ADICIONE ESTE NOVO BLOCO <<<<<
        // ==========================================================
        /**
         * Mostra um spinner de carregamento em QUALQUER botão, salvando seu conteúdo original.
         * @param {HTMLElement} button - O elemento do botão a ser modificado.
         */
        const showButtonLoading = (button) => {
            if (!button) return;
            // Salva o HTML original do botão (incluindo ícones e texto)
            button.setAttribute('data-original-html', button.innerHTML);
            button.disabled = true;
            // Define o spinner como o novo conteúdo.
            button.innerHTML = '<div class="loading-spinner" style="width:18px; height:18px; border-width: 2px;"></div>';
        };

        /**
         * Esconde o spinner de carregamento de um botão, restaurando seu conteúdo original.
         * @param {HTMLElement} button - O elemento do botão a ser restaurado.
         */
        const hideButtonLoading = (button) => {
            if (!button) return;
            // Restaura o HTML original que salvamos
            if (button.hasAttribute('data-original-html')) {
                button.innerHTML = button.getAttribute('data-original-html');
                button.removeAttribute('data-original-html');
            }
            button.disabled = false;
        };

        /**
         * Marca um botão (original e flutuante) como concluído (cor verde).
         * @param {string} originalId - O ID do botão original.
         */
        const markButtonAsCompleted = (originalId) => {
            const originalButton = document.getElementById(originalId);
            const floatButton = document.getElementById(`float_${originalId}`);

            [originalButton, floatButton].forEach(btn => {
                if (btn) {
                    btn.classList.remove('btn-primary', 'btn-secondary');
                    btn.classList.add('btn-success');
                }
            });
            updateProgressBar(); 
        };



        /**
         * Reseta os ícones de conclusão de todos os botões (original e flutuante) para suas cores padrão.
         */
        const resetCompletionIcons = () => {
            const passo1_buttons_ids = ['generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 'conclusionBtn', 'generateCTABtn'];
            
            for (const buttonId in buttons) { // Iterar sobre todos os botões
                const isPasso1 = passo1_buttons_ids.includes(buttonId);
                const originalButton = document.getElementById(buttonId);
                const floatButton = document.getElementById(`float_${buttonId}`);

                // Remove a classe de sucesso e adiciona a classe correta (primary/secondary)
                [originalButton, floatButton].forEach(btn => {
                    if (btn) {
                        btn.classList.remove('btn-success');
                        if (isPasso1) {
                            btn.classList.remove('btn-secondary');
                            btn.classList.add('btn-primary');
                        } else {
                            btn.classList.remove('btn-primary');
                            btn.classList.add('btn-secondary');
                        }
                    }
                });
            }
        };
        
/**
 * Verifica se as seções principais do roteiro foram geradas.
 * @returns {boolean} True se todas as seções principais foram geradas, caso contrário, false.
 */
const isScriptComplete = () => {
    // Esta versão lê diretamente do nosso "painel de controle" de estado,
    // que é muito mais confiável do que verificar o HTML.
    return projectState.intro && projectState.development && projectState.climax && projectState.conclusion && projectState.cta;
};




// =========================================================================
// >>>>> AÇÃO 3: SUBSTITUA A FUNÇÃO updateButtonStates COMPLETA <<<<<
// =========================================================================
const updateButtonStates = () => {
    // Em vez de olhar para o HTML, lemos nosso "painel de controle" (`projectState`).
    const { intro, development, climax, conclusion } = projectState;
    
    // A condição principal agora é baseada em nosso objeto de estado. É 100% confiável.
    const allMainScriptGenerated = intro && development && climax;

    // A lógica de metadados agora é mais robusta.
    const metadataButtons = ['generateTitlesAndThumbnailsBtn', 'generateDescriptionBtn', 'generateSoundtrackBtn', 'mapEmotionsBtn'];
    metadataButtons.forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            if (id === 'mapEmotionsBtn') {
                btn.disabled = !(allMainScriptGenerated && conclusion);
            } else {
                btn.disabled = !allMainScriptGenerated;
            }
        }
    });

    // Lógica para exibir/esconder o Módulo da Conclusão.
    const conclusionModule = document.getElementById('conclusionStrategyModule');
    const climaxContainer = document.getElementById('climaxSection');

    if (conclusionModule && climaxContainer) {
        if (allMainScriptGenerated && conclusionModule.classList.contains('hidden')) {
            climaxContainer.insertAdjacentElement('afterend', conclusionModule);
            conclusionModule.classList.remove('hidden');
            conclusionModule.scrollIntoView({ behavior: 'smooth', block: 'center' });
            window.showToast("Excelente! Agora, defina a estratégia para a sua conclusão.");
            
            document.querySelectorAll('input[name="conclusionType"]').forEach(radio => {
                radio.addEventListener('change', handleConclusionStrategyChange);
            });
            handleConclusionStrategyChange();
        } 
        else if (!allMainScriptGenerated && !conclusionModule.classList.contains('hidden')) {
            conclusionModule.classList.add('hidden');
        }
    }
};




        /**
         * Mostra um alerta em tela cheia com uma mensagem.
         * @param {string} message - A mensagem a ser exibida.
         */
        const showFullScreenAlert = (message) => {
            elements.fullScreenAlertMessage.textContent = message;
            elements.fullScreenAlertOverlay.classList.add('visible');
        };

        /** Esconde o alerta em tela cheia. */
        const hideFullScreenAlert = () => {
            elements.fullScreenAlertOverlay.classList.remove('visible');
        };

        /** Alterna a visibilidade do campo de estilo de imagem personalizado. */
        const toggleCustomImageStyleVisibility = () => {
    // Adiciona uma verificação para garantir que os elementos existem antes de usá-los
    const container = document.getElementById('customImageStyleContainer');
    const select = document.getElementById('imageStyleSelect');
    if (container && select) {
        container.style.display = select.value === 'custom' ? 'block' : 'none';
    }
};




        /**
         * Coleta e concatena o texto puro de todas as seções do roteiro na ordem correta.
         * @returns {string} A transcrição completa e limpa.
         */
        const getTranscriptOnly = () => {
            let transcript = '';
            const sectionOrder = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection']; // CTA is now part of conclusionSection
            
            sectionOrder.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                const contentWrapper = section?.querySelector('.generated-content-wrapper');
                if (contentWrapper?.textContent.trim()) {
                    // Adiciona o texto da seção e duas quebras de linha para separar os parágrafos.
                    transcript += contentWrapper.textContent.trim() + '\n\n';
                }
            });
            
            return transcript.trim();
        };
    
        /**
         * Calcula o tempo de leitura estimado de um texto, considerando o ritmo de fala.
         */
        const calculateReadingTime = (text) => {
            if (!text) return "";

            const paceMap = {
                slow: 120,
                moderate: 150,
                fast: 180
            };
            
            const selectedPace = document.getElementById('speakingPace').value || 'moderate';
            const wordsPerMinute = paceMap[selectedPace];
            
            const words = text.trim().split(/\s+/).length;
            const totalSeconds = (words / wordsPerMinute) * 60;
            
            if (totalSeconds < 1) return "";
            
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.round(totalSeconds % 60);
            
            let timeString = "~";
            if (minutes > 0) timeString += ` ${minutes} min`;
            if (seconds > 0) timeString += ` ${seconds} seg`;
            
            return timeString.trim();
        };

    // ==========================================================
        // ==================== LÓGICA DAS ABAS =====================
        // ==========================================================
        const setupTabs = () => {
            const tabButtons = document.querySelectorAll('#tabs .tab-button');
            const tabPanes = document.querySelectorAll('#tab-content .tab-pane');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('active-tab'));
                    tabPanes.forEach(pane => pane.classList.remove('active-pane'));

                    button.classList.add('active-tab');
                    const tabId = button.getAttribute('data-tab');
                    const activePane = document.getElementById(tabId);
                    if (activePane) {
                        activePane.classList.add('active-pane');
                    }
                });
            });
        };


// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO mapEmotionsAndPacing INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
// =========================================================================

const mapEmotionsAndPacing = async (button) => {
    const isFullScriptComplete = 
        document.querySelector('#introSection .accordion-item') &&
        document.querySelector('#developmentSection .accordion-item') &&
        document.querySelector('#climaxSection .accordion-item') &&
        document.querySelector('#conclusionSection .accordion-item');

    if (!isFullScriptComplete) {
        window.showToast("Por favor, gere o roteiro completo (incluindo a Conclusão) antes de mapear as emoções.");
        return;
    }

    const fullTranscript = getTranscriptOnly();
    if (!fullTranscript) {
        window.showToast("Gere o roteiro completo primeiro para criar o mapa emocional.");
        return;
    }

    const outputContainer = document.getElementById('emotionalMapContent');
    
    showButtonLoading(button);
    outputContainer.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small mx-auto my-4"></div>`);

    const paragraphs = fullTranscript.split('\n\n').filter(p => p.trim() !== '');

    // >>> PROMPT BLINDADO COM REGRAS DE SINTAXE E ESTRUTURA EXPLÍCITAS <<<
    const prompt = `Você é uma API de análise de roteiro que retorna APENAS um array JSON.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`[\` e terminando com \`]\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar aspas duplas (\`"\`).
3.  **VÍRGULA FINAL:** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último objeto.
4.  **ESTRUTURA DO OBJETO:** Cada objeto no array DEVE conter EXATAMENTE estas três chaves: "paragraph_index" (um número, começando em 0), "emotion" (string), e "pace" (string).
5.  **NÚMERO DE OBJETOS:** O array DEVE conter EXATAMENTE ${paragraphs.length} objetos, um para cada parágrafo.

**ROTEIRO PARA ANALISAR:**
${paragraphs.map((p, index) => `PARAGRAFO ${index}: "${p}"`).join('\n\n')}

Responda APENAS com o array JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE as regras acima.`;

    try {
        const rawResult = await callGroqAPI(prompt, 3000);
        const analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis) || analysis.length < paragraphs.length) {
            throw new Error("A IA retornou um mapa emocional em formato inválido ou incompleto.");
        }

        window.emotionalMap = analysis;
        
        let mapHtml = '<div class="space-y-4">';
        analysis.forEach(item => {
            const paragraphText = paragraphs[item.paragraph_index];
            if (!paragraphText) return;

            mapHtml += `
                <div class="emotional-map-item card !p-3">
                    <p class="paragraph-preview">"${DOMPurify.sanitize(paragraphText)}"</p>
                    <div class="analysis-tags">
                        <span class="tag tag-emotion">
                            <i class="fas fa-theater-masks mr-2"></i>${DOMPurify.sanitize(item.emotion)}
                        </span>
                        <span class="tag tag-pace">
                            <i class="fas fa-tachometer-alt mr-2"></i>${DOMPurify.sanitize(item.pace)}
                        </span>
                    </div>
                </div>
            `;
        });
        mapHtml += '</div>';
        
        outputContainer.innerHTML = DOMPurify.sanitize(mapHtml, { ADD_TAGS: ["i"] });
        markButtonAsCompleted(button.id);

    } catch (error) {
        console.error("Erro detalhado em mapEmotionsAndPacing:", error);
        outputContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">Falha ao gerar o mapa emocional: ${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};


// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO generateSoundtrack INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
// =========================================================================

const generateSoundtrack = async (button) => {
    const fullTranscript = getTranscriptOnly();
    if (!fullTranscript) {
        window.showToast("Gere o roteiro completo primeiro para sugerir uma trilha sonora coerente.");
        return;
    }

    const outputContainer = document.getElementById('soundtrackContent');
    
    showButtonLoading(button);
    outputContainer.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small mx-auto my-4"></div>`);

    // >>> PROMPT BLINDADO SEGUINDO A ANÁLISE PROFISSIONAL <<<
    const prompt = `Você é um especialista em criação de prompts para IAs de música. Sua tarefa é gerar 3 parágrafos descritivos para uma trilha sonora baseada no roteiro fornecido.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (ABSOLUTAMENTE OBRIGATÓRIAS):**
1.  **JSON PURO E PERFEITO:** Sua resposta inteira deve ser APENAS um array JSON válido, começando com \`[\` e terminando com \`]\`. NENHUM outro texto é permitido.
2.  **ESTRUTURA DO ARRAY:** O array deve conter EXATAMENTE 3 strings.
3.  **ASPAS DUPLAS SEMPRE:** CADA string no array DEVE usar obrigatoriamente aspas duplas (\`"\`).
4.  **VÍRGULAS OBRIGATÓRIAS:** CADA string no array, exceto a ÚLTIMA, DEVE ser seguida por uma vírgula (\`,\`).
5.  **CONTEÚDO DAS STRINGS:** Cada string deve ser um parágrafo único e bem escrito.

**EXEMPLO DE FORMATO PERFEITO E OBRIGATÓRIO:**
[
  "Uma melodia suave e inspiradora com piano e violão, criando uma atmosfera de esperança.",
  "Ritmo acelerado e eletrizante com sintetizadores, combinando tensão e empolgação para momentos de ação.",
  "Uma orquestração épica e emocional com cordas, evocando sentimentos de conquista e realização."
]

**ROTEIRO COMPLETO PARA ANALISAR:**
---
${fullTranscript}
---

Responda APENAS com o array JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE as regras acima.`;

    try {
        const rawResult = await callGroqAPI(prompt, 1500);
        const analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis) || analysis.length === 0) {
            throw new Error("A IA não retornou sugestões no formato esperado.");
        }

        let suggestionsHtml = '<ul class="soundtrack-list space-y-2">';
        analysis.forEach(suggestion => {
            suggestionsHtml += `<li>${DOMPurify.sanitize(suggestion)}</li>`;
        });
        suggestionsHtml += '</ul>';
        
        outputContainer.innerHTML = DOMPurify.sanitize(`<div class="generated-output-box">${suggestionsHtml}</div>`);
        markButtonAsCompleted(button.id);

    } catch (error) {
        console.error("Erro detalhado em generateSoundtrack:", error);
        outputContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">Falha ao gerar sugestões: ${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};



// =========================================================================
// >>>>> PASSO 2: SUBSTITUA a função 'generateConclusion' INTEIRA por ESTA <<<<<
// =========================================================================

const generateConclusion = async (button) => {
    if (!validateInputs()) return;
    showButtonLoading(button);

    const scriptContainer = document.getElementById('scriptSectionsContainer');
    if (scriptContainer && !document.getElementById('conclusionSection')) {
        const conclusionDiv = document.createElement('div');
        conclusionDiv.id = 'conclusionSection';
        conclusionDiv.classList.add('script-section');
        scriptContainer.appendChild(conclusionDiv);
    }

    const conclusionType = document.querySelector('input[name="conclusionType"]:checked').value;
    const conclusionSpecifics = document.getElementById('conclusionSpecifics').value.trim();

    let strategyDirective = '';
    switch (conclusionType) {
        case 'lesson':
            strategyDirective = `O objetivo é reforçar uma lição ou reflexão central. Detalhe fornecido pelo usuário: '${conclusionSpecifics}'`;
            break;
        case 'answer':
            const question = document.getElementById('centralQuestion').value.trim() || 'a pergunta central do vídeo';
            strategyDirective = `O objetivo é responder de forma clara à pergunta central do vídeo ('${question}'). Detalhe fornecido pelo usuário: '${conclusionSpecifics}'`;
            break;
        case 'cliffhanger':
            strategyDirective = `O objetivo é criar um gancho ou mistério para o próximo vídeo. Detalhe fornecido pelo usuário: '${conclusionSpecifics}'`;
            break;
    }

    const fullContext = getTranscriptOnly();
    const basePromptContext = getBasePromptContext();
    const prompt = `${basePromptContext}
    ${fullContext ? `\n\n**ROTEIRO ESCRITO ATÉ AGORA (PARA CONTEXTO):**\n---\n${fullContext}\n---\n` : ''}
    Sua tarefa é escrever APENAS a **Conclusão** do vídeo, continuando de onde o roteiro parou. NÃO inclua um Call to Action (CTA) neste texto.
    **Diretiva Estratégica para a Conclusão:** ${strategyDirective}
    **REGRAS CRÍTICAS:** Responda APENAS com o texto da conclusão. Sem metadados, sem labels (como "Conclusão:"), apenas o texto a ser falado.`;

    try {
        let result = await callGroqAPI(prompt, 800);
        result = removeMetaComments(result.trim());
        const paragraphs = result.split('\n').filter(p => p.trim() !== '');
        const contentWithSpans = paragraphs.map((p, index) => `<div id="conclusion-p-${index}">${p}</div>`).join('');

        // <<< AQUI ESTÁ A CORREÇÃO >>>
        const conclusionContainer = document.getElementById('conclusionSection');
        const conclusionElement = generateSectionHtmlContent('conclusion', 'Conclusão', contentWithSpans);
        conclusionContainer.innerHTML = ''; // Limpa o container
        conclusionContainer.appendChild(conclusionElement); // Adiciona o elemento seguro
        projectState.conclusion = true;
        
        document.querySelectorAll('input[name="conclusionType"]').forEach(radio => radio.disabled = true);
        document.getElementById('conclusionSpecifics').disabled = true;
        document.querySelector('#conclusionInputContainer').classList.add('opacity-50');

        button.classList.add('hidden');
        document.getElementById('generateCtaBtn').classList.remove('hidden');

        window.showToast("Conclusão gerada! Agora, vamos criar um CTA poderoso.");
        document.getElementById('ctaSpecifics').focus();

    } catch (error) {
        window.showToast(`Falha ao gerar a conclusão: ${error.message}`);
        console.error("Erro detalhado em generateConclusion:", error);
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};

// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO 'generateStrategicCta' INTEIRA POR ESTA <<<<<
// =========================================================================

const generateStrategicCta = async (button) => {
    showButtonLoading(button);

    const scriptContainer = document.getElementById('scriptSectionsContainer');
    let ctaSection = document.getElementById('ctaSection');
    if (scriptContainer && !ctaSection) {
        ctaSection = document.createElement('div');
        ctaSection.id = 'ctaSection';
        ctaSection.classList.add('script-section');
        scriptContainer.appendChild(ctaSection);
    }

    const ctaSpecifics = document.getElementById('ctaSpecifics').value.trim();
    const fullContext = getTranscriptOnly();
    const basePromptContext = getBasePromptContext();

    let ctaDirective = "Crie um Call to Action (CTA) genérico, convidando o espectador a curtir, comentar e se inscrever.";
    if (ctaSpecifics) {
        ctaDirective = `Crie um Call to Action (CTA) altamente específico e persuasivo. Instrução do usuário: "${ctaSpecifics}". Conecte esta instrução ao tema geral do vídeo de forma natural e convincente.`;
    }

    const prompt = `${basePromptContext}
    **ROTEIRO COMPLETO (PARA CONTEXTO):**
    ---
    ${fullContext}
    ---
    Sua tarefa agora é escrever APENAS o **Call to Action (CTA)** para o final do vídeo.
    **Diretiva Estratégica para o CTA:** ${ctaDirective}
    **REGRAS CRÍTICAS DE FORMATAÇÃO (A REGRA MAIS IMPORTANTE):**
    1.  **APENAS TEXTO FALADO:** Sua resposta deve conter única e exclusivamente o texto que será narrado.
    2.  **É ESTRITAMENTE PROIBIDO** incluir qualquer tipo de anotação, rótulo de narrador (como 'Narrator:'), descrição de cena (como '(Visuals:...)', '(Opening shot...)') ou qualquer outra formatação que não seja para ser falado em voz alta. A violação desta regra resultará em falha.
    Responda APENAS com o texto puro do roteiro para o CTA.`;

    try {
        let result = await callGroqAPI(prompt, 400);
        result = removeMetaComments(result.trim());
        const paragraphs = result.split('\n').filter(p => p.trim() !== '');
        const contentWithSpans = paragraphs.map((p, index) => `<div id="cta-p-${index}">${p}</div>`).join('');
        
        const ctaElement = generateSectionHtmlContent('cta', 'Call to Action (CTA)', contentWithSpans);
        ctaSection.innerHTML = '';
        ctaSection.appendChild(ctaElement);
        ctaSection.classList.remove('hidden');
        
        projectState.cta = true;
        markButtonAsCompleted('generateCtaBtn');
        
        // <<< AQUI ESTÁ A LÓGICA DE TRAVAMENTO REINTRODUZIDA >>>
        const ctaSpecificsElement = document.getElementById('ctaSpecifics');
        ctaSpecificsElement.disabled = true;
        ctaSpecificsElement.parentElement.classList.add('opacity-50');
        
        document.getElementById('conclusionStrategyModule').classList.add('hidden');
        window.showToast("CTA Estratégico gerado! Roteiro finalizado.");
        
        const analysisSection = document.getElementById('scriptAnalysisSection');
        if (analysisSection) {
            analysisSection.classList.remove('hidden');
            analysisSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

    } catch(error) {
        console.error("Erro detalhado em generateStrategicCta:", error);
        window.showToast(`Falha ao gerar o CTA: ${error.message}`);
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};



    // ==========================================================
        // NOVA FUNÇÃO PARA ATUALIZAR A BARRA DE PROGRESO
        // ==========================================================
            const updateProgressBar = () => {
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    if (!progressFill || !progressText) return;

    const taskButtonIds = [
        'analyzeStrategyBtn',
        'generateOutlineBtn',
        'generateIntroBtn',
        'generateDevelopmentBtn',
        'climaxBtn',
        'generateConclusionAndCtaBtn', // Corrigido para o botão correto da conclusão
        'generateTitlesAndThumbnailsBtn',
        'mapEmotionsBtn',
        'generateDescriptionBtn',
        'generateSoundtrackBtn'
    ];
    const totalTasks = taskButtonIds.length;
    let completedTasks = 0;
    
    taskButtonIds.forEach(id => {
        const button = document.getElementById(id);
        if (button && button.classList.contains('btn-success')) {
            completedTasks++;
        }
    });

    const percentage = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

    // >>>>> INÍCIO DA CORREÇÃO <<<<<
    // Usamos as variáveis corretas (progressFill e progressText) e as cores corretas do CSS.
    progressFill.style.width = `${percentage}%`;
    progressText.textContent = `${percentage}%`;

    if (percentage === 100) {
        progressFill.textContent = "Projeto Pronto!"; 
        progressFill.style.color = '#ffffff';
        progressFill.style.textAlign = 'center';
        progressFill.style.backgroundColor = 'var(--success)'; // Corrigido
    } else {
        progressFill.textContent = '';
        progressFill.style.backgroundColor = 'var(--primary)'; // Corrigido
    }
    // >>>>> FIM DA CORREÇÃO <<<<<
};

        // ==========================================================
        // >>>>> SUBSTITUA SUA FUNÇÃO setupInputTabs POR ESTA <<<<<
        // ==========================================================
        const setupInputTabs = () => {
            const nav = document.getElementById('inputTabsNav');
            if (!nav) return;

            const tabButtons = nav.querySelectorAll('.tab-button');
            const tabPanes = document.getElementById('inputTabContent').querySelectorAll('.tab-pane');

            nav.addEventListener('click', (event) => {
                const button = event.target.closest('.tab-button');
                if (!button) return;

                // 1. Remove a classe ativa de TODOS os botões
                tabButtons.forEach(btn => btn.classList.remove('tab-active'));
                
                // 2. Esconde TODOS os painéis de conteúdo
                tabPanes.forEach(pane => pane.classList.add('hidden'));

                // 3. Adiciona a classe ativa APENAS no botão clicado
                button.classList.add('tab-active');
                
                // 4. Mostra APENAS o painel de conteúdo correspondente
                const tabId = button.getAttribute('data-tab');
                const activePane = document.getElementById(tabId);
                if (activePane) {
                    activePane.classList.remove('hidden');
                }
            });
        };

        const handleConclusionStrategyChange = () => {
            const conclusionSpecificsContainer = document.getElementById('conclusionInputContainer');
            const answerRadioButtonLabel = document.querySelector('input[value="answer"]').parentElement;
            const answerRadioButton = document.querySelector('input[value="answer"]');

            // 1. Lógica para desabilitar a opção "Responder Pergunta" se não houver pergunta
            const centralQuestionText = document.getElementById('centralQuestion').value.trim();
            if (!centralQuestionText) {
                answerRadioButton.disabled = true;
                answerRadioButtonLabel.classList.add('opacity-50', 'cursor-not-allowed');
                answerRadioButtonLabel.title = "Defina a 'Pergunta Central' nos campos principais para usar esta opção.";
                // Se a opção desabilitada estava selecionada, muda para a primeira
                if(answerRadioButton.checked) {
                    document.querySelector('input[value="lesson"]').checked = true;
                }
            } else {
                answerRadioButton.disabled = false;
                answerRadioButtonLabel.classList.remove('opacity-50', 'cursor-not-allowed');
                answerRadioButtonLabel.title = "";
            }
            
            const selectedValue = document.querySelector('input[name="conclusionType"]:checked').value;
            
            // 2. Lógica para mostrar/esconder o textarea e mudar o placeholder
            if (conclusionSpecificsContainer) {
                conclusionSpecificsContainer.classList.toggle('hidden', !['lesson', 'answer', 'cliffhanger'].includes(selectedValue));
            }
            
            const textarea = document.getElementById('conclusionSpecifics');
            if (textarea) {
                const placeholders = {
                    lesson: "Ex: A lição é que a resiliência é a nossa maior força...",
                    answer: "Ex: A resposta é que a Arca foi levada para a Etiópia, mas o verdadeiro segredo é...",
                    cliffhanger: "Ex: ...mas se a Arca foi encontrada, o que aconteceu com o que estava DENTRO dela?"
                };
                textarea.placeholder = placeholders[selectedValue] || "";
            }
        };

        /**
         * Alterna a visibilidade de um corpo de acordeão e a rotação de sua seta. (VERSÃO CORRIGIDA E ROBUSTA)
         * @param {string} bodyId - O ID do elemento do corpo do acordeão.
         * @param {string} arrowId - O ID do elemento da seta do acordeão.
         */
        window.toggleAccordion = (bodyId, arrowId) => {
            const body = document.getElementById(bodyId);
            const arrow = document.getElementById(arrowId);
            // CORREÇÃO: Encontra o cabeçalho subindo na árvore DOM
            const header = body ? body.closest('.accordion-item').querySelector('.accordion-header') : null;

            if (body && arrow && header) {
                const isOpen = body.classList.toggle('open');
                arrow.classList.toggle('open', isOpen);
                header.classList.toggle('active', isOpen);
            }
        };

        /**
 * Renderiza a página correta de prompts para uma determinada seção. (VERSÃO CORRIGIDA)
 * @param {string} sectionElementId - O ID da seção (ex: 'introSection').
 */
const renderPaginatedPrompts = (sectionElementId) => {
    const sectionElement = document.getElementById(sectionElementId);
    if (!sectionElement) return;

    const itemsPerPage = 4;
    const prompts = allImagePrompts[sectionElementId] || [];
    const currentPage = promptPaginationState[sectionElementId] || 0;
    const totalPages = Math.ceil(prompts.length / itemsPerPage);

    const promptItemsContainer = sectionElement.querySelector('.prompt-items-container');
    const navContainer = sectionElement.querySelector('.prompt-nav-container');

    if (!promptItemsContainer || !navContainer) return;

    promptItemsContainer.innerHTML = ''; // Limpa o conteúdo atual

    // --- NOVA LÓGICA DE CÁLCULO GLOBAL ---
    // 1. Define o índice de início no array completo de prompts
    const startIndex = currentPage * itemsPerPage;
    const promptsToShow = prompts.slice(startIndex, startIndex + itemsPerPage);

    // 2. Calcula a duração total de TODOS os prompts ANTES da página atual
    let cumulativeSeconds = 0;
    if (startIndex > 0) {
        const previousPrompts = prompts.slice(0, startIndex);
        cumulativeSeconds = previousPrompts.reduce((total, p) => total + (parseInt(p.estimated_duration, 10) || 18), 0);
    }
    // --- FIM DA NOVA LÓGICA ---

    promptsToShow.forEach((promptData, index) => {
        const globalIndex = startIndex + index; // Índice no array completo
        const currentSceneNumber = globalIndex + 1; // Número da cena correto

        // Calcula o timestamp para esta cena específica
        const minutes = Math.floor(cumulativeSeconds / 60);
        const seconds = cumulativeSeconds % 60;
        const timestamp = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

        const styleBlockContent = promptData.styleBlock || '';
        const promptHtml = `
            <div class="prompt-item card !p-3 animate-fade-in">
                <div class="prompt-header">
                    <span class="tag tag-scene"><i class="fas fa-film mr-2"></i>Cena ${String(currentSceneNumber).padStart(2, '0')}</span>
                    <span class="tag tag-time"><i class="fas fa-clock mr-2"></i>${timestamp}</span>
                    <button class="copy-btn-small" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${globalIndex}')?.textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${globalIndex}')?.textContent); window.showCopyFeedback(this)" title="Copiar Prompt">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <p class="paragraph-preview">"${promptData.scriptPhrase}"</p>
                <div class="prompt-details">
                    <p class="prompt-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                    <p id="prompt-content-${sectionElementId}-${globalIndex}">${promptData.imageDescription}</p>
                    ${styleBlockContent ? `<p class="style-block-indicator">[Estilo Cinematográfico Aplicado]</p>` : ''}
                    <pre id="style-block-${sectionElementId}-${globalIndex}" class="hidden">${styleBlockContent}</pre>
                </div>
            </div>
        `;
        promptItemsContainer.innerHTML += promptHtml;

        // Atualiza os segundos acumulados para a PRÓXIMA iteração do loop
        cumulativeSeconds += (parseInt(promptData.estimated_duration, 10) || 18);
    });
    
    // Atualiza os controles de navegação (código existente, permanece igual)
    navContainer.innerHTML = `
        <button class="btn btn-secondary btn-small" onclick="window.navigatePrompts('${sectionElementId}', -1)" ${currentPage === 0 ? 'disabled' : ''}>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/></svg>
        </button>
        <span class="text-sm font-medium text-gray-600 dark:text-gray-400">Página ${currentPage + 1} de ${totalPages}</span>
        <button class="btn btn-secondary btn-small" onclick="window.navigatePrompts('${sectionElementId}', 1)" ${currentPage + 1 >= totalPages ? 'disabled' : ''}>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg>
        </button>
    `;
    
    // REMOVIDO: A chamada para reNumberAllScenes() foi removida pois agora é desnecessária
};

/**
 * Valida se o array de prompts recebido da IA tem a estrutura correta.
 * @param {any} data - O dado parseado do JSON.
 * @returns {boolean} - True se for um array válido de prompts, false caso contrário.
 */
const validatePromptsArray = (data) => {
    // É um array? Ele não está vazio? O primeiro item é um objeto com as chaves que precisamos?
    return Array.isArray(data) && data.length > 0 && data.every(item => 
        item && typeof item === 'object' && 'scriptPhrase' in item && 'imageDescription' in item
    );
};

/**
 * Reseta o conteúdo do roteiro gerado quando um input estratégico é alterado.
 * @param {string} sourceId - O ID do elemento que causou a mudança.
 */
const resetGeneratedScriptContent = (sourceId) => {
    // Só reseta se já houver conteúdo gerado para não incomodar o usuário no início.
    if (!strategicOutline && !document.querySelector('#scriptSectionsContainer .accordion-item')) {
        return;
    }

    console.log(`Input estratégico '${sourceId}' alterado. Resetando conteúdo do roteiro.`);

    // 1. Limpa as variáveis de estado
    strategicOutline = null;
    allImagePrompts = {};
    promptPaginationState = {};
    totalScriptSeconds = 0;

    // 2. Limpa a UI do esboço e das seções
    const outlineContent = document.getElementById('outlineContent');
    if (outlineContent) {
        outlineContent.innerHTML = `<div class="asset-card-placeholder">A estratégia mudou. Clique em 'Criar Esboço' novamente.</div>`;
    }

    const scriptContainer = document.getElementById('scriptSectionsContainer');
    if (scriptContainer) {
        scriptContainer.innerHTML = `
            <div id="introSection" class="script-section"></div>
            <div id="developmentSection" class="script-section"></div>
            <div id="climaxSection" class="script-section"></div>
            <div id="conclusionSection" class="script-section"></div>
            <div id="ctaSection" class="script-section hidden"></div>
        `;
    }
    
    // 3. Reseta os botões de geração para o estado inicial
    const buttonsToReset = [
        'generateOutlineBtn', 'generateIntroBtn', 'generateDevelopmentBtn', 
        'climaxBtn', 'conclusionBtn', 'generateCTABtn', 
        'generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn'
    ];
    
    buttonsToReset.forEach(id => {
        const btn = document.getElementById(id);
        const floatBtn = document.getElementById(`float_${id}`);
        [btn, floatBtn].forEach(b => {
            if (b) {
                b.classList.remove('btn-success');
                // Adiciona a classe correta (primary ou secondary)
                if (['generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn', 'generateOutlineBtn'].includes(id)) {
                    b.classList.add('btn-secondary');
                } else {
                    b.classList.add('btn-primary');
                }
            }
        });
    });

    // 4. Atualiza a UI e notifica o usuário
    updateProgressBar();
    updateButtonStates();
    const sourceLabel = document.querySelector(`label[for='${sourceId}']`)?.textContent || sourceId;
    window.showToast(`'${sourceLabel}' mudou. O roteiro foi resetado.`);
};


/**
 * Invalida e limpa os prompts de imagem de uma seção quando seu texto é alterado.
 * @param {HTMLElement} sectionElement - O elemento da seção (ex: o div com id="introSection").
 */
const invalidateAndClearPrompts = (sectionElement) => {
    if (!sectionElement) return;

    const sectionId = sectionElement.id;
    const promptContainer = sectionElement.querySelector('.prompt-container');

    // 1. Remove os prompts da memória (do estado global)
    if (allImagePrompts[sectionId]) {
        delete allImagePrompts[sectionId];
        console.log(`Prompts para a seção '${sectionId}' invalidados e removidos da memória.`);
    }
    
    // 2. Limpa a interface do usuário, se os prompts já foram renderizados
    if (promptContainer && promptContainer.innerHTML.trim() !== '') {
        promptContainer.innerHTML = `
            <div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border-l-4 border-yellow-400">
                <p class="text-sm text-yellow-700 dark:text-yellow-300 font-semibold">
                    Atenção: O roteiro foi modificado.
                </p>
                <p class="text-xs text-yellow-600 dark:text-yellow-400 mt-1">
                    Por favor, clique em "Gerar Prompts de Imagem" novamente para criar novos recursos visuais com base no texto atualizado.
                </p>
            </div>
        `;
    }
};


/**
         * Invalida e limpa a sugestão de performance, exibindo um aviso.
         */
        const invalidateAndClearPerformance = (sectionElement) => {
            if (!sectionElement) return;

            const performanceContainer = sectionElement.querySelector('.section-performance-output');
            if (performanceContainer && performanceContainer.innerHTML.trim() !== '') {
                performanceContainer.innerHTML = `
                    <div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border-l-4 border-yellow-400">
                        <p class="text-sm text-yellow-700 dark:text-yellow-300 font-semibold">
                            Atenção: O roteiro foi modificado.
                        </p>
                        <p class="text-xs text-yellow-600 dark:text-yellow-400 mt-1">
                            Por favor, clique em "Sugerir Performance" novamente para criar novas anotações com base no texto atualizado.
                        </p>
                    </div>
                `;
            }
        };

        /**
         * Lida com os cliques nas setas de navegação dos prompts.
         * @param {string} sectionElementId - O ID da seção.
         * @param {number} direction - -1 para a esquerda, 1 para a direita.
         */
        window.navigatePrompts = (sectionElementId, direction) => {
            const prompts = allImagePrompts[sectionElementId] || [];
            const itemsPerPage = 4;
            const totalPages = Math.ceil(prompts.length / itemsPerPage);
            let currentPage = promptPaginationState[sectionElementId] || 0;

            const newPage = currentPage + direction;

            // Validação dos limites
            if (newPage >= 0 && newPage < totalPages) {
                promptPaginationState[sectionElementId] = newPage;
                renderPaginatedPrompts(sectionElementId);
            }
        };
    
// =========================================================================
// >>>>> PASSO 1: SUBSTITUA A FUNÇÃO generateSectionHtmlContent INTEIRA POR ESTA VERSÃO <<<<<
// =========================================================================

// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO generateSectionHtmlContent INTEIRA POR ESTA <<<<<
// =========================================================================

const generateSectionHtmlContent = (sectionId, title, content) => {
    // ---- PASSO 1: Criar os Elementos Principais (esqueleto) ----
    const accordionItem = document.createElement('div');
    accordionItem.className = 'accordion-item card !p-0 mb-4 animate-fade-in';

    const accordionHeader = document.createElement('div');
    accordionHeader.className = 'accordion-header';

    const accordionBody = document.createElement('div');
    accordionBody.id = `${sectionId}Body`;
    accordionBody.className = 'accordion-body';

    // ---- PASSO 2: Construir o CABEÇALHO (Header) peça por peça ----
    const headerTitleGroup = document.createElement('div');
    headerTitleGroup.className = 'header-title-group';
    const h3 = document.createElement('h3');
    h3.textContent = title;
    const timeSpan = document.createElement('span');
    timeSpan.className = 'text-xs font-normal text-gray-500';
    timeSpan.textContent = calculateReadingTime(content);
    headerTitleGroup.appendChild(h3);
    headerTitleGroup.appendChild(timeSpan);

    const headerActionsGroup = document.createElement('div');
    headerActionsGroup.className = 'header-actions-group';
    const headerButtons = document.createElement('div');
    headerButtons.className = 'header-buttons';

    const regenerateBtn = document.createElement('button');
    regenerateBtn.className = 'regenerate-btn';
    regenerateBtn.title = 'Re-gerar esta seção';
    regenerateBtn.dataset.action = 'regenerate';
    regenerateBtn.dataset.sectionId = `${sectionId}Section`;
    regenerateBtn.innerHTML = DOMPurify.sanitize(`<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/></svg>`);

    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-btn';
    copyBtn.title = 'Copiar Roteiro';
    copyBtn.dataset.action = 'copy';
    copyBtn.innerHTML = DOMPurify.sanitize(`<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5-.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg>`);
    headerButtons.appendChild(regenerateBtn);
    headerButtons.appendChild(copyBtn);

    const arrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    arrowSvg.id = `${sectionId}Arrow`;
    arrowSvg.setAttribute('class', 'accordion-arrow');
    arrowSvg.setAttribute('width', '16');
    arrowSvg.setAttribute('height', '16');
    arrowSvg.setAttribute('fill', 'currentColor');
    arrowSvg.setAttribute('viewBox', '0 0 16 16');
    arrowSvg.innerHTML = DOMPurify.sanitize(`<path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>`);
    
    headerActionsGroup.appendChild(headerButtons);
    headerActionsGroup.appendChild(arrowSvg);
    accordionHeader.appendChild(headerTitleGroup);
    accordionHeader.appendChild(headerActionsGroup);

    // ---- PASSO 3: Construir o CORPO (Body) ----
    const contentWrapper = document.createElement('div');
    contentWrapper.className = 'generated-content-wrapper';
    contentWrapper.setAttribute('contenteditable', 'true');
    contentWrapper.innerHTML = DOMPurify.sanitize(content);

    const analysisTools = document.createElement('div');
    const addChapterButtonHtml = sectionId === 'development' ? `<button class="btn btn-primary btn-small" data-action="addDevelopmentChapter"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8.5 4.5a.5.5 0 0 0-1 0v3h-3a.5.5 0 0 0 0 1h3v3a.5.5 0 0 0 1 0v-3h3a.5.5 0 0 0 0-1h-3v-3z"/></svg> Adicionar Capítulo</button>` : '';
    
    const toolsHtml = `
        <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700 space-y-6">
            <div class="text-center">
                <h5 class="font-semibold text-base mb-2 text-gray-800 dark:text-gray-200">Passo 1: Diagnóstico e Criativo</h5>
                <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Analise, edite ou enriqueça o texto para máxima qualidade.</p>
                <div class="flex items-center justify-center gap-2 flex-wrap">
                    <button class="btn btn-secondary btn-small" data-action="analyzeRetention" data-section-id="${sectionId}Section">Analisar Retenção</button>
                    <button class="btn btn-secondary btn-small" data-action="refineStyle">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-gem" viewBox="0 0 16 16"><path d="M3.1.7a.5.5 0 0 1 .4-.2h9a.5.5 0 0 1 .4.2l2.976 3.974c.149.199.224.458.224.726v1.2a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5v-1.2c0-.268.075-.527.224-.726L3.1.7zM1.49 4.107l-1.18-1.575a.5.5 0 0 1 .4-.8h13.56a.5.5 0 0 1 .4.8L14.51 4.107H1.49zM.5 5.5a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1 0-1H1v-1H.5a.5.5 0 0 1 0-1H1v-1H.5a.5.5 0 0 1 0-1H1v-1H.5a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v7a.5.5 0 0 1 0 1h-.5a.5.5 0 0 1 0-1H15v-1h-.5a.5.5 0 0 1 0-1H15v-1h-.5a.5.5 0 0 1 0-1H15v-1h.5a.5.5 0 0 1 .5-.5v-1a.5.5 0 0 1-.5.5zM2 13.5a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg>
                        Refinar Estilo
                    </button>
                    <button class="btn btn-secondary btn-small" data-action="enrichWithData">
                         <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8.5 2a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-1 0v-11a.5.5 0 0 1 .5-.5z"/><path d="M2 7.5a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg>
                        Enriquecer com Dados
                    </button>
                    ${addChapterButtonHtml}
                </div>
                <div id="analysis-output-${sectionId}" class="section-analysis-output mt-3 text-left"></div>
            </div>
            <div class="pt-4 border-t border-dashed border-gray-200 dark:border-gray-700 text-center">
                 <h5 class="font-semibold text-base mb-2 text-gray-800 dark:text-gray-200">Passo 2: Estrutura de Narração</h5>
                <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Adicione sugestões de performance para guiar a narração.</p>
                <div class="flex items-center justify-center gap-2"><button class="btn btn-secondary btn-small" data-action="suggestPerformance" data-section-id="${sectionId}Section">Sugerir Performance</button></div>
                <div class="section-performance-output mt-3 text-left"></div> 
            </div>
            <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700 text-center">
                <h5 class="font-semibold text-base mb-2 text-gray-800 dark:text-gray-200">Passo 3: Recursos Visuais</h5>
                <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Crie o storyboard visual para esta seção do roteiro.</p>
                <button class="btn btn-secondary btn-small" data-action="generate-prompts" data-section-id="${sectionId}Section">Gerar Prompts de Imagem</button>
                <div class="prompt-container mt-4 text-left"></div>
            </div>
        </div>
    `;
    analysisTools.innerHTML = DOMPurify.sanitize(toolsHtml, { ADD_TAGS: ["svg", "path"], ADD_ATTR: ["d", "fill", "viewBox", "xmlns", "width", "height", "class"] });
    
    accordionBody.appendChild(contentWrapper);
    accordionBody.appendChild(analysisTools);
    accordionItem.appendChild(accordionHeader);
    accordionItem.appendChild(accordionBody);

    return accordionItem;
};

    
        // ==========================================================
        // >>>>> SUBSTITUA SUA FUNÇÃO cleanGeneratedText INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
        // ==========================================================
        const cleanGeneratedText = (text, expectJson = false) => {
            if (!text) return null;
            if (!expectJson) return text.trim();

            const startIndex = text.search(/[\{\[]/);
            if (startIndex === -1) {
                console.error("Nenhum caractere de início JSON ('{' ou '[') encontrado no texto da IA.", text);
                throw new Error("A IA não retornou um formato JSON reconhecível.");
            }
            const firstChar = text[startIndex];
            const matchingLastChar = firstChar === '{' ? '}' : ']';
            let level = 1;
            let endIndex = -1;
            for (let i = startIndex + 1; i < text.length; i++) {
                if (text[i] === firstChar) level++;
                if (text[i] === matchingLastChar) level--;
                if (level === 0) {
                    endIndex = i;
                    break;
                }
            }
            if (endIndex === -1) {
                console.warn("JSON não foi fechado corretamente, tentando encontrar o final de forma aproximada.");
                endIndex = text.length;
            }
            
            let jsonString = text.substring(startIndex, endIndex + 1);
            let sanitizedJsonString = jsonString.replace(/[\u0000-\u001F\u007F-\u009F\u200B-\u200F\uFEFF]/g, '');

            try {
                return JSON.parse(sanitizedJsonString);
            } catch (e) {
                console.warn("Parse inicial (sanitizado) falhou. Tentando reparos estruturais...", e.message);
                try {
                    let repairedString = sanitizedJsonString;

                    // >>>>> CIRURGIA INTELIGENTE DE ASPAS <<<<<
                    // 1. Garante que todas as chaves (keys) estejam com aspas duplas.
                    repairedString = repairedString.replace(/([{,]\s*)'([^']+)'(\s*:)/g, '$1"$2"$3');
                    repairedString = repairedString.replace(/([{,]\s*)([a-zA-Z0-9_]+)(\s*:)/g, '$1"$2"$3');

                    // 2. Troca aspas simples por duplas APENAS em valores que são strings completas.
                    // Isso preserva as aspas simples dentro das strings.
                    repairedString = repairedString.replace(/:\s*'([^']*)'/g, ': "$1"');

                    // 3. Remove vírgulas extras no final de objetos/arrays.
                    repairedString = repairedString.replace(/,\s*([}\]])/g, "$1");
                    
                    return JSON.parse(repairedString);
                } catch (finalError) {
                    console.error("Falha ao fazer o parse do JSON, mesmo após todas as cirurgias:", finalError.message);
                    console.error("JSON problemático (original):", text);
                    throw new Error("A IA retornou um JSON com sintaxe interna inválida que não pôde ser corrigido.");
                }
            }
        };


                /**
         * Remove comentários meta da IA do texto gerado. (VERSÃO BLINDADA)
         * @param {string} text - O texto gerado pela IA.
         * @returns {string} O texto sem os comentários meta.
         */
// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO removeMetaComments INTEIRA POR ESTA <<<<<
// =========================================================================

const removeMetaComments = (text) => {
    if (!text) return "";
    
    let cleanedText = text.trim();

    // CAMADA 1: Remove preâmbulos comuns que terminam com ":"
    const lines = cleanedText.split('\n');
    if (lines.length > 1 && lines[0].trim().endsWith(':')) {
        lines.shift();
        cleanedText = lines.join('\n').trim();
    }

    // CAMADA 2: Usa regex para remover padrões específicos e indesejados
    const patternsToRemove = [
        // Padrões genéricos que já tínhamos
        /Here is the (generated )?script for the "[^"]+" section:\s*\n?/gi,
        /^\*\*roteiro anotado:\*\*\s*\n?/im,
        /^\*\*Introdução:\*\*\s*\n?/im,
        /^\*\*Desenvolvimento:\*\*\s*\n?/im,
        /^\*\*Clímax:\*\*\s*\n?/im,
        /^\*\*Conclusão:\*\*\s*\n?/im,
        /^\*\*TEXTO REFINADO:\*\*\s*\n?/im,
        
        // "Caçador de Títulos" genérico
        /^\s*\*\*[^*]+\*\*\s*$/gm,

        // <<< NOSSO NOVO "CAÇADOR DE METADADOS" AQUI >>>
        // Remove linhas que começam com "Word count:" e variações
        /^\s*Word count:\s*\d+\s*$/gim
    ];

    patternsToRemove.forEach(pattern => {
        cleanedText = cleanedText.replace(pattern, '');
    });
    
    // CAMADA 3: Limpeza final
    if (cleanedText.startsWith('"') && cleanedText.endsWith('"')) {
        cleanedText = cleanedText.substring(1, cleanedText.length - 1);
    }

    // Remove quebras de linha extras no início ou no final do texto
    return cleanedText.replace(/^\s*\n|\n\s*$/g, '');
};

        // --- INÍCIO DO NOVO MÓDULO DE NARRATIVA ---

        const narrativeStructures = {
            storytelling: {
                documentary: "Documentário (Factual e Investigativo)",
                heros_journey: "Jornada do Herói (Estrutura Épica)",
                pixar_spine: "Espinha Dorsal - Pixar (Estrutura Emocional)",
                mystery_loop: "Mistério (com Loop Aberto)",
                twist: "Narrativa com Virada (Twist)"
            },
            storyselling: {
                underdog_victory: "Vitória do Vira-lata (Conexão e Superação)",
                discovery_mentor: "A Grande Descobrir / Mentor Secreto",
                if_not_found_create: "Não Encontrei, Então Criei (História de Origem)",
                pas: "Problema-Agitação-Solução (PAS)",
                bab: "Antes-Depois-Ponte (BAB)"
            }
        };

        const narrativeTooltips = {
            documentary: "Constrói um argumento com fatos, evidências e uma narração autoritária. Perfeito para vídeos expositivos.",
            heros_journey: "Conta uma história de transformação e superação. Ótimo para narrativas inspiradoras.",
            pixar_spine: "Estrutura emocional de 8 passos (Era uma vez... todo dia... até que...). Pergunta para arcos de personagem rápidos.",
            mystery_loop: "Apresenta uma pergunta no início e a responde no final. Excelente para reter a atenção.",
            twist: "Constrói uma expectativa e a quebra com uma revelação surpreendente no final.",
            underdog_victory: "Mostra alguém com limitações que venceu contra tudo e todos. Gera alta conexão emocional.",
            discovery_mentor: "Revela um grande segredo ou uma descoberta que mudou tudo. Posição de autoridade.",
            if_not_found_create: "Conta a história de origem de um produto ou serviço criado a partir de uma necessidade pessoal.",
            pas: "Foca em um problema que o público tem, agita a dor e apresenta a solução. Perfeito para vendas diretas.",
            bab: "Mostra um cenário 'antes' (o problema), um 'depois' (o resultado ideal) e seu conteúdo como 'a ponte' para chegar lá."
        };


   // ==========================================================
// >>>>> AÇÃO 1: SUBSTITUA A FUNÇÃO updateMainTooltip INTEIRA <<<<<
// ==========================================================
const updateMainTooltip = () => {
    const popoverTitle = document.getElementById('popoverTitle');
    const popoverDescription = document.getElementById('popoverDescription');
    const structureSelect = document.getElementById('narrativeStructure');

    if (!popoverTitle || !popoverDescription || !structureSelect) return;

    // AQUI ESTÁ A CORREÇÃO:
    // Se nenhuma opção estiver selecionada (selectedIndex === -1), a função para aqui.
    if (structureSelect.selectedIndex === -1) {
        // Opcional: Limpa o popover para não mostrar informação antiga.
        popoverTitle.textContent = "Selecione uma Estrutura";
        popoverDescription.textContent = "Passe o mouse sobre uma opção para ver sua descrição.";
        return; 
    }

    const selectedKey = structureSelect.value;
    const selectedText = structureSelect.options[structureSelect.selectedIndex].text;
    const descriptionText = narrativeTooltips[selectedKey] || "Descrição não encontrada.";
    
    popoverTitle.textContent = selectedText;
    popoverDescription.textContent = descriptionText;
};

        const updateNarrativeStructureOptions = () => {
    const goalSelect = document.getElementById('narrativeGoal');
    const structureSelect = document.getElementById('narrativeStructure');
    if (!goalSelect || !structureSelect) return;

    const goal = goalSelect.value;
    const savedValue = structureSelect.value; // Salva o valor atual, se houver
    structureSelect.innerHTML = ''; 

    const structures = narrativeStructures[goal];
    for (const key in structures) {
       const option = document.createElement('option');
        option.value = key;
       option.textContent = structures[key];
       structureSelect.appendChild(option);
   }
    
 // Tenta restaurar o valor que estava selecionado
    if (Array.from(structureSelect.options).some(opt => opt.value === savedValue)) {
        structureSelect.value = savedValue;
    }
    
    // Chama a nossa nova função para atualizar o texto do tooltip!
   updateMainTooltip();
 };


// =========================================================================
// >>>>> BLOCO 1: SUBSTITUA SUA FUNÇÃO getBasePromptContext INTEIRA POR ESTA <<<<<
// =========================================================================
/**
 * Constrói o contexto base do prompt, agora incluindo o gancho emocional e dados de pesquisa.
 */
const getBasePromptContext = () => {
    // Coleta todos os valores dos campos do formulário
    const channelName = document.getElementById('channelName')?.value.trim() || "";
    const videoTheme = document.getElementById('videoTheme')?.value.trim() || "";
    const targetAudience = document.getElementById('targetAudience')?.value.trim() || "";
    const language = document.getElementById('languageSelect')?.value || "en";
    const languageStyle = document.getElementById('languageStyle')?.value || "";
    const videoObjective = document.getElementById('videoObjective')?.value || "";
    const speakingPace = document.getElementById('speakingPace')?.value || "";
    const narrativeStructure = document.getElementById('narrativeStructure')?.value || "";
    const narrativeTheme = document.getElementById('narrativeTheme')?.value.trim() || "";
    const narrativeTone = document.getElementById('narrativeTone')?.value || ""; // Crucial para a nova lógica
    const narrativeVoice = document.getElementById('narrativeVoice')?.value.trim() || "";
    const shockingEndingHook = document.getElementById('shockingEndingHook')?.value.trim() || "";
    const videoDescription = document.getElementById('videoDescription')?.value.trim() || "";
    const centralQuestion = document.getElementById('centralQuestion')?.value.trim() || "";
    const emotionalArc = document.getElementById('emotionalArc')?.value.trim() || "";
    const imageDescriptionEngine = document.getElementById('imageDescriptionEngine')?.value.trim() || "";
    const imageStyleSelect = document.getElementById('imageStyleSelect')?.value || "";
    const customImageStyle = document.getElementById('customImageStyle')?.value.trim() || "";
    const researchData = document.getElementById('researchData')?.value.trim() || "";
    const emotionalHook = document.getElementById('emotionalHook')?.value.trim() || "";

    // Monta o prompt base
    let context = `
    You are an expert YouTube scriptwriter and researcher for the channel "${channelName}".
    Your goal is to create highly engaging, credible, and emotionally resonant video content.
    
    **Core Project Details:**
    - Video Topic: "${videoTheme}"
    - Target Audience: "${targetAudience}"
    - Language: "${language}"
    - Video Objective: "${videoObjective}"
                        
    **Narrative & Style Instructions:**
    - Narrative Structure to use: "${narrativeStructure}"
    - Speaking Pace: "${speakingPace}"
    `;

    if (narrativeTheme) { context += `\n- Core Theme (The Big Idea): "${narrativeTheme}"`; }
    if (narrativeTone) { context += `\n- Narrative Tone (The Feeling): "${narrativeTone}"`; }
    if (narrativeVoice) { context += `\n- Narrator's Voice (The Personality): "${narrativeVoice}"`; }
    if (shockingEndingHook) { context += `\n- Shocking Ending Hook to use: "${shockingEndingHook}"`; }
    if (videoDescription) { context += `\n\n**Additional Information & Inspiration:**\n- Inspiration/Context: "${videoDescription}"`; }
    if (centralQuestion) { context += `\n- Central Question to guide the entire script: "${centralQuestion}"`; }
    if (emotionalArc) { context += `\n- Desired Emotional Arc: "${emotionalArc}"`; }

    // <<< AQUI ESTÁ A LÓGICA CONDICIONAL INTELIGENTE (v6.0) >>>
    if (emotionalHook) {
        if (narrativeTone === 'inspirador') {
            // Nova instrução poderosa para histórias inspiradoras
            context += `

**PROFUNDIDADE EMOCIONAL (REGRA MAIS IMPORTANTE):**
A história a seguir é a âncora emocional do nosso roteiro. Para que ela não pareça superficial, você DEVE "mostrar, não apenas contar".
- **Crie 'Cenas' Vívidas:** Ao longo do roteiro, em vez de apenas citar o personagem, descreva pequenos momentos e cenas.
- **Mostre a Dificuldade:** Inclua uma pequena cena ou descrição do personagem enfrentando um obstáculo real. (Ex: estudando até tarde, recebendo uma notícia ruim).
- **Mostre a Superação:** Inclua uma pequena cena ou descrição do momento de virada ou pequena vitória do personagem. (Ex: recebendo o e-mail de aprovação, vendo o primeiro resultado positivo).
- **Conecte o Micro ao Macro:** Use essas pequenas cenas para ilustrar os grandes temas do roteiro.

**Âncora Emocional:** "${emotionalHook}"
---
`;
        } else {
            // Instrução original, que funciona bem para drama e outros tons
            context += `

**CRITICAL NARRATIVE ANCHOR (THE MOST IMPORTANT RULE):**
You MUST use the following personal story as the emotional core and recurring 'human anchor' for the entire script. Weave references to this character/story throughout the introduction, development, and conclusion to make the grand historical narrative feel personal and relatable. This is the guiding thread of the story.
---
Emotional Anchor Story: "${emotionalHook}"
---
`;
        }
    }

    if (researchData) {
        context += `
**CRITICAL RESEARCH DATA & CONTEXT:**
You MUST incorporate and properly attribute the following facts, names, and sources into the script...
---
${researchData}
---
`;
    }

    if (imageStyleSelect === 'cinematic' || imageStyleSelect === 'custom') {
        context += `\n\n**Visual Style Instructions:**...`;
    }

    return context;
};


// =========================================================================
// >>>>> SUBSTITUA SUA FUNÇÃO constructScriptPrompt INTEIRA PELA VERSÃO FINAL E COMPLETA <<<<<
// =========================================================================
        /**
         * Constrói o prompt específico para cada secção do roteiro ou tipo de conteúdo.
         * @param {string} sectionName - O nome da secção (ex: 'intro', 'titles_thumbnails').
         * @param {string} sectionTitle - O título da secção para o prompt.
         * @param {string|null} outlineDirective - Uma diretriz específica do esboço estratégico para esta secção.
         * @returns {{prompt: string, maxTokens: number}} O prompt e o limite de tokens.
         */

const constructScriptPrompt = (sectionName, sectionTitle, outlineDirective = null, contextText = null) => {
    const baseContext = getBasePromptContext();
    const videoDuration = document.getElementById('videoDuration').value;
    const selectedLanguage = document.getElementById('languageSelect').value;
    const narrativeStructure = document.getElementById('narrativeStructure').value;

    const targetWords = wordCountMap[videoDuration]?.[sectionName];
    let durationInstruction = '';
    if (targetWords) {
        durationInstruction = `\n\n**CRITICAL TIMING CONSTRAINT:** The generated text for this section MUST be approximately **${targetWords} words** long to fit the video's schedule. This is a strict requirement.`;
    }

    let prompt = `${baseContext}

Você é um mestre roteirista de YouTube. Sua tarefa é escrever o texto para a seção **"${sectionTitle}"** do roteiro.
    ${durationInstruction}

**REGRAS CRÍTICAS E INEGOCIÁVEIS:**
1.  **FOCO TOTAL:** Sua resposta deve ser APENAS e SOMENTE o texto para a seção **"${sectionTitle}"**.
2.  **SEM EXTRAS:** É estritamente proibido incluir preâmbulos (como "Aqui está a introdução:"), resumos, traduções ou qualquer outro texto que não seja o próprio roteiro. A violação desta regra resultará em falha.
3.  **FORMATO LIMPO:** Não inclua rótulos de cena, de áudio ou de narrador (como [CENA], (Música sobe), Narrador:). Apenas o texto a ser falado.

**NOVA REGRA PERMANENTE: MAESTRO DO RITMO NARRATIVO**
A partir de agora, você deve agir como um "Maestro do Ritmo". Sua escrita precisa ser dinâmica e cativante, não monótona. Para isso, você DEVE:
- **Variar o Comprimento das Frases:** Alterne entre frases curtas e diretas (para criar impacto e tensão) e frases mais longas e complexas (para descrever ou aprofundar um conceito).
- **Usar Perguntas Retóricas:** Ocasionalmente, faça perguntas diretas ao espectador para provocar reflexão e aumentar o engajamento. (Ex: "Mas o que isso realmente significava?", "Você consegue imaginar a cena?").
- **Criar Pausas Dramáticas:** Use parágrafos muito curtos, às vezes de uma única frase, para criar pausas e dar peso a uma revelação.
`;

    if (contextText) {
        prompt += `
**INSTRUÇÃO DE CONTINUIDADE (A REGRA MAIS IMPORTANTE):**
Você está escrevendo a continuação de um roteiro. O texto abaixo é da seção ANTERIOR.
- **NÃO REPITA** as ideias, frases ou o tom da seção anterior.
- Sua tarefa é **AVANÇAR A NARRATIVA**. Comece de onde o texto anterior parou.
- Introduza novas informações, aprofunde os argumentos ou inicie o próximo ponto da história.

**TEXTO DA SEÇÃO ANTERIOR (PARA CONTEXTO):**
---
${contextText}
---

Agora, escreva a seção "${sectionTitle}", garantindo que seja uma continuação fluida e sem repetições.`;
    }

    if (outlineDirective) {
        prompt += `\n\n**IMPORTANT STRATEGIC GUIDELINE:** For this specific section, you MUST follow this strategic plan: "${outlineDirective}"`;
    }

    prompt += `\n\nIMPORTANT: Do NOT include any scene descriptions, visual/audio cues (e.g., [SHOT], (Camera pan), (Music swells)), or speaker labels (e.g., "Narrator:", "Host:") in the generated script content. Provide only the spoken text.`;
    prompt += `\n\nABSOLUTELY NO META-COMMENTS. Do not add any explanatory text about the script itself. Your entire response must be ONLY the text to be spoken in the video, and nothing else.`;

    if (document.getElementById('centralQuestion').value.trim()) {
        prompt += `\nIf a 'Central Question' is provided, ensure every section of the script (Introduction, Development, Climax) directly contributes to exploring or answering this question. The entire video must revolve around this central theme.`;
    }
    
    // >>> BLOCO AGORA 100% COMPLETO, SEM ABREVIAÇÕES OU PLACEHOLDERS <<<
    switch (narrativeStructure) {
        case 'documentary':
            prompt += `\n\nNARRATIVE STYLE: As this is a 'Documentary', prioritize factual accuracy, a clear timeline, and an authoritative tone. Build your case with evidence and logical progression.`;
            break;
        case 'heros_journey':
            prompt += `\n\nNARRATIVE STYLE: Following the 'Hero's Journey', structure this section around the hero's call to adventure, trials, or transformation. Emphasize the conflict and growth.`;
            break;
        case 'pixar_spine':
            prompt += `\n\nNARRATIVE STYLE: Following the 'Pixar Spine', structure this section to follow the emotional beats of "Once upon a time... Every day... Until one day... Because of that... Until finally...".`;
            break;
        case 'mystery_loop':
            prompt += `\n\nNARRATIVE STYLE: Following the 'Mystery Loop', if this is the introduction, pose the central mystery. If it's the development, add clues and false leads. If it's the conclusion, provide the satisfying answer.`;
            break;
        case 'twist':
            prompt += `\n\nNARRATIVE STYLE: For a 'Twist' narrative, build a clear expectation throughout the script, only to subvert it dramatically in the climax or conclusion.`;
            break;
        case 'underdog_victory':
            prompt += `\n\nNARRATIVE STYLE: For 'Underdog Victory', emphasize the struggles, the lack of resources, and the immense odds the protagonist is facing. Make the audience root for them.`;
            break;
        case 'discovery_mentor':
            prompt += `\n\nNARRATIVE STYLE: For 'Discovery/Mentor', position the narrative as a secret being revealed. Use phrases like "The secret that nobody tells you..." or "What if I told you...".`;
            break;
        case 'if_not_found_create':
            prompt += `\n\nNARRATIVE STYLE: For 'If Not Found, Create', tell the origin story. Focus on the personal frustration and the 'aha!' moment that led to the creation of the solution.`;
            break;
        case 'pas':
            prompt += `\n\nNARRATIVE STYLE: Using 'Problem-Agitate-Solve', this section should clearly define a pain point (Problem), intensify the negative emotions associated with it (Agitate), or present the clear solution (Solve).`;
            break;
        case 'bab':
            prompt += `\n\nNARRATIVE STYLE: Using 'Before-After-Bridge', paint a vivid picture of the negative 'Before' state, the ideal 'After' state, or present the content as the 'Bridge' to get there.`;
            break;
    }

    let maxTokens = 2000;

    switch (sectionName) {
        case 'outline':
            prompt = `${baseContext}

Você é um mestre roteirista e estrategista de conteúdo. Sua tarefa é criar um "beat sheet" ou um esboço estratégico detalhado para o vídeo.

**REGRAS DE FORMATAÇÃO (INEGOCIÁVEIS):**
1.  Responda APENAS com um objeto JSON.
2.  O objeto deve conter chaves para: "introduction", "development", "climax", "conclusion", e "cta".
3.  O valor de cada chave deve ser uma string descrevendo o objetivo daquela seção.

**REGRA DE SINTAXE CRÍTICA:**
- **Certifique-se de que cada valor de string no JSON comece e termine com aspas duplas (\`).** É estritamente proibido misturar aspas simples e duplas ou esquecer de fechar uma string corretamente.

**EXEMPLO DE FORMATO PERFEITO:**
{
  "introduction": "Começar com uma pergunta retórica chocante sobre a mortalidade.",
  "development": "Construir a narrativa explorando o luto das irmãs de Lázaro.",
  "climax": "O momento de maior tensão no túmulo.",
  "conclusion": "Resumir a lição: o milagre não é sobre desafiar a morte, mas sobre o poder da fé.",
  "cta": "Fazer uma chamada para ação suave."
}
`;
            maxTokens = 2000;
            break;

        // =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA O "case 'intro':" INTEIRO POR ESTE BLOCO <<<<<
// =========================================================================

        // =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA O "case 'intro':" INTEIRO PELA VERSÃO CORRIGIDA <<<<<
// =========================================================================

        case 'intro':
            const shockingHook = document.getElementById('shockingEndingHook')?.value.trim();
            
            prompt += `

**INSTRUÇÕES CRÍTICAS PARA A INTRODUÇÃO (ESTILO YOUTUBE VIRAL):**
Sua tarefa é escrever a **Introdução** do vídeo. O objetivo é criar um "hook" magnético que prenda a atenção do espectador nos primeiros 15-30 segundos.`;

            // <<< AQUI ESTÁ A LÓGICA CONDICIONAL INTELIGENTE >>>
            if (shockingHook) {
                prompt += `

**REGRA DE HOOK PRIORITÁRIA (A MAIS IMPORTANTE):**
Você DEVE começar o roteiro EXATAMENTE com a seguinte frase fornecida pelo usuário no campo 'Desfecho Chocante'. NÃO adicione nada antes dela. Após usar esta frase, construa o resto da introdução para criar um profundo mistério sobre como a história chegou a este ponto.
**Frase Obrigatória:** "${shockingHook}"`;
            } else {
                prompt += `

**REGRAS DE CONTEÚDO (HOOK VIRAL):**
1.  **PROIBIDO COMEÇO LENTO:** Você DEVE começar de uma das seguintes formas (escolha a mais impactante para o tema):
    - **In Media Res:** Comece no meio do momento de maior ação ou tensão da história.
    - **Estatística Chocante:** Apresente um dado ou estatística surpreendente e contra-intuitivo.
    - **Pergunta Provocativa:** Faça uma pergunta direta e pessoal que crie uma conexão imediata com o espectador.
2.  **CRIE UM LOOP ABERTO:** Após o impacto inicial, você DEVE fazer uma promessa clara ou uma pergunta intrigante que só será totalmente respondida no final do vídeo. Crie um mistério.`;
            }

            prompt += `
**REGRAS GERAIS PARA A INTRODUÇÃO:**
- Seja conciso e direto. Use frases curtas e poderosas.
- O foco é criar curiosidade e urgência para que o espectador continue assistindo.`;

            if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                prompt += `\n**IMPORTANTE: Todo o texto DEVE ser em Português.**`;
            }

            maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 500;
            break;

       case 'development':
            prompt += `

**INSTRUÇÕES CRÍTICAS PARA O DESENVOLVIMENTO (ESTILO YOUTUBE VIRAL):**
Sua tarefa é escrever o **Desenvolvimento** do roteiro. Esta é a seção mais longa, onde você aprofunda o tema. O objetivo principal aqui é **manter a RETENÇÃO** do espectador a todo custo.

**REGRAS DE CONTEÚDO E RITMO (RETENÇÃO E ENGAJAMENTO):**
1.  **ESTRUTURA EM BLOCOS:** Apresente as informações em blocos temáticos claros e lógicos. Cada bloco deve explorar um aspecto do tema.
2.  **GANCHOS DE RETENÇÃO (A REGRA MAIS IMPORTANTE):** Para evitar que o texto fique monótono ou denso, você DEVE, a cada 2 ou 3 parágrafos de informação, inserir um "gancho de retenção". Este gancho serve para quebrar o padrão e re-engajar o espectador. Use uma das seguintes técnicas:
    - **Teaser / Loop Aberto:** Crie um mini-mistério que será respondido em breve. (Ex: "...mas eles não sabiam que a parte mais difícil ainda estava por vir.", "E a solução que ele encontrou para isso é a razão pela qual esta empresa vale bilhões hoje.").
    - **Pergunta de Engajamento:** Faça uma pergunta direta ao público relacionada ao conteúdo, incentivando a participação nos comentários. (Ex: "O que você teria feito nessa situação? Deixa sua opinião aqui nos comentários.", "Você já conhecia esse fato? Me conta aqui embaixo.").
3.  **EQUILÍBRIO E CONTEXTO:** Mantenha o equilíbrio entre fornecer informações valiosas e manter a narrativa fluida. Sempre conecte os dados de volta à história principal ou ao gancho emocional (se houver).`;

            if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                prompt += `\n**IMPORTANTE: Todo o texto DEVE ser em Português.**`;
            }
            maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 1500;
            break;

        case 'climax':
            prompt += `
            The climax should be the most impactful part of the video, revealing key insights, surprising twists, or the most compelling evidence related to the video theme. It should be dramatic and leave the viewer with a sense of awe or profound understanding.
            `;
            if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
            }
            maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 500;
            break;

        case 'conclusion':
            prompt += `
            The conclusion should summarize the main points, provide a final thought or reflection, and leave the viewer with a lasting impression. Ensure the conclusion is complete and well-rounded, providing a sense of closure.
            `;
            if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
            }
            maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 500;
            break;

        case 'cta':
            prompt += `
            The Call to Action (CTA) should be clear and concise, encouraging viewers to subscribe, like, comment, or share. It should be compelling and feel like a natural conclusion to the video, **but ensure it is a complete and well-rounded paragraph.**
            `;
            maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 400;
            break;

case 'titles_thumbnails':
            prompt = `${baseContext}
Você é uma API de geração de metadados que retorna APENAS um objeto JSON.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`{\` e terminando com \`}\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar aspas duplas (\`"\`).
3.  **ESTRUTURA OBRIGATÓRIA:** O objeto JSON DEVE conter EXATAMENTE duas chaves principais: "titles" e "thumbnails".
    - O valor de "titles" DEVE ser um array de 5 strings.
    - O valor de "thumbnails" DEVE ser um array de 3 objetos.
    - Cada objeto em "thumbnails" DEVE ter exatamente duas chaves: "title" e "description".
4.  **SEM ASPAS INTERNAS:** Dentro dos valores de string (como "description"), NÃO use aspas duplas. Use aspas simples (\`'\`) se precisar de ênfase.

**EXEMPLO DE RESPOSTA PERFEITA:**
{
  "titles": [
    "Título 1: Curto e impactante",
    "Título 2: Com pergunta",
    "Título 3: Com urgência",
    "Título 4: Focado em benefício",
    "Título 5: Controverso"
  ],
  "thumbnails": [
    { "title": "Ideia de Thumbnail 1", "description": "Close-up em um objeto misterioso com uma seta vermelha." },
    { "title": "Ideia de Thumbnail 2", "description": "Foto de uma pessoa com expressão chocada e texto 'VOCÊ NÃO VAI ACREDITAR'." },
    { "title": "Ideia de Thumbnail 3", "description": "Gráfico de 'Antes vs Depois' mostrando uma transformação." }
  ]
}

Analise o contexto do roteiro e gere o objeto JSON seguindo TODAS as regras.`;
            maxTokens = 2000; // Aumentado para dar espaço para a IA
            break;

        case 'description':
            const languageName = new Intl.DisplayNames([selectedLanguage], { type: 'language' }).of(selectedLanguage);
            prompt = `${baseContext}
            
            Sua tarefa é gerar uma descrição otimizada para um vídeo do YouTube e um conjunto de hashtags relevantes, no idioma ${languageName}.
            
            **REGRAS DE FORMATAÇÃO (INEGOCIÁVEIS):**
            1.  Comece com 2-3 frases que resumem o vídeo e incluem as palavras-chave principais do tema.
            2.  Adicione um parágrafo que aprofunde o que o espectador aprenderá ou descobrirá.
            3.  Finalize a descrição com uma chamada para ação (inscrever-se, comentar, etc.).
            4.  Após a descrição, adicione uma linha em branco e depois a seção "Hashtags:".
            5.  Liste 10 hashtags relevantes, começando com a mais ampla e terminando com as mais específicas.
            
            Responda APENAS com a descrição e as hashtags, nada mais.`;
            maxTokens = 700;
            break;
    }
    
    return { prompt, maxTokens };
};

        /**
         * Faz uma chamada à API Groq através de uma função Netlify.
         * @param {string} prompt - O prompt a ser enviado para a IA.
         * @param {number} maxTokens - O número máximo de tokens para a resposta.
         * @returns {Promise<string>} A resposta bruta da IA.
         * @throws {Error} Se a chamada à API falhar.
         */
        const callGroqAPI = async (prompt, maxTokens) => {
            const proxyUrl = "/.netlify/functions/groq"; // Endpoint do proxy

            const payload = {
                prompt: prompt,
                maxTokens: maxTokens
            };

            const request = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetch(proxyUrl, request);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Erro desconhecido do servidor proxy.' } }));
                    throw new Error(`Erro na API via Proxy: ${errorData.error?.message || 'Erro do servidor'}`);
                }
                const result = await response.json();
                const rawContent = result.choices?.[0]?.message?.content;
                if (rawContent) { return rawContent; }
                else { throw new Error("Resposta inesperada da API Groq."); }
            } catch (error) {
                console.error("Fetch da API via Netlify Function falhou:", error);
                window.showToast(`Falha na API: ${error.message}`);
                throw error;
           }
        };

        /**
         * Valida os inputs essenciais antes de gerar conteúdo.
         * @returns {boolean} True se os inputs são válidos, caso contrário, false.
         */
             
        /**
         * Itera sobre todas as seções do roteiro na ordem correta,
         * renumera globalmente todas as cenas E recalcula o timestamp
         * com base na duração estimada pela IA para cada cena.
         */
        
    
        /**
         * Escapa um objeto JSON para ser usado com segurança dentro de um atributo onclick.
         * @param {object} idea - O objeto da ideia a ser escapado.
         * @returns {string} Uma string JSON segura para HTML.
         */
        const escapeIdeaForOnclick = (idea) => {
            // Primeiro, converte o objeto para uma string JSON
            const jsonString = JSON.stringify(idea);
            // Em seguida, substitui os caracteres que quebram o HTML
            // Escapa aspas duplas, aspas simples e barras invertidas
            return jsonString.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/\\/g, '&#92;');
        };

        // ==========================================================
        // ===== COLE ESTA FUNÇÃO FALTANTE NO SEU JAVASCRIPT =====
        // ==========================================================
        /**
         * Lida com a visibilidade da barra de ação flutuante com base na posição de rolagem.
         */
        window.handleFloatingActionBar = () => {
            const bar = document.getElementById('floatingActionBar');
            // O gatilho para a barra aparecer será a grade de inputs principais
            const triggerElement = document.getElementById('mainInputsTabs'); 

            if (!bar || !triggerElement) {
                return; // Sai da função se os elementos não existirem
            }

            // Ponto de gatilho: quando o final do 'mainInputsGrid' passar pelo topo da tela
            const triggerPoint = triggerElement.offsetTop + triggerElement.offsetHeight;

            if (window.scrollY > triggerPoint) {
                bar.classList.add('visible');
            } else {
                bar.classList.remove('visible');
            }
        };





        // =========================================================================
// >>>>> AÇÃO 1: SUBSTITUA A FUNÇÃO createScriptSectionPlaceholder COMPLETA <<<<<
// =========================================================================
/**
 * Cria e retorna o HTML de um placeholder para uma seção do roteiro.
 * @param {string} sectionId - O ID base da seção (ex: 'intro').
 * @param {string} title - O título da seção (ex: 'Introdução').
 * @param {string} buttonId - O ID do botão principal que gera esta seção (ex: 'generateIntroBtn').
 * @returns {string} O HTML do placeholder da seção.
 */


const createScriptSectionPlaceholder = (sectionId, title, buttonId, actionName) => {
    const containerId = `${sectionId}Section`;
    
    return `
        <div id="${containerId}" class="script-section card card-placeholder mb-4 animate-fade-in flex justify-between items-center">
            <h3 class="font-semibold text-lg text-gray-700 dark:text-gray-300">${title}</h3>
            <button id="${buttonId}" data-action="${actionName}" class="btn btn-primary">
                <i class="fas fa-magic mr-2"></i>Gerar
            </button>
        </div>
    `;
};



// =========================================================================
// >>>>> VERSÃO FINAL DE addDevelopmentChapter COM PROMPT "ANTI-ECO" <<<<<
// =========================================================================
/**
 * Adiciona um novo capítulo ao desenvolvimento, com prompt refinado para evitar repetição do título e "ecos".
 * @param {HTMLElement} button - O botão que foi clicado.
 */
window.addDevelopmentChapter = async (button) => {
    const devSection = document.getElementById('developmentSection');
    const contentWrapper = devSection?.querySelector('.generated-content-wrapper');
    const existingText = contentWrapper?.textContent.trim();

    if (!existingText) {
        window.showToast("Gere o desenvolvimento inicial primeiro.");
        return;
    }

    showButtonLoading(button);

    try {
        const suggestionPrompt = `Você é um Estrategista de Roteiro. Baseado no roteiro abaixo, sugira 3 temas distintos e lógicos para o próximo capítulo. Responda APENAS com um array JSON de 3 strings.

        ROTEIRO ATUAL:
        ---
        ${existingText.slice(-2000)}
        ---
        
        Exemplo de resposta: ["A Batalha dos Números", "O Legado Fora de Campo", "Momentos Decisivos"]`;

        const rawSuggestions = await callGroqAPI(suggestionPrompt, 300);
        const chapterSuggestions = cleanGeneratedText(rawSuggestions, true) || [];
        
        hideButtonLoading(button);

        const chapterTheme = await showInputDialog(
            'Adicionar Novo Capítulo',
            'Escolha uma sugestão da IA ou digite seu próprio tema abaixo.',
            'Ou crie um tema personalizado:',
            'Digite seu tema aqui...',
            chapterSuggestions
        );

        if (!chapterTheme) {
            window.showToast("Operação cancelada.");
            return;
        }

        showButtonLoading(button);

        const basePrompt = getBasePromptContext();
        const continuationPrompt = `${basePrompt}
        
Você é um roteirista de documentários investigativos. Sua tarefa é escrever um novo capítulo para um roteiro existente.

**TEMA OBRIGATÓRIO PARA ESTE CAPÍTULO:** "${chapterTheme}"

**INSTRUÇÃO CRÍTICA DE CONTINUIDADE:**
- O texto abaixo é o roteiro escrito até agora. **NÃO REPITA** as informações contidas nele.
- Sua tarefa é escrever um novo capítulo que avance a narrativa, focado **EXCLUSIVAMENTE** no tema "${chapterTheme}".

**REGRA DE FORMATAÇÃO (MUITO IMPORTANTE):**
- Sua resposta deve ser APENAS o texto do roteiro.
- **NÃO inclua o título do capítulo ("${chapterTheme}") ou qualquer outro subtítulo no corpo do texto.** Apenas o conteúdo a ser falado.

// ==========================================================
// >>>>> AQUI ESTÁ A NOVA REGRA "ANTI-ECO" <<<<<
// ==========================================================
**REGRA DE FOCO (A MAIS IMPORTANTE):**
- Mantenha um tom **factual e investigativo** durante todo o capítulo.
- Concentre-se em apresentar informações, eventos e a narrativa específica do tema "${chapterTheme}".
- **É ESTRITAMENTE PROIBIDO adicionar conclusões gerais, opiniões pessoais, sermões ou chamadas para ação genéricas no final do capítulo.** Deixe as conclusões e as chamadas para mudança para a seção final do roteiro.
// ==========================================================

**ROTEIRO ESCRITO ATÉ AGORA (PARA CONTEXTO):**
---
${existingText}
---

Agora, escreva o novo capítulo sobre "${chapterTheme}", seguindo TODAS as regras.`;

        const rawResult = await callGroqAPI(continuationPrompt, 4000);
        const newChapter = removeMetaComments(rawResult.trim());
        
        const chapterTitleHtml = `<div class="font-bold text-lg mt-4 mb-2">Capítulo: ${chapterTheme}</div>`;
        
        const existingParagraphsCount = contentWrapper.querySelectorAll('div[id]').length;
        const newParagraphs = newChapter.split('\n').filter(p => p.trim() !== '');
        const newContentWithDivs = newParagraphs.map((p, index) => 
            `<div id="development-p-${existingParagraphsCount + index}">${p}</div>`
        ).join('');

        contentWrapper.insertAdjacentHTML('beforeend', chapterTitleHtml + newContentWithDivs);
        
        invalidateAndClearPerformance(devSection);
        invalidateAndClearPrompts(devSection);
        updateAllReadingTimes();
        
        window.showToast("Novo capítulo adicionado com sucesso!");
        contentWrapper.lastElementChild.scrollIntoView({ behavior: 'smooth', block: 'center' });

    } catch (error) {
        window.showToast(`Falha ao adicionar capítulo: ${error.message}`);
        console.error("Erro detalhado em continuationPrompt:", error);
    } finally {
        hideButtonLoading(button);
    }
};



        /**
         * Escapa uma string de texto plano para ser usada em um documento RTF,
         * lidando corretamente com caracteres non-ASCII e especiais.
         * @param {string} text - O texto a ser escapado.
         * @returns {string} O texto formatado para RTF.
         */
        const escapeRtf = (text) => {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                // Escapa caracteres especiais do RTF
                if (charCode === 92 || charCode === 123 || charCode === 125) { // Backslash, {, }
                    result += '\\' + text.charAt(i);
                }
                // Converte caracteres non-ASCII para o formato hexadecimal do RTF
                else if (charCode > 127) {
                    let hex = charCode.toString(16);
                    if (hex.length < 2) {
                        hex = '0' + hex;
                    }
                    result += "\\'" + hex;
                }
                // Mantém caracteres ASCII padrão
                else {
                    result += text.charAt(i);
                }
            }
            return result;
        };

        // ==========================================================
        // ================== FUNÇÕES PRINCIPAIS ====================
        // ==========================================================
        
            const handleSuggestionMouseOver = (event) => {
            const targetParagraph = event.currentTarget;
            const suggestionGroupText = targetParagraph.dataset.suggestionGroup;
            if (!suggestionGroupText) return;

            const contentWrapper = targetParagraph.closest('.generated-content-wrapper');
            if (!contentWrapper) return;
            
            // >>>>> AQUI ESTÁ A CORREÇÃO CRÍTICA <<<<<
            // Escapa as aspas duplas no texto da sugestão antes de usá-lo no seletor
            const safeSuggestionSelector = suggestionGroupText.replace(/"/g, '\\"');

            // Encontra todos os parágrafos com a mesma sugestão (usando o seletor seguro) e os destaca
            contentWrapper.querySelectorAll(`[data-suggestion-group="${safeSuggestionSelector}"]`).forEach(p => {
                p.classList.add('highlight-group');
            });
        };

        const handleSuggestionMouseOut = (event) => {
            const targetParagraph = event.currentTarget;
            const contentWrapper = targetParagraph.closest('.generated-content-wrapper');
            if (!contentWrapper) return;
            
            // Remove o destaque de todos os parágrafos
            contentWrapper.querySelectorAll('.highlight-group').forEach(p => {
                p.classList.remove('highlight-group');
            });
        };

window.analyzeSectionRetention = async (button, sectionId) => {
    const sectionElement = document.getElementById(sectionId);
    const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');

    if (!contentWrapper || !contentWrapper.textContent.trim()) {
        window.showToast("Gere o roteiro desta seção antes de analisar a retenção.");
        return;
    }

    const paragraphs = Array.from(contentWrapper.querySelectorAll('div[id]'));
    if (paragraphs.length === 0) {
        window.showToast("Não há parágrafos para analisar.");
        return;
    }

    showButtonLoading(button);

    try {
        const paragraphsWithIndexes = paragraphs.map((p, index) => ({ index: index, text: p.textContent.trim() }));
        
        // >>> PROMPT BLINDADO COM A NOVA REGRA DE ASPAS INTERNAS <<<
        const prompt = `Você é uma API de análise de retenção que retorna um array JSON.

**REGRAS CRÍTICAS DE SINTAXE (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON.
2.  **ESTRUTURA COMPLETA:** Sua resposta DEVE começar com um colchete de abertura \`[\` e, OBRIGATORIAMENTE, terminar com um colchete de fechamento \`]\`.
3.  **ASPAS DUPLAS EXTERNAS:** TODAS as chaves (ex: "suggestion") E todos os valores de texto (strings) DEVEM usar aspas duplas (\`"\`).
4.  **ASPAS SIMPLES INTERNAS (A REGRA MAIS IMPORTANTE):** Se você precisar usar aspas DENTRO de uma string de "suggestion", você DEVE, OBRIGATORIAMENTE, usar aspas simples (\`'\`). É estritamente proibido usar aspas duplas dentro de outra string.
5.  **VÍRGULA FINAL:** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último objeto.
6.  **OBJETO COMPLETO:** Cada objeto no array deve conter EXATAMENTE as três chaves: "paragraphIndex", "retentionScore" ("green", "yellow", ou "red"), e "suggestion" (em Português-Brasil).

**DADOS PARA ANÁLISE:**
${JSON.stringify(paragraphsWithIndexes, null, 2)}

Analise os dados e retorne o array JSON completo e sintaticamente perfeito.`;

        const rawResult = await callGroqAPI(prompt, 4000);
        let analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis)) throw new Error("Análise da IA em formato inválido.");

        // LÓGICA DE UNIFICAÇÃO (permanece a mesma)
        if (analysis.length > 0) {
            let currentGroup = [];
            for (let i = 0; i < analysis.length; i++) {
                const currentItem = analysis[i];
                const previousItem = i > 0 ? analysis[i - 1] : null;

                if (previousItem && currentItem.retentionScore === previousItem.retentionScore && currentItem.retentionScore !== 'green') {
                    currentGroup.push(currentItem);
                } else {
                    if (currentGroup.length > 1) {
                        const unifiedSuggestion = currentGroup[0].suggestion;
                        currentGroup.forEach(groupItem => groupItem.suggestion = unifiedSuggestion);
                    }
                    currentGroup = [currentItem];
                }
            }
            if (currentGroup.length > 1) {
                const unifiedSuggestion = currentGroup[0].suggestion;
                currentGroup.forEach(groupItem => groupItem.suggestion = unifiedSuggestion);
            }
        }

        const newParagraphs = paragraphs.map(p => {
            const newP = p.cloneNode(true);
            newP.className = '';
            newP.innerHTML = DOMPurify.sanitize(p.innerHTML.replace(/<div class="retention-tooltip">.*?<\/div>|<button class="retention-action-btn optimize-btn">.*?<\/button>/g, ''));
            p.parentNode.replaceChild(newP, p);
            return newP;
        });

        analysis.forEach((item, index) => {
            const p = newParagraphs[item.paragraphIndex];
            if (p) {
                p.classList.add('retention-paragraph-live', `retention-${item.retentionScore}`);
                p.dataset.suggestionGroup = item.suggestion;

                if (item.retentionScore === 'yellow' || item.retentionScore === 'red') {
                    const previousItem = index > 0 ? analysis[index - 1] : null;
                    if (!previousItem || item.suggestion !== previousItem.suggestion) {
                        const scoreLabels = { yellow: "PONTO DE ATENÇÃO", red: "PONTO DE RISCO" };
                        const tooltipTitle = scoreLabels[item.retentionScore] || 'ANÁLISE';

                        const suggestionTextEscaped = item.suggestion
                            .replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/`/g, '\\`');

                 const buttonsHtml = `
    <div class="flex gap-2 mt-3">
        <button class="flex-1 btn btn-primary btn-small py-1" 
                data-action="optimizeGroup" 
                data-suggestion-text="${suggestionTextEscaped}">
            <i class="fas fa-magic mr-2"></i> Otimizar
        </button>
        <button class="flex-1 btn btn-danger bg-red-600 hover:bg-red-700 btn-small py-1" 
                data-action="deleteParagraphGroup" 
                data-suggestion-text="${suggestionTextEscaped}">
            <i class="fas fa-trash-alt mr-2"></i> Deletar
        </button>
    </div>
`;
                        const tooltipHtml = `<div class="retention-tooltip"><strong>${tooltipTitle}:</strong> ${item.suggestion}${buttonsHtml}</div>`;
                        p.innerHTML += DOMPurify.sanitize(tooltipHtml);
                    }
                }
            }
        });

        newParagraphs.forEach(p => {
            if (p.dataset.suggestionGroup) {
                p.addEventListener('mouseover', handleSuggestionMouseOver);
                p.addEventListener('mouseout', handleSuggestionMouseOut);
            }
        });

        window.showToast("Análise de retenção concluída!");
    } catch (error) {
        console.error("Erro detalhado em analyzeSectionRetention:", error);
        window.showToast(`Falha na análise: ${error.message}`);
    } finally {
        hideButtonLoading(button);
    }
};

/**
         * Pega um parágrafo, otimiza com IA e substitui seu conteúdo.
         * (VERSÃO CORRIGIDA E ANEXADA AO 'WINDOW')
         */
        window.optimizeParagraph = async (paragraphId, suggestion) => {
            const paragraphElement = document.getElementById(paragraphId);
            if (!paragraphElement) return;

            const button = paragraphElement.querySelector('.retention-action-btn');
            if (button) {
                button.disabled = true;
                button.innerHTML = `<div class="loading-spinner" style="width:16px; height:16px; border-width: 2px;"></div>`;
            }

            const originalText = paragraphElement.firstChild.textContent.trim();
            const languageName = document.getElementById('languageSelect').options[document.getElementById('languageSelect').selectedIndex].text;
            const prompt = `You are an expert copywriter. Rewrite the "Original Paragraph" below based on the "Improvement Suggestion".
        
            **CRITICAL RULE: You MUST respond in ${languageName}.** Do not change the language.

             **Original Paragraph:**
             "${originalText}"

              **Improvement Suggestion:**
               "${suggestion}"

           Respond ONLY with the rewritten paragraph, in ${languageName}.`;

            try {
                const rewrittenText = await callGroqAPI(prompt, 1000);
                paragraphElement.firstChild.textContent = removeMetaComments(rewrittenText);
                
                // Feedback visual
                paragraphElement.classList.remove('retention-yellow', 'retention-red');
                paragraphElement.classList.add('retention-green');
                paragraphElement.querySelector('.retention-tooltip')?.remove();
                button?.remove();
                
                invalidateAndClearPrompts(paragraphElement.closest('.script-section'));
                invalidateAndClearPerformance(paragraphElement.closest('.script-section'));

                window.showToast("Parágrafo otimizado!");
            } catch (error) {
                window.showToast(`Falha ao otimizar: ${error.message}`);
                console.error("Erro detalhado em optimizeParagraph:", error);
                if (button) button.innerHTML = '⚠️'; // Ícone de erro
            }
        };
    
         // ==========================================================
        // >>>>> SUBSTITUA SUA FUNÇÃO suggestPerformance INTEIRA POR ESTA VERSÃO <<<<<
        // ==========================================================
        window.suggestPerformance = async (button, sectionId) => {
    const sectionElement = document.getElementById(sectionId);
    const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');
    const outputContainer = sectionElement?.querySelector('.section-performance-output');

    if (!contentWrapper || !contentWrapper.textContent.trim() || !outputContainer) {
        window.showToast("Gere o roteiro desta seção primeiro.");
        return;
    }

    showButtonLoading(button);
    outputContainer.innerHTML = `<div class="loading-spinner-small mx-auto my-4"></div>`;
    
    try {
        const paragraphElements = Array.from(contentWrapper.querySelectorAll('div[id]'));
        const originalParagraphs = paragraphElements.map(p => p.textContent.trim().replace(/\[.*?\]/g, '').trim());

        if (originalParagraphs.length === 0) { throw new Error("Não foram encontrados parágrafos estruturados para análise."); }

        const batchSize = 15;
        const apiPromises = [];

        for (let i = 0; i < originalParagraphs.length; i += batchSize) {
            const paragraphBatch = originalParagraphs.slice(i, i + batchSize);
            let promptContext = '';
            paragraphBatch.forEach((p, indexInBatch) => {
                const globalIndex = i + indexInBatch;
                promptContext += `Parágrafo ${globalIndex}: "${p}"\n\n`;
            });

            // ==========================================================
            // >>>>> INÍCIO DA MUDANÇA NO PROMPT <<<<<
            // ==========================================================
            const prompt = `Você é uma API de análise de roteiro. Sua resposta DEVE ser um array JSON.

**REGRAS DE FORMATAÇÃO (INEGOCIÁVEIS E CRÍTICAS):**
1.  Sua resposta final DEVE ser um array JSON válido, começando com \`[\` e terminando com \`]\`.
2.  Sua resposta NÃO PODE conter nenhum texto, comentário ou explicação antes ou depois do JSON.
3.  O array deve conter EXATAMENTE ${paragraphBatch.length} objetos.
4.  Cada objeto DEVE ter duas chaves: "general_annotation" (uma string) e "emphasis_words" (um array com no máximo 1 string).
5.  **REGRA DA VÍRGULA (A MAIS IMPORTANTE):** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último. Exemplo: \`[ { ... }, { ... } ]\`
6.  **VERIFICAÇÃO FINAL:** Antes de responder, verifique se cada objeto JSON \`{...}\` está completamente fechado com sua chave \`}\` antes da próxima vírgula ou do colchete final \`]\`.

**EXEMPLO DE RESPOSTA PERFEITA:**
[
  {
    "general_annotation": "[Tom de surpresa]",
    "emphasis_words": ["inacreditável"]
  },
  {
    "general_annotation": "[Tom de suspense]",
    "emphasis_words": ["segredo"]
  }
]

Analise os ${paragraphBatch.length} parágrafos a seguir e retorne o array JSON, seguindo TODAS as regras.

**ROTEIRO (LOTE ATUAL):**
${promptContext}`;
            // ==========================================================
            // >>>>> FIM DA MUDANÇA NO PROMPT <<<<<
            // ==========================================================

            apiPromises.push(callGroqAPI(prompt, 3000).then(res => cleanGeneratedText(res, true)));
        }

        const allBatchResults = await Promise.all(apiPromises);
        const annotations = allBatchResults.flat();

        if (!Array.isArray(annotations) || annotations.length !== originalParagraphs.length) { 
            console.error(`Falha na contagem: JS esperava ${originalParagraphs.length} anotações, mas a IA retornou ${annotations ? annotations.length : 0}.`);
            throw new Error("A IA não retornou o número correto de anotações após juntar os lotes."); 
        }
        
        let annotatedParagraphs = [];
        originalParagraphs.forEach((p, index) => {
            const annotationData = annotations[index];
            let annotatedParagraph = p;

            if (annotationData && annotationData.emphasis_words && Array.isArray(annotationData.emphasis_words) && annotationData.emphasis_words.length > 0) {
                annotationData.emphasis_words.forEach(word => {
                    const escapedWord = word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    const wordRegex = new RegExp(`\\b(${escapedWord})\\b`, 'gi');
                    annotatedParagraph = annotatedParagraph.replace(wordRegex, `[ênfase em '${word}']$1`);
                });
            }
            const finalParagraph = `${annotationData.general_annotation || ''}\n${annotatedParagraph}`;
            annotatedParagraphs.push(finalParagraph.trim());
        });

        const finalAnnotatedText = annotatedParagraphs.join('\n');
        
        const originalTextForAudit = originalParagraphs.join('\n');
        const { isValid } = auditGeneratedText(originalTextForAudit.replace(/\n/g, ' '), finalAnnotatedText.replace(/\n/g, ' '));

        if (!isValid) { throw new Error("Falha crítica na auditoria interna. O texto foi corrompido durante a montagem."); }
        
        const highlightedText = finalAnnotatedText.replace(/(\[.*?\])/g, '<span class="text-indigo-500 dark:text-indigo-400 font-semibold italic">$1</span>');

        outputContainer.innerHTML = `
            <div class="card-background p-4 mt-2 rounded-lg border-l-4 border-indigo-500">
                <h5 class="font-bold text-sm mb-2 text-gray-700 dark:text-gray-200">Sugestão de Performance:</h5>
                <div class="performance-output-scrollable">
                    <p class="text-gray-800 dark:text-gray-200 leading-relaxed whitespace-pre-wrap">${highlightedText}</p>
                </div>
            </div>`;

        if (sectionElement) { invalidateAndClearPrompts(sectionElement); }

    } catch (error) {
        outputContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao sugerir performance: ${error.message}</p>`;
        console.error("Erro detalhado em auditGeneratedText:", error);
    } finally {
        hideButtonLoading(button);
    }
};


// =========================================================================
// >>>>> SUBSTITUA A FUNÇÃO 'window.refineSectionStyle' INTEIRA POR ESTA VERSÃO SEGURA <<<<<
// =========================================================================

/**
 * Pega o texto de uma seção, pede para a IA refinar o estilo (remover repetições, melhorar fluidez)
 * e substitui o conteúdo original pelo texto refinado.
 * @param {HTMLElement} buttonElement - O botão "Refinar Estilo" que foi clicado.
 */
window.refineSectionStyle = async (buttonElement) => {
    showButtonLoading(buttonElement);

    const sectionElement = buttonElement.closest('.script-section');
    if (!sectionElement) {
        window.showToast("Erro: Seção do roteiro não encontrada.");
        hideButtonLoading(buttonElement);
        return;
    }

    const contentWrapper = sectionElement.querySelector('.generated-content-wrapper');
    const originalText = contentWrapper?.textContent.trim();

    if (!originalText) {
        window.showToast("Não há texto para refinar nesta seção.");
        hideButtonLoading(buttonElement);
        return;
    }

    const prompt = `Você é um Editor de Estilo (Copy Editor) de elite. Sua tarefa é reescrever o texto a seguir para melhorar sua qualidade, fluidez e impacto, sem alterar o significado, o tom ou a mensagem central.

**TEXTO ORIGINAL:**
---
${originalText}
---

**REGRAS DE REFINAMENTO (INEGOCIÁVEIS):**
1.  **Elimine Repetições:** Identifique e remova palavras e estruturas de frases repetitivas. Use sinônimos e varie a construção das sentenças.
2.  **Melhore a Fluidez:** Conecte as ideias de forma mais suave e lógica. Garanta que o texto flua bem quando lido em voz alta.
3.  **Mantenha a Essência:** NÃO adicione novas informações, opiniões ou mude o significado original. Seu trabalho é polir, não recriar.
4.  **RESPOSTA LIMPA:** Sua resposta deve ser APENAS o texto refinado. Sem preâmbulos, comentários ou explicações.`;

    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const refinedText = removeMetaComments(rawResult);

        const newParagraphs = refinedText.split('\n').filter(p => p.trim() !== '');
        const sectionId = sectionElement.id.replace('Section', '');
        
        // Constrói o novo HTML
        const newHtml = newParagraphs.map((p, index) => 
            `<div id="${sectionId}-p-${index}">${p}</div>`
        ).join('');

        // <<< AQUI ESTÁ A IMPLEMENTAÇÃO DE SEGURANÇA >>>
        // Sanitiza o HTML antes de inseri-lo no DOM
        contentWrapper.innerHTML = DOMPurify.sanitize(newHtml);

        // Invalida análises anteriores, pois o texto mudou
        invalidateAndClearPerformance(sectionElement);
        invalidateAndClearPrompts(sectionElement);
        const analysisOutput = sectionElement.querySelector('.section-analysis-output');
        if (analysisOutput) {
            analysisOutput.innerHTML = ''; // Limpa a análise de retenção
        }

        // Atualiza o tempo de leitura
        updateAllReadingTimes();

        window.showToast("Estilo do roteiro refinado com sucesso!");

    } catch (error) {
        console.error("Erro detalhado em refineSectionStyle:", error); // Adicionado log de erro
        window.showToast(`Falha ao refinar o estilo: ${error.message}`);
    } finally {
        hideButtonLoading(buttonElement);
    }
};



// =========================================================================
// >>>>> VERSÃO FINAL (v7) - BLINDADA E IDEMPOTENTE <<<<<
// =========================================================================
window.applySuggestion = (button) => {
    const { criterionName, problematicQuote, rewrittenQuote } = button.dataset;
    const sectionId = (window.criterionMap || {})[criterionName];

    if (!sectionId) { /* ... (código de erro) ... */ return; }

    const sectionElement = document.getElementById(sectionId);
    const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');

    if (!contentWrapper) { /* ... (código de erro) ... */ return; }

    let replaced = false;
    const paragraphs = contentWrapper.querySelectorAll('div[id^="' + sectionId.replace('Section','') + '-p-"]');

    paragraphs.forEach(p => {
        if (replaced) return;
        const childNodes = Array.from(p.childNodes);

        for (const node of childNodes) {
            // A condição de busca permanece a mesma
            if (node.nodeType === Node.TEXT_NODE && node.textContent.includes(problematicQuote)) {

                // <<< AQUI ESTÁ A BLINDAGEM QUE FALTAVA >>>
                // Se o texto já foi envolvido por nosso span, não fazemos nada!
                if (node.parentElement.classList.contains('highlight-change')) {
                    console.log("Ação bloqueada: Este trecho já foi substituído e animado.");
                    replaced = true; // Marca como 'replaced' para sair da lógica.
                    break;
                }
                
                // O resto da nossa lógica de transplante de DOM, que já estava correta.
                const originalTextNode = node;
                const text = originalTextNode.textContent;
                const startIndex = text.indexOf(problematicQuote);

                const textBefore = text.substring(0, startIndex);
                const textAfter = text.substring(startIndex + problematicQuote.length);

                const highlightSpan = document.createElement('span');
                highlightSpan.textContent = rewrittenQuote;
                // A classe é aplicada diretamente aqui, sem setTimeout. O problema não era a renderização.
                highlightSpan.className = 'highlight-change'; 

                const nodeBefore = document.createTextNode(textBefore);
                const nodeAfter = document.createTextNode(textAfter);

                const parent = originalTextNode.parentNode;
                
                parent.replaceChild(nodeAfter, originalTextNode);
                parent.insertBefore(highlightSpan, nodeAfter);
                parent.insertBefore(nodeBefore, highlightSpan);

                replaced = true;
                break;
            }
        }
    });

    if (!replaced) {
        // ... (código de erro se não encontrou) ...
        return;
    }
    
    // ... (resto da função: showToast, invalidate, feedback no botão) ...
    // Esta parte já está correta.
    window.showToast("Sugestão aplicada com sucesso!");
    invalidateAndClearPerformance(sectionElement);
    invalidateAndClearPrompts(sectionElement);
    updateAllReadingTimes();

    button.disabled = true;
    button.innerHTML = '<i class="fas fa-check mr-2"></i>Aplicada!';
    button.classList.remove('btn-primary');
    button.classList.add('btn-success');

    setTimeout(() => {
        button.disabled = false;
        button.innerHTML = 'Aplicar';
        button.classList.remove('btn-success');
        button.classList.add('btn-primary');
    }, 5000);
};





// =========================================================================
// >>>>> PASSO 2: SUBSTITUA A FUNÇÃO 'window.enrichWithData' INTEIRA POR ESTA <<<<<
// =========================================================================

window.enrichWithData = async (buttonElement) => {
    const selection = window.getSelection();
    if (selection.rangeCount === 0 || selection.toString().trim() === '') {
        window.showToast("Por favor, selecione primeiro o trecho de texto que deseja enriquecer.");
        return;
    }
    
    userSelectionRange = selection.getRangeAt(0).cloneRange();
    const selectedText = selection.toString().trim();

    const newData = await showInputDialog(
        'Enriquecer com Dados',
        'Cole abaixo o dado, fonte ou exemplo que você quer adicionar ao trecho selecionado.',
        'Nova Informação:',
        'Ex: Fonte: Forbes 2023; Segundo o Dr. especialista...'
    );

    if (!newData) {
        window.showToast("Operação cancelada.");
        userSelectionRange = null;
        return;
    }

    showButtonLoading(buttonElement);
    const sectionElement = buttonElement.closest('.script-section');

    try {
        // <<< O PROMPT FOI COMPLETAMENTE REESCRITO PARA SER À PROVA DE FALHAS >>>
        const prompt = `Você é um Editor de Roteiro de elite. Sua única função é reescrever um trecho de texto para integrar uma nova informação de forma sutil e profissional.

**Trecho Original do Roteiro:**
---
${selectedText}
---

**Nova Informação a ser Integrada:**
---
${newData}
---

**SUA TAREFA (A ÚNICA REGRA):**
Reescreva o "Trecho Original do Roteiro", tecendo a "Nova Informação a ser Integrada" de forma natural e fluida. O resultado final deve ser um parágrafo (ou parágrafos) coeso e bem escrito, que mantenha o tom e a mensagem do texto original, mas agora enriquecido com o novo dado.

**É ESTRITAMENTE PROIBIDO:**
- Apresentar-se ou falar sobre suas habilidades.
- Adicionar qualquer comentário, título ou explicação.
- Desviar-se da tarefa de reescrever o texto.

Responda APENAS com o texto final reescrito.`;

        const rawResult = await callGroqAPI(prompt, 1000);
        const enrichedText = removeMetaComments(rawResult);

        if (userSelectionRange) {
            selection.removeAllRanges();
            selection.addRange(userSelectionRange);
            document.execCommand('insertHTML', false, DOMPurify.sanitize(`<span class="highlight-change">${enrichedText}</span>`));
        }
        
        if (sectionElement) {
            invalidateAndClearPerformance(sectionElement);
            invalidateAndClearPrompts(sectionElement);
        }

        window.showToast("Texto enriquecido com sucesso!");

    } catch (error) {
        console.error("Erro detalhado em enrichWithData:", error);
        window.showToast(`Falha ao enriquecer o texto: ${error.message}`);
    } finally {
        hideButtonLoading(buttonElement);
        userSelectionRange = null;
    }
};

     
// =========================================================================
// >>>>> PASSO 1: SUBSTITUA A FUNÇÃO 'generateVideoIdeas' INTEIRA POR ESTA <<<<<
// =========================================================================
const generateVideoIdeas = async (button) => {
    const nicheDescription = document.getElementById('nicheDescription').value.trim();
    if (!nicheDescription) {
        window.showToast("Por favor, descreva o nicho do seu canal.");
        return;
    }

    const selectedLangCode = document.getElementById('languageSelect').value;
    const languageName = selectedLangCode === 'pt-br' ? 'Português do Brasil' : 'English';

    const outputContainer = document.getElementById('ideasOutput');
    outputContainer.innerHTML = DOMPurify.sanitize(`<div class="md:col-span-2 loading-spinner-small mx-auto my-4"></div>`);

    showButtonLoading(button);

    // PROMPT FINAL E BLINDADO
    const prompt = `Você é uma API Estrategista de Conteúdo que retorna APENAS um array JSON. Sua missão é gerar 6 ideias de vídeo com alto potencial de engajamento para um canal do YouTube.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`[\` e terminando com \`]\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar aspas duplas (\`"\`).
3.  **VÍRGULA FINAL:** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último objeto.
4.  **ESTRUTURA DO OBJETO:** Cada objeto no array DEVE conter EXATAMENTE estas cinco chaves: "title", "angle", "targetAudience", "viralityScore" (um número de 0 a 10), e "videoDescription" (uma string).
5.  **IDIOMA:** Lembre-se, todos os valores de texto devem estar em **${languageName}**.

**MANUAL DE CONTEÚDO (SIGA EXATAMENTE):**
- **"title":** Um título "clickbait" mas inteligente (máximo 70 caracteres).
- **"angle":** O ângulo ou abordagem única em **uma única frase curta e impactante**. (Ex: "Desvendando as estratégias ocultas que os bancos usam para investir seu dinheiro.")
- **"targetAudience":** O público-alvo específico para esta ideia.
- **"viralityScore":** Uma nota de 0 a 10 sobre o potencial de viralidade.
- **"videoDescription":** Uma descrição mais detalhada de **5 a 6 frases substanciais**, otimizada para o YouTube, explicando o que o espectador aprenderá e qual problema será resolvido.

**Nicho/Descrição para analisar:** "${nicheDescription}"

Gere 6 ideias de vídeo seguindo EXATAMENTE as regras e o formato acima.`;

    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const ideas = cleanGeneratedText(rawResult, true);

        if (!ideas || !Array.isArray(ideas) || ideas.length === 0) {
            throw new Error("A IA não retornou ideias no formato esperado.");
        }

        outputContainer.innerHTML = '';

        ideas.forEach((idea, index) => {
            const title = idea.title || "Ideia sem título";
            const displayDescription = idea.videoDescription || idea.angle || "Descrição não disponível.";
            const viralityScore = idea.viralityScore || "N/A";

            const card = document.createElement('div');
            card.className = 'card-background p-4 rounded-lg shadow-md border-l-4 border-indigo-500 animate-fade-in flex flex-col justify-between min-h-[140px]';
            
            const escapedIdea = escapeIdeaForOnclick(idea);
            const cardContent = `
                <div>
                    <div class="flex justify-between items-start gap-4">
                        <h4 class="font-bold text-base text-gray-800 dark:text-gray-200 flex-grow">${index + 1}. ${DOMPurify.sanitize(title)}</h4>
                        <button class="btn btn-primary btn-small flex-shrink-0 py-1 px-3"
                                data-action="select-idea"
                                data-idea='${escapedIdea}'>
                            Usar
                        </button>
                    </div>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">"${DOMPurify.sanitize(displayDescription)}"</p>
                </div>
                <span class="font-bold text-sm text-indigo-500 bg-indigo-100 dark:bg-indigo-900 dark:text-indigo-300 py-1 px-2 rounded self-start mt-3">
                    Potencial: ${DOMPurify.sanitize(String(viralityScore))} / 10
                </span>
            `;
            card.innerHTML = DOMPurify.sanitize(cardContent, { ADD_ATTR: ['data-action', 'data-idea'] });
            outputContainer.appendChild(card);
        });

    } catch (error) {
        console.error("Erro detalhado em generateVideoIdeas:", error);
        if (error.message.includes("A IA não retornou um formato")) {
            outputContainer.innerHTML = DOMPurify.sanitize(`<p class="md:col-span-2 text-yellow-500 text-sm p-4 bg-yellow-900/20 rounded-md border-l-4 border-yellow-400">
                <strong>A IA se recusou a gerar conteúdo para este tema.</strong><br><br>
                Isso geralmente acontece com tópicos considerados sensíveis ou controversos. Tente reformular sua descrição.
            </p>`);
        } else {
            outputContainer.innerHTML = DOMPurify.sanitize(`<p class="md:col-span-2 text-red-500 text-sm">Falha ao gerar ideias: ${error.message}</p>`);
        }
    } finally {
        hideButtonLoading(button);
    }
};



// =========================================================================
// >>>>> PASSO 2: SUBSTITUA A FUNÇÃO 'unravelEnigmas' INTEIRA POR ESTA <<<<<
// =========================================================================
const unravelEnigmas = async (button) => {
    const nicheDescription = document.getElementById('nicheDescription').value.trim();
    if (!nicheDescription) {
        window.showToast("Por favor, descreva o nicho ou um tema bíblico para desvendar.");
        return;
    }

    const selectedLangCode = document.getElementById('languageSelect').value;
    const languageName = selectedLangCode === 'pt-br' ? 'Português do Brasil' : 'English';
    const outputContainer = document.getElementById('ideasOutput');
    outputContainer.innerHTML = DOMPurify.sanitize(`<div class="md:col-span-2 loading-spinner-small mx-auto my-4"></div>`);
    showButtonLoading(button);

    const prompt = `Você é um Teólogo Investigativo e um Mestre em Hermenêutica Bíblica para o canal "The Biblical Unveiling".

**Sua missão é gerar 6 ideias de vídeos que conectem o TEMA FORNECIDO PELO USUÁRIO com enigmas, símbolos e histórias da Bíblia.**

**DIRETIVA PRINCIPAL: FAÇA A CONEXÃO.** Mesmo que o tema do usuário não seja diretamente bíblico (ex: "Mercado Financeiro"), sua tarefa é encontrar paralelos, metáforas, princípios e lições dentro das Escrituras que se apliquem a esse tema. Você deve incluir referências bíblicas (livro, capítulo, versículo) como ponto de partida para a investigação.

Para encontrar ideias únicas, você DEVE usar uma das seguintes **Técnicas Investigativas**:
1.  **Fio Oculto (Cross-Referencing)**
2.  **Lupa Lexical (Análise de Palavras)**
3.  **O Espelho Tipológico (Tipologia)**
4.  **Contexto Histórico Profundo**

**FORMATO DA RESPOSTA:**
Sua resposta DEVE ser um array JSON válido. Cada ideia no array deve ser um objeto com as seguintes chaves:
- "title": (String) Um título curioso e específico.
- "enigma": (String) O mistério central em uma única frase.
- "synopsis": (String) Uma sinopse detalhada de **5 a 6 frases substanciais**, que explica a abordagem do vídeo, os pontos que serão cobertos e qual será a revelação principal.
- "investigative_method": (String) O nome exato da técnica usada.
- "hook_question": (String) Uma pergunta intrigante para os primeiros 15 segundos.

**REGRA CRÍTICA DE IDIOMA:** Todos os valores de texto (title, enigma, synopsis, hook_question) DEVEM ser gerados em **${languageName}**.

**Tema fornecido pelo usuário (para conectar com a Bíblia):** "${nicheDescription}"

Agora, gere as 6 ideias.`;
    
    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const ideas = cleanGeneratedText(rawResult, true);

        if (!ideas || !Array.isArray(ideas) || ideas.length === 0) {
            throw new Error("A IA não retornou ideias de enigmas no formato esperado.");
        }

        outputContainer.innerHTML = '';

        ideas.forEach((idea, index) => {
            const card = document.createElement('div');
            card.className = 'card-background p-4 rounded-lg shadow-md border-l-4 border-purple-500 animate-fade-in flex flex-col justify-between';
            
            const escapedIdea = escapeIdeaForOnclick(idea);
            const cardContent = `
                <div>
                    <div class="flex justify-between items-start gap-4">
                        <h4 class="font-bold text-base text-gray-800 dark:text-gray-200 flex-grow">${index + 1}. ${DOMPurify.sanitize(idea.title)}</h4>
                        <button class="btn btn-primary btn-small flex-shrink-0 py-1 px-3"
                                data-action="select-enigma-idea" 
                                data-idea='${escapedIdea}'>
                            Usar
                        </button>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">${DOMPurify.sanitize(idea.synopsis || idea.enigma)}</p>
                    <p class="text-xs text-purple-600 dark:text-purple-400 font-semibold mt-3">Método: ${DOMPurify.sanitize(idea.investigative_method)}</p>
                </div>
            `;
            card.innerHTML = DOMPurify.sanitize(cardContent, { ADD_ATTR: ['data-action', 'data-idea'] });
            outputContainer.appendChild(card);
        });

    } catch (error) {
        console.error("Erro detalhado em unravelEnigmas:", error);
        outputContainer.innerHTML = DOMPurify.sanitize(`<p class="md:col-span-2 text-red-500 text-sm">Falha ao desvendar enigmas: ${error.message}</p>`);
    } finally {
        hideButtonLoading(button);
    }
};



// =========================================================================
// >>>>> AÇÃO 1: ADICIONE A FUNÇÃO `selectIdea` QUE ESTAVA FALTANDO <<<<<
// =========================================================================
/**
 * Preenche os campos do formulário principal com a ideia de vídeo selecionada.
 * @param {object} idea - O objeto da ideia contendo título, descrição, etc.
 */
const selectIdea = (idea) => {
    // Garante que os campos sejam preenchidos de forma segura, mesmo se a IA não retornar um valor
    document.getElementById('videoTheme').value = idea.title || '';
    document.getElementById('videoDescription').value = idea.videoDescription || '';
    document.getElementById('targetAudience').value = idea.targetAudience || '';

    // Rola a página para que o usuário veja os campos que foram preenchidos
    const targetElement = document.getElementById('inputTabsNav');
    if (targetElement) {
        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    // Notifica o usuário que a ação foi bem-sucedida
    window.showToast("Ideia selecionada! Agora defina a estratégia completa.");
};



// =========================================================================
// >>>>> AÇÃO 2: SUBSTITUA A FUNÇÃO handleGenerateSection COMPLETA <<<<<
// =========================================================================
const handleGenerateSection = async (button, sectionName, sectionTitle, elementId) => {
    if (!validateInputs()) return;
    if (!strategicOutline && sectionName !== 'intro') { // A intro pode ser gerada sem esboço se necessário
        window.showToast("Crie o Esboço Estratégico primeiro!");
        return;
    }
    
    showButtonLoading(button);
    
    const targetSectionElement = document.getElementById(`${elementId}Section`);
    if (targetSectionElement) {
        const analysisOutput = targetSectionElement.querySelector('.section-analysis-output');
        const performanceOutput = targetSectionElement.querySelector('.section-performance-output');
        if (analysisOutput) analysisOutput.innerHTML = '';
        if (performanceOutput) performanceOutput.innerHTML = '';
    }

    try {
        let contextText = null;
        const previousSectionsContent = [];
        const requiredSections = {
            'development': ['introSection'],
            'climax': ['introSection', 'developmentSection'],
            'conclusion': ['introSection', 'developmentSection', 'climaxSection']
        };

        if (requiredSections[sectionName]) {
            for (const reqId of requiredSections[sectionName]) {
                const requiredWrapper = document.querySelector(`#${reqId} .generated-content-wrapper`);
                if (!requiredWrapper || !requiredWrapper.textContent.trim()) {
                    const reqTitle = document.querySelector(`#${reqId} h3`)?.textContent || reqId.replace('Section', '');
                    window.showToast(`Por favor, gere a seção "${reqTitle}" primeiro.`);
                    hideButtonLoading(button);
                    return;
                }
                previousSectionsContent.push(requiredWrapper.textContent.trim());
            }
            contextText = previousSectionsContent.join('\n\n---\n\n');
        }

        const keyMap = { intro: 'introduction', development: 'development', climax: 'climax', conclusion: 'conclusion' };
        const outlineKey = keyMap[sectionName];
        const directive = strategicOutline ? strategicOutline[outlineKey] : null;
        
        const { prompt, maxTokens } = constructScriptPrompt(sectionName, sectionTitle, directive, contextText);
        
        let rawResult = await callGroqAPI(prompt, maxTokens);
        let cleanedResult = removeMetaComments(rawResult.trim());

        const paragraphs = cleanedResult.split('\n').filter(p => p.trim() !== '');
        const contentWithDivs = paragraphs.map((p, index) => 
            `<div id="${elementId}-p-${index}">${p}</div>`
        ).join('');
        
        if (targetSectionElement) {
            // <<< AQUI ESTÁ A CORREÇÃO CRÍTICA >>>
            // Chamamos nossa função segura que retorna um ELEMENTO, não uma string.
            const sectionElement = generateSectionHtmlContent(elementId, sectionTitle, contentWithDivs);
            
            // Limpamos o container e adicionamos o novo elemento usando appendChild.
            targetSectionElement.innerHTML = ''; 
            targetSectionElement.appendChild(sectionElement);
            
            targetSectionElement.classList.remove('card', 'card-placeholder', 'flex', 'justify-between', 'items-center');
        } else {
            console.error(`Elemento alvo com ID '${elementId}Section' não encontrado.`);
            window.showToast("Erro interno: Seção do roteiro não encontrada.");
            return;
        }
        
        if (projectState.hasOwnProperty(sectionName)) {
            projectState[sectionName] = true;
        }

        markButtonAsCompleted(button.id);
        updateButtonStates();

    } catch (error) {
        window.showToast(`Falha ao gerar ${sectionTitle}: ${error.message}`);
        console.error(`Error generating ${sectionTitle}.`, error);
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};





        /**
         * Re-gera o conteúdo de uma secção específica do roteiro.
         * @param {string} sectionName - O nome da secção (ex: 'intro').
         * @param {string} sectionTitle - O título da secção.
         * @param {string} elementId - O ID do elemento HTML da secção.
         */
        // ==========================================================
// FUNÇÃO DE RE-GERAÇÃO CORRIGIDA
// ==========================================================
window.regenerateSection = (fullSectionId) => {
            const sectionName = fullSectionId.replace('Section', '');
            
            const sectionMap = {
    'intro': { title: 'Introdução', elementId: 'intro' },
    'development': { title: 'Desenvolvimento', elementId: 'development' },
    'climax': { title: 'Clímax', elementId: 'climax' },
    'conclusion': { title: 'Conclusão', elementId: 'conclusion' }, // Título corrigido
    'cta': { title: 'Call to Action (CTA)', elementId: 'cta' } // <<< ADICIONADO
};

            const sectionInfo = sectionMap[sectionName];
            
            if (sectionInfo) {
                // Encontra o botão de re-gerar que foi clicado, em vez de um botão antigo
                const button = document.querySelector(`[data-action='regenerate'][data-section-id='${fullSectionId}']`);
                if (button) {
                     handleGenerateSection(button, sectionName, sectionInfo.title, sectionInfo.elementId);
                } else {
                    console.error(`Botão de re-gerar não encontrado para a seção: ${fullSectionId}`);
                }
            } else {
                console.error(`Informações da seção não encontradas para: ${sectionName}`);
            }
        };



// =========================================================================
// >>>>> SUBSTITUA A SUA FUNÇÃO generatePromptsForSection INTEIRA PELA VERSÃO BLINDADA <<<<<
// =========================================================================
window.generatePromptsForSection = async (button, sectionElementId) => {
    const sectionElement = document.getElementById(sectionElementId);
    const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');
    const promptContainer = sectionElement?.querySelector('.prompt-container');

    if (!contentWrapper || !contentWrapper.textContent.trim() || !promptContainer) {
        window.showToast("Gere o conteúdo do roteiro desta seção primeiro.");
        return;
    }
    if (!window.emotionalMap || window.emotionalMap.length === 0) {
        window.showToast("Gere o Mapa Emocional primeiro para criar prompts contextuais.");
        return;
    }

    showButtonLoading(button);
    promptContainer.innerHTML = `<div class="loading-spinner-small mx-auto my-4"></div>`;

    try {
        const allChildren = Array.from(contentWrapper.children);
        const paragraphsWithContext = [];
        let currentChapterTitle = "Contexto Geral";
        allChildren.forEach(child => {
            if (child.classList.contains('font-bold') && child.textContent.includes('Capítulo:')) {
                currentChapterTitle = child.textContent.replace('Capítulo:', '').trim();
            } else if (child.id && child.id.includes('-p-')) {
                paragraphsWithContext.push({
                    text: child.textContent.trim().replace(/\[.*?\]/g, '').trim(),
                    chapter: currentChapterTitle,
                    originalId: child.id
                });
            }
        });

        if (paragraphsWithContext.length === 0) { throw new Error("Não foram encontrados parágrafos estruturados para análise."); }

        const baseIndexMatch = paragraphsWithContext[0]?.originalId.match(/-p-(\d+)$/);
        const baseIndex = baseIndexMatch ? parseInt(baseIndexMatch[1], 10) : 0;
        const batchSize = 3;
        const apiPromises = [];

        const visualPacing = document.getElementById('visualPacing').value;
        const durationMap = {
            'dinamico': '3 e 8',
            'normal': '8 e 15',
            'contemplativo': '15 e 25'
        };
        const durationRange = durationMap[visualPacing] || '3 e 8';

        for (let i = 0; i < paragraphsWithContext.length; i += batchSize) {
            const batch = paragraphsWithContext.slice(i, i + batchSize);
            let promptContextForAI = '';
            batch.forEach((item, indexInBatch) => {
                const globalIndex = i + indexInBatch;
                const mapIndex = baseIndex + globalIndex;
                const emotionalContext = window.emotionalMap[mapIndex] || { emotion: 'Neutro', pace: 'Normal' };
                promptContextForAI += `\nParágrafo ${globalIndex}:\n- Título do Capítulo (Guia Temático): "${item.chapter}"\n- Texto do Parágrafo: "${item.text}"\n- Contexto Emocional: (Emoção: ${emotionalContext.emotion}, Ritmo: ${emotionalContext.pace})`;
            });
            
            // >>> PROMPT BLINDADO COM REGRAS DE SINTAXE EXPLÍCITAS <<<
            const prompt = `Você é uma API de geração de JSON. Sua resposta deve ser APENAS um array JSON.

**REGRAS CRÍTICAS DE SINTAXE (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`[\` e terminando com \`]\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves (ex: "imageDescription") E todos os valores de texto (strings) DEVEM, OBRIGATORIAMENTE, usar aspas duplas (\`"\`). É estritamente proibido usar aspas simples (\`'\`) ou crases (\`\`) para delimitar as strings. A violação desta regra resultará em falha.
3.  **SEM ASPAS INTERNAS:** Dentro dos valores de "imageDescription", NÃO use aspas duplas. Se precisar de ênfase, use aspas simples (\`'\`).
4.  **REVISÃO FINAL:** Antes de responder, revise sua própria saída para garantir que cada string está corretamente aberta e fechada com aspas duplas (\`"\`) e que a sintaxe JSON está perfeita.

**MANUAL DE CONTEÚDO (IGUALMENTE INEGOCIÁVEL):**
1.  **UM OBJETO POR PARÁGRAFO:** Crie um objeto JSON para CADA parágrafo fornecido. O array final deve ter EXATAMENTE ${batch.length} objetos.
2.  **DESCRIÇÃO RICA E DETALHADA:** Para a chave "imageDescription", você DEVE criar uma descrição VÍVIDA e CINEMATOGRÁFICA. É obrigatório incluir detalhes sobre Ângulo da Câmera, Iluminação, Foco e Composição.
3.  **DURAÇÃO REALISTA:** O valor de "estimated_duration" DEVE ser um número entre **${durationRange}**.

**DADOS PARA ANÁLISE (LOTE ATUAL):**
---
${promptContextForAI}
---`;

            apiPromises.push(callGroqAPI(prompt, 4000).then(res => cleanGeneratedText(res, true)));
        }

        const allBatchResults = await Promise.all(apiPromises);
        let allGeneratedPrompts = allBatchResults.flat();

        if (!Array.isArray(allGeneratedPrompts) || allGeneratedPrompts.length < paragraphsWithContext.length) {
            throw new Error("A IA não retornou um prompt para cada parágrafo.");
        }

        const curatedPrompts = allGeneratedPrompts.map((promptData, index) => {
            return {
                scriptPhrase: paragraphsWithContext[index].text,
                imageDescription: promptData.imageDescription || "Falha ao gerar descrição. Tente re-gerar.",
                estimated_duration: promptData.estimated_duration || 5
            };
        });

        allImagePrompts[sectionElementId] = curatedPrompts.map((p) => ({ ...p, styleBlock: CINEMATIC_STYLE_BLOCK }));
        promptPaginationState[sectionElementId] = 0;

        promptContainer.innerHTML = `
            <div class="prompt-pagination-wrapper space-y-4">
                <div class="prompt-nav-container flex items-center justify-center gap-4"></div>
                <div class="prompt-items-container space-y-4"></div>
            </div>
        `;
        renderPaginatedPrompts(sectionElementId);

    } catch (error) {
        promptContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar prompts: ${error.message}</p>`;
        console.error("Erro detalhado em curatedPrompts:", error);
    } finally {
        hideButtonLoading(button);
    }
};



    
        /**
         * Sugere trilhas sonoras para uma secção específica do roteiro.
         * @param {string} sectionId - O ID do elemento HTML da secção (ex: 'introSection').
         */
        window.suggestSoundtrack = async (sectionId) => {
            const sectionElement = document.getElementById(sectionId);
            const scriptContent = sectionElement.querySelector('.generated-content-wrapper').textContent; 
            const soundtrackContainer = sectionElement.querySelector('.soundtrack-container');
            
            if (!scriptContent) {
                window.showToast("Gere o roteiro para esta secção primeiro.");
                return;
            }

            soundtrackContainer.innerHTML = `<div class="loading-spinner-small"></div>`; 

            const prompt = `Você é um especialista em prompts para IAs de geração de música (como Suno/Udio). Sua tarefa é analisar o seguinte trecho de roteiro e criar 3 prompts de texto distintos e detalhados.

            **REGRAS DE FORMATAÇÃO (NÃO NEGOCIÁVEIS):**1.  Sua resposta DEVE SER um array JSON válido.2.  O array deve conter EXATAMENTE 3 strings.3.  CADA string deve ser um parágrafo único, bem escrito e descritivo, pronto para ser colado em uma IA de música. NÃO use chaves, colchetes ou qualquer outra sintaxe de objeto DENTRO da string do prompt.

            **EXEMPLO DE RESPOSTA PERFEITA:**
            ["Generate an epic, cinematic orchestral piece in the style of Hans Zimmer... No vocals or percussion, focus on the emotional intensity of the strings and piano.","Create a contemplative, melancholic ambient track with a slow, mournful tempo... No bright or cheerful notes, focus on the darker, more introspective tones.","Craft an uplifting, inspirational electronic piece with a moderate tempo... avoid any jarring or harsh sounds, focusing on the soaring, inspirational quality of the melody."
            ]

                Agora, use o roteiro abaixo como inspiração para criar 3 prompts seguindo EXATAMENTE este formato.

            Trecho do roteiro para analisar:
                    ---
                ${scriptContent}

                ---`;
            
            try {
                const rawResult = await callGroqAPI(prompt, 500);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const suggestions = JSON.parse(cleanedResult);

                // Adiciona tratamento de erro para garantir que suggestions é um array de strings
                if (!Array.isArray(suggestions) || !suggestions.every(s => typeof s === 'string')) {
                    throw new Error("A IA retornou um formato de trilha sonora inesperado. Esperava um array de strings.");
                }

                soundtrackContainer.innerHTML = ''; // Limpa o spinner
                if (suggestions && suggestions.length > 0) {
                    // Agora envolvemos a lista em um div com as classes corretas para ter um fundo e padding.
                    let suggestionsHtml = '<div class="card-background p-4 rounded-lg shadow-inner">';
                    suggestionsHtml += '<ul class="soundtrack-list">';
                    suggestions.forEach(suggestion => {
                        suggestionsHtml += `<li>${suggestion}</li>`;
                    });
                    suggestionsHtml += '</ul>';
                    suggestionsHtml += '</div>'; 

                    soundtrackContainer.innerHTML = suggestionsHtml;
                } else {
                    soundtrackContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhuma sugestão de trilha sonora foi gerada.</p>';
                }
            } catch (error) {
                soundtrackContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar sugestões: ${error.message}</p>`;
                console.error("Erro detalhado em suggestSoundtrack:", error);
            }
        };

        /**
         * Copia a transcrição para a área de transferência e
         * inicia o download de um arquivo .rtf limpo e com a codificação correta.
         */
        const handleCopyAndDownloadTranscript = () => {
            const transcriptText = getTranscriptOnly();

            if (!transcriptText) {
                window.showToast("Nenhum roteiro para copiar. Gere as seções primeiro.");
                return;
            }

            copyTextToClipboard(transcriptText);
            window.showToast("Transcrição copiada! Download do arquivo .rtf iniciado.");

            const fileName = (document.getElementById('videoTheme').value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro') + '_transcricao.rtf';
            
            // **A CORREÇÃO ESTÁ AQUI:**
            // 1. Escapa o texto para o formato RTF.
            // 2. Substitui as quebras de linha pelo comando de parágrafo do RTF.
            const safeText = escapeRtf(transcriptText);
            const rtfContent = `{\\rtf1\\ansi\\deff0 {\\fonttbl{\\f0 Arial;}}\\f0\\fs24 ${safeText.replace(/\n/g, '\\par\r\n')}}`;
            
            const blob = new Blob([rtfContent], { type: 'application/rtf' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };
    
        /**
         * Gera títulos de vídeo e ideias de thumbnail.
         */
                const generateTitlesAndThumbnails = async (button) => {
            if (!validateInputs()) return;
            showButtonLoading(button);

            try {
                const { prompt, maxTokens } = constructScriptPrompt('titles_thumbnails');
                
                const finalPrompt = prompt + `\n\nCRITICAL RULE: Inside the 'description' strings, you MUST use single quotes ('') for any internal quotes, or properly escape double quotes (\\\"). Failure to do so will result in an invalid JSON. Example: "A text overlay that says 'Hope is Here'".`;
                
                const result = await callGroqAPI(finalPrompt, maxTokens);
                const cleanedResult = cleanGeneratedText(result, true);
                
                if (!cleanedResult) {
                    throw new Error("A IA não retornou um JSON válido.");
                }
                
                const parsedContent = cleanedResult;
                generatedTitlesAndThumbnails = parsedContent;


                if (!Array.isArray(parsedContent.titles) || !Array.isArray(parsedContent.thumbnails)) {
                    console.error("Formato de Títulos/Thumbnails inválido recebido da IA:", parsedContent);
                    throw new Error("A IA retornou os dados de títulos em um formato inesperado. Tente novamente.");
                }


                const targetContentElement = document.getElementById('titlesThumbnailsContent');
                if (targetContentElement) {
                    const titlesListHtml = parsedContent.titles.map((title, index) => `<p>${index + 1}. ${title}</p>`).join('');
                    const thumbnailsListHtml = parsedContent.thumbnails.map((thumb, index) => `
                        <div class="${index === 0 ? '' : 'thumbnail-item-separator'}"> 
                            <p class="font-semibold">"${thumb.title}"</p>
                            <p class="text-sm leading-tight">Descrição: ${thumb.description}</p>
                        </div>
                    `).join('');

                    targetContentElement.innerHTML = `
                        <div class="generated-output-box">
                            <div>
                                <h4 class="output-subtitle">Sugestões de Títulos:</h4>
                                <div class="output-content-block">${titlesListHtml}</div>
                                <div class="mt-3">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeTitles()">Analisar CTR</button>
                                    <div id="ctrAnalysisResult" class="mt-3"></div>
                                </div>
                            </div>
                            <div>
                                <h4 class="output-subtitle">Ideias de Thumbnail:</h4>
                                <div class="output-content-block">${thumbnailsListHtml}</div>
                                <div class="mt-3">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeThumbnails()">Analisar Thumbnails</button>
                                    <div id="thumbnailAnalysisResult" class="mt-3"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    markButtonAsCompleted(button.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar Títulos: ${error.message}`);
                console.error("Error generating Titles/Thumbnails.", error);
            } finally {
                hideButtonLoading(button);
                updateButtonStates();
            }
        };


// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO analyzeTitles INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
// =========================================================================

window.analyzeTitles = async () => {
    if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.titles || generatedTitlesAndThumbnails.titles.length === 0) {
        window.showToast("Gere os títulos primeiro!");
        return;
    }

    const resultContainer = document.getElementById('ctrAnalysisResult');
    resultContainer.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small"></div>`);

    const titlesString = generatedTitlesAndThumbnails.titles.join('\n');
    
    // >>> PROMPT BLINDADO COM REGRAS DE SINTAXE E ESTRUTURA EXPLÍCITAS <<<
    const prompt = `Você é uma API de análise de títulos do YouTube que retorna APENAS um array JSON.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`[\` e terminando com \`]\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar aspas duplas (\`"\`).
3.  **VÍRGULA FINAL:** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último objeto.
4.  **ESTRUTURA DO OBJETO:** Cada objeto no array DEVE conter EXATAMENTE estas três chaves: "titulo_original" (string), "nota_ctr" (um número de 0 a 10), e "sugestao_melhora" (string).

**EXEMPLO DE FORMATO PERFEITO E OBRIGATÓRIO:**
[
  {
    "titulo_original": "Título Exemplo 1",
    "nota_ctr": 8,
    "sugestao_melhora": "Adicionar um número ou um gatilho de curiosidade."
  },
  {
    "titulo_original": "Título Exemplo 2",
    "nota_ctr": 6,
    "sugestao_melhora": "Encurtar para ser mais direto e impactante."
  }
]

**Títulos para analisar:**
---
${titlesString}
---

Responda APENAS com o array JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE as regras acima.`;

    try {
        const rawResult = await callGroqAPI(prompt, 3000);
        const analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis)) {
            throw new Error("A IA não retornou uma análise de títulos em formato válido.");
        }

        let analysisHtml = '<div class="space-y-4">';
        analysis.forEach(item => {
            analysisHtml += `
                <div class="p-3 card-background rounded-md shadow-sm">
                    <p class="font-semibold text-gray-800 dark:text-gray-200">${DOMPurify.sanitize(item.titulo_original)}</p>
                    <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de CTR:</strong> <span class="text-indigo-500 font-bold">${DOMPurify.sanitize(String(item.nota_ctr))} / 10</span></p>
                    <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugestão:</strong> ${DOMPurify.sanitize(item.sugestao_melhora)}</p>
                </div>
            `;
        });
        analysisHtml += '</div>';
        resultContainer.innerHTML = DOMPurify.sanitize(analysisHtml);

    } catch (error) {
        console.error("Erro detalhado em analyzeTitles:", error);
        resultContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">Falha ao analisar os títulos: ${error.message}</p>`);
    }
};

// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO analyzeThumbnails INTEIRA POR ESTA VERSÃO BLINDADA <<<<<
// =========================================================================

window.analyzeThumbnails = async () => {
    if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.thumbnails || generatedTitlesAndThumbnails.thumbnails.length === 0) {
        window.showToast("Gere as ideias de thumbnail primeiro!");
        return;
    }

    const resultContainer = document.getElementById('thumbnailAnalysisResult');
    resultContainer.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small"></div>`);

    const thumbnailsString = generatedTitlesAndThumbnails.thumbnails.map(t => `Título: ${t.title}, Descrição: ${t.description}`).join('\n---\n');
    
    // >>> PROMPT BLINDADO COM REGRAS DE SINTAXE E ESTRUTURA EXPLÍCITAS <<<
    const prompt = `Você é uma API de análise de thumbnails do YouTube que retorna APENAS um array JSON.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`[\` e terminando com \`]\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar aspas duplas (\`"\`).
3.  **VÍRGULA FINAL:** Cada objeto JSON dentro do array DEVE ser seguido por uma vírgula, EXCETO o último objeto.
4.  **ESTRUTURA DO OBJETO:** Cada objeto no array DEVE conter EXATAMENTE estas três chaves: "titulo" (string, contendo o título original da ideia analisada), "nota_visual" (um número de 0 a 10), e "sugestao_melhora" (string).

**EXEMPLO DE FORMATO PERFEITO E OBRIGATÓRIO:**
[
  {
    "titulo": "Ideia de Thumbnail 1",
    "nota_visual": 7,
    "sugestao_melhora": "Aumentar o contraste e usar uma fonte mais legível no texto."
  },
  {
    "titulo": "Ideia de Thumbnail 2",
    "nota_visual": 9,
    "sugestao_melhora": "Adicionar um contorno brilhante ao redor da pessoa para destacá-la do fundo."
  }
]

**Ideias para analisar:**
---
${thumbnailsString}
---

Responda APENAS com o array JSON completo e sintaticamente PERFEITO, seguindo EXATAMENTE as regras acima.`;

    try {
        const rawResult = await callGroqAPI(prompt, 2500);
        const analysis = cleanGeneratedText(rawResult, true);

        if (!analysis || !Array.isArray(analysis)) {
            throw new Error("A IA não retornou uma análise de thumbnails em formato válido.");
        }

        let analysisHtml = '<div class="space-y-4">';
        analysis.forEach(item => {
            analysisHtml += `
                <div class="p-3 card-background rounded-md shadow-sm">
                    <p class="font-semibold text-gray-800 dark:text-gray-200">"${DOMPurify.sanitize(item.titulo || 'Ideia Sem Título')}"</p>
                    <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de Potencial Visual:</strong> <span class="text-indigo-500 font-bold">${DOMPurify.sanitize(String(item.nota_visual))} / 10</span></p>
                    <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugestão:</strong> ${DOMPurify.sanitize(item.sugestao_melhora)}</p>
                </div>
            `;
        });
        analysisHtml += '</div>';
        resultContainer.innerHTML = DOMPurify.sanitize(analysisHtml);

    } catch (error) {
        console.error("Erro detalhado em analyzeThumbnails:", error);
        resultContainer.innerHTML = DOMPurify.sanitize(`<p class="text-red-500 text-sm">Falha ao analisar as thumbnails: ${error.message}</p>`);
    }
};



        /**
         * Gera a descrição do vídeo e hashtags.
         */
            const generateVideoDescription = async (button) => {
            if (!validateInputs()) return;
            showButtonLoading(button);

            try {
                let result = await callGroqAPI(constructScriptPrompt('description').prompt, constructScriptPrompt('description').maxTokens);
                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);
                
                const targetContentElement = document.getElementById('videoDescriptionContent');
                if (targetContentElement) {
                    // >>> AQUI ESTÁ A MUDANÇA <<<
                    const sanitizedResult = DOMPurify.sanitize(`<div class="generated-output-box whitespace-pre-wrap">${result}</div>`);
                    targetContentElement.innerHTML = sanitizedResult;
                    markButtonAsCompleted(button.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar Descrição: ${error.message}`);
                console.error("Error generating Video Description.", error);
            } finally {
                hideButtonLoading(button);
                updateButtonStates();
            }
        };

// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A FUNÇÃO generateStrategicOutline INTEIRA <<<<<
// =========================================================================

const generateStrategicOutline = async (button) => {
    if (!validateInputs()) return;
    showButtonLoading(button);
    
    const outlineContentDiv = document.getElementById('outlineContent');
    if (outlineContentDiv) {
        outlineContentDiv.innerHTML = DOMPurify.sanitize(`<div class="loading-spinner-small mx-auto"></div>`);
    } else {
        window.showToast("Erro: Container do esboço não encontrado.");
        hideButtonLoading(button);
        return;
    }

    try {
        const { prompt } = constructScriptPrompt('outline'); // Usamos o prompt blindado
        const rawResult = await callGroqAPI(prompt, 4000);
        
        strategicOutline = cleanGeneratedText(rawResult, true);

        if (!strategicOutline || typeof strategicOutline !== 'object' || !strategicOutline.introduction) {
            console.error("A IA retornou um esboço em formato inválido:", rawResult);
            throw new Error("A IA falhou em gerar um esboço válido.");
        }

        const titleTranslations = {
            'introduction': 'Introdução', 'development': 'Desenvolvimento',
            'climax': 'Clímax', 'conclusion': 'Conclusão', 'cta': 'CTA'
        };
        
        let outlineHtml = '<ul class="space-y-4 text-sm">';
        for (const key in strategicOutline) {
            if (Object.hasOwnProperty.call(strategicOutline, key)) {
                const translatedTitle = titleTranslations[key] || key;
                const contentValue = strategicOutline[key];
                
                outlineHtml += `<li><div><strong class="text-indigo-600 dark:text-indigo-400">${translatedTitle}:</strong>`;
                
                // <<< AQUI ESTÁ A NOVA LÓGICA INTELIGENTE DE RENDERIZAÇÃO >>>
                if (typeof contentValue === 'string') {
                    outlineHtml += ` <span class="text-gray-600 dark:text-gray-300">${DOMPurify.sanitize(contentValue)}</span>`;
                } else if (typeof contentValue === 'object' && contentValue !== null) {
                    outlineHtml += '<ul class="list-disc pl-5 mt-1 space-y-1">';
                    for (const subKey in contentValue) {
                        if(Array.isArray(contentValue[subKey])) { // Para o caso do Desenvolvimento ter seções
                             contentValue[subKey].forEach(section => {
                                outlineHtml += `<li><span class="font-semibold">${DOMPurify.sanitize(section.title || subKey)}:</span> ${DOMPurify.sanitize(section.description || '')}</li>`;
                             });
                        } else {
                            outlineHtml += `<li><span class="font-semibold">${DOMPurify.sanitize(subKey.replace(/_/g, ' '))}:</span> ${DOMPurify.sanitize(contentValue[subKey])}</li>`;
                        }
                    }
                    outlineHtml += '</ul>';
                }
                
                outlineHtml += '</div></li>';
            }
        }
        outlineHtml += '</ul>';
        
        outlineContentDiv.innerHTML = outlineHtml; // A sanitização já foi feita nos pedaços
        markButtonAsCompleted(button.dataset.action ? button.id : 'generateOutlineBtn');

        const scriptContainer = document.getElementById('scriptSectionsContainer');
        if (scriptContainer) {
            scriptContainer.innerHTML = ''; 
            scriptContainer.innerHTML += DOMPurify.sanitize(createScriptSectionPlaceholder('intro', 'Introdução', 'generateIntroBtn', 'generateIntro'));
            scriptContainer.innerHTML += DOMPurify.sanitize(createScriptSectionPlaceholder('development', 'Desenvolvimento', 'generateDevelopmentBtn', 'generateDevelopment'));
            scriptContainer.innerHTML += DOMPurify.sanitize(createScriptSectionPlaceholder('climax', 'Clímax', 'climaxBtn', 'generateClimax'));
        }

    } catch (error) {
        console.error("Erro detalhado em generateStrategicOutline:", error);
        window.showToast(`Falha ao gerar Esboço: ${error.message}`);
        // ... (resto do seu catch)
    } finally {
        hideButtonLoading(button);
        updateButtonStates();
    }
};


        /**
         * Realiza o download do roteiro como PDF.
         */
        const downloadPdf = async () => {
            // 1. Criar um container temporário para a impressão
            let printContainer = document.createElement('div');
            printContainer.id = 'print-container';

            // 2. Coletar e formatar TODO o conteúdo que queremos imprimir
            let htmlToPrint = `<h1 style="text-align: center; font-size: 22pt; margin-bottom: 24px;">${elements.videoTheme.value}</h1>`;

            // Adicionar o esboço estratégico
            if (strategicOutline) {
                const titleTranslations = {
                    'introduction': 'Introdução',
                    'development': 'Desenvolvimento',
                    'climax': 'Clímax',
                    'conclusion': 'Conclusão',
                    'cta': 'CTA'
                };
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Esboço Estratégico</div>
                        <div class="print-section-content">
                            <ul style="list-style-type: disc; padding-left: 20px;">`;
                for (const key in strategicOutline) {
                    const translatedTitle = titleTranslations[key] || (key.charAt(0).toUpperCase() + key.slice(1));
                    htmlToPrint += `<li><strong>${translatedTitle}:</strong> ${strategicOutline[key]}</li>`;
                }
                htmlToPrint += `</ul></div></div>`;
            }

            // Adicionar o roteiro principal
            document.querySelectorAll('#scriptSectionsContainer .accordion-item').forEach(item => {
                const title = item.querySelector('h3')?.textContent;
                const content = item.querySelector('.generated-content-wrapper')?.textContent;
                if (title && content) {
                    htmlToPrint += `
                        <div class="print-section">
                            <div class="print-section-title">${title}</div>
                            <div class="print-section-content"><pre>${content}</pre></div>
                        </div>`;
                }
            });
            
            // Adicionar Descrição e Hashtags
            const videoDescriptionContent = document.getElementById('videoDescriptionContent');
            if (videoDescriptionContent && videoDescriptionContent.textContent.trim() !== 'Clique em \'Gerar\' para ver a descrição') {
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Descrição & Hashtags</div>
                        <div class="print-section-content">${videoDescriptionContent.innerHTML}</div>
                    </div>`;
            }

            // Adicionar Títulos e Thumbnails
            const titlesThumbnailsContent = document.getElementById('titlesThumbnailsContent');
            if (titlesThumbnailsContent && titlesThumbnailsContent.textContent.trim() !== 'Clique em \'Gerar\' para ver as sugestões') {
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Títulos & Thumbnails</div>
                        <div class="print-section-content">${titlesThumbnailsContent.innerHTML}</div>
                    </div>`;
            }

            // 3. Injetar o HTML no container e adicioná-lo ao body
            printContainer.innerHTML = htmlToPrint;
            document.body.appendChild(printContainer);

            // 4. Chamar a impressão
            window.print();

            // 5. Remover o container temporário após a impressão (com um pequeno atraso para garantir a renderização)
            setTimeout(() => {
                document.body.removeChild(printContainer);
            }, 500); // 500ms de atraso
        };



// =========================================================================
// >>>>> PASSO 4: SUBSTITUA A FUNÇÃO resetApplicationState INTEIRA POR ESTA <<<<<
// =========================================================================
const resetApplicationState = () => {
    projectState = {
        intro: false,
        development: false,
        climax: false,
        conclusion: false,
        cta: false
    };

    const safeReset = (elementId, value = '') => { /* ... */ };

    // ... (o resto da sua função de reset, que já está correta)
    
    // Apenas para garantir, o miolo da função deve ser este:
    safeReset('channelName', 'The Biblical Unveiling');
    safeReset('videoTheme');
    safeReset('videoDescription');
    safeReset('targetAudience', ''); 
    safeReset('languageSelect', 'en');
    safeReset('videoObjective', 'informar');
    safeReset('videoDuration', '');
    safeReset('speakingPace', 'moderate');
    safeReset('narrativeGoal', 'storytelling');
    safeReset('narrativeTheme');
    safeReset('narrativeTone', 'inspirador');
    safeReset('narrativeVoice');
    safeReset('centralQuestion');
    safeReset('emotionalArc');
    safeReset('shockingEndingHook');
    safeReset('imageDescriptionEngine');
    safeReset('imageStyleSelect', 'cinematic');
    safeReset('customImageStyle');
    safeReset('researchData');
    safeReset('emotionalHook');

    toggleCustomImageStyleVisibility();
    updateNarrativeStructureOptions();

    const nicheDesc = document.getElementById('nicheDescription');
    const ideasOut = document.getElementById('ideasOutput');
    if (nicheDesc) nicheDesc.value = '';
    if (ideasOut) ideasOut.innerHTML = '';

    strategicOutline = null;
    allImagePrompts = {};
    generatedTitlesAndThumbnails = null;
    totalScriptSeconds = 0;
    promptPaginationState = {};

    resetProjectOutputs();

    window.showToast("Pronto para um novo roteiro!");
    window.scrollTo({ top: 0, behavior: 'smooth' });
};
        

        /**
         * Exporta o estado atual do projeto para um ficheiro JSON.
         */
        const exportProject = () => {
            const projectData = {
                inputs: {},
                outputs: {},
                memory: {
                    allImagePrompts: allImagePrompts,
                    generatedTitlesAndThumbnails: generatedTitlesAndThumbnails,
                    strategicOutline: strategicOutline, // Exporta o esboço
                    promptPaginationState: promptPaginationState // Export pagination state
                }
            };

            // Salva o estado dos inputs
            for (const key in elements) {
                if (elements[key] && typeof elements[key].value !== 'undefined') {
                    projectData.inputs[key] = elements[key].value;
                }
            }
            // Salva o conteúdo gerado (HTML interno das secções)
            const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection']; // CTA is now part of conclusionSection
            scriptSectionIds.forEach(id => {
                const sectionElement = document.getElementById(id);
                if (sectionElement) {
                    projectData.outputs[id] = sectionElement.innerHTML;
                }
            });

            // Salva o conteúdo do esboço
            projectData.outputs.strategicOutlineContent = elements.outlineContent.innerHTML;

            // Salva o conteúdo dos cartões de recursos
            projectData.outputs.titlesThumbnailsContent = document.getElementById('titlesThumbnailsContent').innerHTML;
            projectData.outputs.videoDescriptionContent = document.getElementById('videoDescriptionContent').innerHTML;
            // Removed storyboardContent export
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            const fileName = elements.videoTheme.value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro_viral';
            downloadAnchorNode.setAttribute("download", `${fileName}_projeto.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            document.body.removeChild(downloadAnchorNode);
            downloadAnchorNode.remove();
            window.showToast("Projeto exportado com sucesso!");
        };

        /**
         * Renderiza os prompts de imagem para uma secção específica na UI.
         * Usado após carregar um projeto.
         * @param {string} sectionElementId - O ID do elemento HTML da secção.
         */
        const renderImagePromptsForSection = (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            if (!sectionElement) return;

            const promptContainer = sectionElement.querySelector('.prompt-container');
            if (!promptContainer) return;

            // Re-cria a estrutura de paginação se ela não existir
            if (!promptContainer.querySelector('.prompt-pagination-wrapper')) {
                promptContainer.innerHTML = `
                    <div class="prompt-pagination-wrapper space-y-4">
                        <div class="prompt-nav-container flex items-center justify-center gap-4">
                            <!-- Controles de navegação serão inseridos aqui -->
                        </div>
                        <div class="prompt-items-container space-y-4">
                            <!-- Os 4 prompts da página atual serão inseridos aqui -->
                        </div>
                    </div>
                `;
            }

            // Renderiza a página atual de prompts
            renderPaginatedPrompts(sectionElementId);
        };

        /**
         * Importa um projeto de um ficheiro JSON.
         * @param {Event} event - O evento de mudança do input de ficheiro.
         */
        const importProject = (event) => {
            const file = event.target.files[0];
            if (!file) { return; }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    
                    resetApplicationState();

                    // Restaura os inputs
                    const inputIds = [
                        'channelName', 'videoTheme', 'videoDescription', 'targetAudience', 
                        'languageSelect', 'videoObjective', 'videoDuration', 'speakingPace', 
                        'narrativeGoal', 'narrativeStructure', 'narrativeTheme', 'narrativeTone', 
                        'narrativeVoice', 'centralQuestion', 'emotionalArc', 'shockingEndingHook', 'imageDescriptionEngine', 
                        'imageStyleSelect', 'customImageStyle'
                    ];
                    inputIds.forEach(id => {
                        const element = document.getElementById(id);
                        if (element && projectData.inputs[id] !== undefined) {
                            element.value = projectData.inputs[id];
                        }
                    });
                    
                    const structureSelect = document.getElementById('narrativeStructure');
                    if (structureSelect && projectData.inputs['narrativeStructure']) {
                        structureSelect.value = projectData.inputs['narrativeStructure'];
                        // Ensure the tooltip is updated after setting the structure value
                        
                    }

                    // Restaura o conteúdo gerado
                    const outputIds = [
                        'introSection', 'developmentSection', 'climaxSection', 'conclusionSection', // CTA is now part of conclusionSection
                        'outlineContent', 'titlesThumbnailsContent', 'videoDescriptionContent'
                    ];
                    outputIds.forEach(id => {
                        const element = document.getElementById(id);
                        if (element && projectData.outputs[id]) {
                            element.innerHTML = projectData.outputs[id]; 
                        }
                    });
                    
                    strategicOutline = projectData.memory.strategicOutline || null;
                    allImagePrompts = projectData.memory.allImagePrompts || {};
                    generatedTitlesAndThumbnails = projectData.memory.generatedTitlesAndThumbnails || null;
                    promptPaginationState = projectData.memory.promptPaginationState || {}; // Load pagination state

                    // Renderiza os prompts de imagem paginados após carregar
                    const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection'];
                    scriptSectionIds.forEach(id => {
                        if (allImagePrompts[id] && allImagePrompts[id].length > 0) {
                            renderImagePromptsForSection(id);
                        }
                    });

                    updateButtonStates();
                    
                    if (elements.outlineContent.textContent.trim().length > 100) markButtonAsCompleted('generateOutlineBtn');
                    if (document.getElementById('introSection').innerHTML.trim()) markButtonAsCompleted('generateIntroBtn');
                    if (document.getElementById('developmentSection').innerHTML.trim()) markButtonAsCompleted('generateDevelopmentBtn');
                    if (document.getElementById('climaxSection').innerHTML.trim()) markButtonAsCompleted('climaxBtn');
                    if (document.getElementById('conclusionSection').innerHTML.trim()) markButtonAsCompleted('conclusionBtn');
                    if (document.getElementById('videoDescriptionContent').innerHTML.includes('Hashtags')) markButtonAsCompleted('generateDescriptionBtn');
                    if (document.getElementById('titlesThumbnailsContent').innerHTML.includes('Analisar CTR')) markButtonAsCompleted('generateTitlesAndThumbnailsBtn');

                    updateProgressBar(); 
                    
                    elements.projectDashboard.classList.remove('hidden');
                    window.showToast("Projeto importado com sucesso!");

                } catch (err) {
                    window.showToast("Erro: Ficheiro de projeto inválido ou corrompido.");
                    console.error("Erro ao importar projeto:", err);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        };



// =-==================================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA A SUA FUNÇÃO suggestStrategy INTEIRA POR ESTA VERSÃO <<<<<
// =-==================================================================================

const suggestStrategy = async (button) => {
    if (document.querySelector('#scriptSectionsContainer .accordion-item')) {
        const userConfirmed = await showConfirmationDialog(
            "Sugerir Nova Estratégia?",
            "Isso limpará todo o roteiro e metadados já gerados para aplicar a nova sugestão. Deseja continuar?"
        );
        if (!userConfirmed) return;
    }

    resetProjectOutputs();

    const theme = document.getElementById('videoTheme')?.value.trim();
    const description = document.getElementById('videoDescription')?.value.trim();
    if (!theme || !description) {
        window.showToast("Preencha o Tema e a Descrição do Vídeo para receber sugestões.");
        return;
    }

    showButtonLoading(button);
    isSettingStrategy = true;

    const selectedLangCode = document.getElementById('languageSelect').value;
    const languageName = selectedLangCode === 'pt-br' ? 'Português (Brasil)' : 'English';

    const validOptions = {
        narrative_goal: `['${Array.from(document.getElementById('narrativeGoal').options).map(o => o.value).filter(Boolean).join("', '")}']`,
        narrative_tone: `['${Array.from(document.getElementById('narrativeTone').options).map(o => o.value).filter(Boolean).join("', '")}']`,
        language_style: `['${Array.from(document.getElementById('languageStyle').options).map(o => o.value).filter(Boolean).join("', '")}']`,
        video_objective: `['${Array.from(document.getElementById('videoObjective').options).map(o => o.value).filter(Boolean).join("', '")}']`,
        speaking_pace: `['${Array.from(document.getElementById('speakingPace').options).map(o => o.value).filter(Boolean).join("', '")}']`,
    };

    // >>> PROMPT BLINDADO COM REGRAS DE SINTAXE E ESTRUTURA EXPLÍCITAS <<<
    const prompt = `Você é uma API que retorna um objeto JSON para definir a estratégia de um vídeo.

**REGRAS CRÍTICAS DE SINTAXE E ESTRUTURA (INEGOCIÁVEIS):**
1.  **JSON PURO:** Sua resposta inteira deve ser APENAS o código JSON, começando com \`{\` e terminando com \`}\`.
2.  **ASPAS DUPLAS, SEMPRE:** TODAS as chaves e valores de texto DEVEM usar aspas duplas (\`"\`).
3.  **PREENCHIMENTO TOTAL:** Você DEVE preencher TODAS as chaves listadas no manual abaixo com valores criativos e relevantes.

**MANUAL DE PREENCHIMENTO (SIGA EXATAMENTE):**
-   **"target_audience":** (String) Descreva o público-alvo ideal.
-   **"narrative_goal":** (String) Escolha EXATAMENTE UM valor da lista: ${validOptions.narrative_goal}.
-   **"narrative_structure":** (String) Com base no "narrative_goal", escolha uma estrutura compatível: se 'storytelling', escolha de ["documentary", "heros_journey", "pixar_spine", "mystery_loop", "twist"]; se 'storyselling', escolha de ["underdog_victory", "discovery_mentor", "if_not_found_create", "pas", "bab"].
-   **"narrative_theme":** (String) Defina o tema principal.
-   **"narrative_tone":** (String) Escolha EXATAMENTE UM valor da lista: ${validOptions.narrative_tone}.
-   **"narrative_voice":** (String) Descreva a personalidade do narrador.
-   **"central_question":** (String) Formule a pergunta central do vídeo.
-   **"emotional_arc":** (String) Descreva a jornada emocional do espectador.
-   **"emotional_hook":** (String) Crie uma história pessoal para ser o fio condutor.
-   **"shocking_ending_hook":** (String) Crie uma frase chocante para o início do vídeo.
-   **"language_style":** (String) Escolha EXATAMENTE UM valor da lista: ${validOptions.language_style}.
-   **"video_objective":** (String) Escolha EXATAMENTE UM valor da lista: ${validOptions.video_objective}.
-   **"speaking_pace":** (String) Escolha EXATAMENTE UM valor da lista: ${validOptions.speaking_pace}.
-   **"image_description_engine":** (String) Sugira palavras-chave para o estilo visual.
-   **"research_data":** (String) Sugira quais dados pesquisar para o roteiro (NÃO INVENTE DADOS).
-   **IDIOMA:** Lembre-se, todos os valores de texto devem estar em **${languageName}**.

**Tema do Vídeo:** "${theme}"
**Descrição:** "${description}"

Responda APENAS com o objeto JSON completo e sintaticamente PERFEITO.`;

    try {
        const rawResult = await callGroqAPI(prompt, 4000);
        const strategy = cleanGeneratedText(rawResult, true);

        if (!strategy || typeof strategy !== 'object') {
            throw new Error("A IA não retornou uma resposta em formato JSON válido.");
        }

        // Lógica de preenchimento dos campos (permanece a mesma)
        const narrativeGoalSelect = document.getElementById('narrativeGoal');
        const narrativeStructureSelect = document.getElementById('narrativeStructure');
        if (narrativeGoalSelect && strategy.narrative_goal) {
            narrativeGoalSelect.value = strategy.narrative_goal;
            updateNarrativeStructureOptions();
        }
        if (narrativeStructureSelect && strategy.narrative_structure) {
            setTimeout(() => {
                if ([...narrativeStructureSelect.options].some(option => option.value === strategy.narrative_structure)) {
                    narrativeStructureSelect.value = strategy.narrative_structure;
                } else {
                    narrativeStructureSelect.selectedIndex = 0;
                    console.warn(`A estrutura '${strategy.narrative_structure}' não foi encontrada. Usando fallback.`);
                }
                updateMainTooltip();
            }, 50);
        }
        
        const keyToElementIdMap = {
            'target_audience': 'targetAudience', 'narrative_theme': 'narrativeTheme',
            'narrative_tone': 'narrativeTone', 'narrative_voice': 'narrativeVoice',
            'central_question': 'centralQuestion', 'emotional_arc': 'emotionalArc',
            'emotional_hook': 'emotionalHook', 'shocking_ending_hook': 'shockingEndingHook',
            'language_style': 'languageStyle', 'video_objective': 'videoObjective',
            'speaking_pace': 'speakingPace', 'image_description_engine': 'imageDescriptionEngine',
            'research_data': 'researchData'
        };
        for (const key in keyToElementIdMap) {
            if (strategy[key]) {
                const element = document.getElementById(keyToElementIdMap[key]);
                if (element) { element.value = strategy[key]; }
            }
        }

        window.showToast("Estratégia sugerida pela IA! Revise e edite como desejar.");
        document.querySelector('[data-tab="input-tab-estrategia"]')?.click();

    } catch (error) {
        console.error("Erro detalhado em suggestStrategy:", error);
        window.showToast(`Falha ao sugerir estratégia: ${error.message}`);
    } finally {
        isSettingStrategy = false;
        hideButtonLoading(button);
    }
};


/**
 * Valida os inputs essenciais e avança para o painel de criação do roteiro.
 * Não utiliza a IA, apenas libera a próxima etapa.
 */
const startCrafting = () => {
    // Valida apenas os campos mais essenciais para garantir que há uma base para o roteiro.
    if (!validateInputs()) { // Reutilizamos a validação que já obriga os campos da aba "Básico"
        return;
    }
    
    const dashboard = document.getElementById('projectDashboard');
    if (dashboard) {
        dashboard.classList.remove('hidden');
        dashboard.scrollIntoView({ behavior: 'smooth', block: 'start' });
        window.showToast("Estratégia definida! Pronto para criar o esboço.");
    }
};

// =========================================================================
// >>>>> PASSO ÚNICO: SUBSTITUA O BLOCO DOMContentLoaded INTEIRO POR ESTE <<<<<
// =========================================================================

document.addEventListener('DOMContentLoaded', () => {
    // --- 1. MAPEAMENTO INICIAL DE ELEMENTOS ---
    document.querySelectorAll('[id]').forEach(el => {
        if (el.tagName === 'BUTTON') { buttons[el.id] = el; } 
        else { elements[el.id] = el; }
    });

    // --- 2. INICIALIZAÇÃO DE FUNÇÕES DA INTERFACE ---
    setupInputTabs();
    updateProgressBar();
    updateButtonStates();
    updateNarrativeStructureOptions();

    // --- 3. EVENT LISTENERS ESPECÍFICOS ---
    const goalSelect = document.getElementById('narrativeGoal');
    if (goalSelect) { goalSelect.addEventListener('change', updateNarrativeStructureOptions); }

    const structureSelect = document.getElementById('narrativeStructure');
    if (structureSelect) { structureSelect.addEventListener('change', updateMainTooltip); }
    
    const imageStyleSelect = document.getElementById('imageStyleSelect');
    if (imageStyleSelect) { imageStyleSelect.addEventListener('change', toggleCustomImageStyleVisibility); }
    
    const importInput = document.getElementById('importFileInput');
    if (importInput) { importInput.addEventListener('change', importProject); }
    
    const darkModeToggle = document.getElementById('darkModeToggle');
    if (darkModeToggle) {
        darkModeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark');
            const isDarkMode = document.body.classList.contains('dark');
            document.getElementById('moonIcon').classList.toggle('hidden', isDarkMode);
            document.getElementById('sunIcon').classList.toggle('hidden', !isDarkMode);
            localStorage.setItem('darkMode', isDarkMode ? 'enabled' : 'disabled');
        });
    }

    if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark');
        const moonIcon = document.getElementById('moonIcon');
        const sunIcon = document.getElementById('sunIcon');
        if(moonIcon) moonIcon.classList.add('hidden');
        if(sunIcon) sunIcon.classList.remove('hidden');
    }

    const speakingPaceSelect = document.getElementById('speakingPace');
    if (speakingPaceSelect) { speakingPaceSelect.addEventListener('change', updateAllReadingTimes); }
    
    // --- 4. O "GERENTE DE CLIQUES" (versão v6.0 - Robusta) ---
const actions = {
        'suggestStrategy': (btn) => suggestStrategy(btn),
        'startCrafting': (btn) => startCrafting(),
        'generateIdeas': (btn) => generateVideoIdeas(btn),
        'unravelEnigmas': (btn) => unravelEnigmas(btn),
        'generateOutline': (btn) => generateStrategicOutline(btn),
        'mapEmotions': (btn) => mapEmotionsAndPacing(btn),
        'generateDescription': (btn) => generateVideoDescription(btn),
        'generateTitlesAndThumbnails': (btn) => generateTitlesAndThumbnails(btn),
        'generateSoundtrack': (btn) => generateSoundtrack(btn),
        'generateIntro': (btn) => handleGenerateSection(btn, 'intro', 'Introdução', 'intro'),
        'generateDevelopment': (btn) => handleGenerateSection(btn, 'development', 'Desenvolvimento', 'development'),
        'generateClimax': (btn) => handleGenerateSection(btn, 'climax', 'Clímax', 'climax'),
        'generateConclusion': (btn) => generateConclusion(btn),
        'generateCta': (btn) => generateStrategicCta(btn),
        'suggestFinalStrategy': (btn) => suggestFinalStrategy(btn),
        'applySuggestion': (btn) => window.applySuggestion(btn),
        'exportProject': () => exportProject(),
        'exportPdf': () => downloadPdf(),
        'exportTranscript': () => handleCopyAndDownloadTranscript(),
        'resetProject': async () => {
            const confirmed = await showConfirmationDialog("Começar um Novo Projeto?","Isso limpará todos os campos e o trabalho realizado. Esta ação não pode ser desfeita. Deseja continuar?");
            if (confirmed) { resetApplicationState(); }
        },
        'addDevelopmentChapter': (btn) => window.addDevelopmentChapter(btn),
        'select-idea': (btn) => {
            const ideaString = btn.dataset.idea;
            if (ideaString) {
                try {
                    const ideaObject = JSON.parse(ideaString.replace(/"/g, '"'));
                    document.getElementById('videoTheme').value = ideaObject.title || '';
                    document.getElementById('videoDescription').value = ideaObject.videoDescription || ideaObject.angle || '';
                    document.getElementById('targetAudience').value = ideaObject.targetAudience || '';
                    window.showToast("Ideia selecionada! Estratégia pré-preenchida.");
                    document.getElementById('inputTabsNav').scrollIntoView({ behavior: 'smooth', block: 'center' });
                } catch (e) { console.error("Falha ao processar dados da ideia:", e); }
            }
        },
        'select-enigma-idea': (btn) => {
            const ideaString = btn.dataset.idea;
            if (ideaString) {
                try {
                    const ideaObject = JSON.parse(ideaString.replace(/"/g, '"'));
                    document.getElementById('videoTheme').value = ideaObject.title || '';
                    document.getElementById('videoDescription').value = ideaObject.synopsis || ideaObject.enigma || '';
                    document.getElementById('centralQuestion').value = ideaObject.hook_question || '';
                    window.showToast("Enigma selecionado! Estratégia pré-preenchida.");
                    document.getElementById('inputTabsNav').scrollIntoView({ behavior: 'smooth', block: 'center' });
                } catch (e) { console.error("Falha ao processar dados da ideia de enigma:", e); }
            }
        },
        'regenerate': (btn) => window.regenerateSection(btn.dataset.sectionId),
        'copy': (btn) => {
            const content = btn.closest('.accordion-item')?.querySelector('.generated-content-wrapper');
            if (content) { window.copyTextToClipboard(content.textContent); window.showCopyFeedback(btn); }
        },
        'generate-prompts': (btn) => window.generatePromptsForSection(btn, btn.dataset.sectionId),
        'analyzeRetention': (btn) => window.analyzeSectionRetention(btn, btn.dataset.sectionId),
        'refineStyle': (btn) => window.refineSectionStyle(btn),
        'enrichWithData': (btn) => window.enrichWithData(btn),
        'suggestPerformance': (btn) => window.suggestPerformance(btn, btn.dataset.sectionId),
        'optimizeGroup': (btn) => {
            const suggestionText = btn.dataset.suggestionText;
            if (suggestionText) window.optimizeGroup(btn, suggestionText);
        },
        'deleteParagraphGroup': (btn) => {
            const suggestionText = btn.dataset.suggestionText;
            if (suggestionText) window.deleteParagraphGroup(btn, suggestionText);
        },
        // <<< A LINHA QUE FALTAVA ESTÁ AQUI >>>
        'analyzeScript': (btn) => analyzeFullScript(btn)
    };



    document.addEventListener('click', function(event) {
        const target = event.target;
        
        // Lógica do Acordeão
        const accordionHeader = target.closest('.accordion-header');
        if (accordionHeader && !target.closest('.header-buttons')) {
            const body = accordionHeader.nextElementSibling;
            const arrow = accordionHeader.querySelector('.accordion-arrow');
            if (body && arrow) { body.classList.toggle('open'); arrow.classList.toggle('open'); }
        }

        // Lógica dos Botões de Ação
        const button = target.closest('button[data-action]');
        if (!button) return;

        const actionName = button.dataset.action;
        const action = actions[actionName];

        if (action) {
            event.preventDefault();
            action(button);
        }
    });


    const toneMenu = document.getElementById('tone-variation-menu');

    // Listener para mostrar o menu quando um texto é selecionado
    document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (selectedText.length > 10 && selection.anchorNode.parentElement.closest('.generated-content-wrapper')) {
            userSelectionRange = selection.getRangeAt(0).cloneRange();
            const rect = userSelectionRange.getBoundingClientRect();
            
            toneMenu.style.left = `${rect.left + window.scrollX}px`;
            toneMenu.style.top = `${rect.bottom + window.scrollY + 5}px`;
            toneMenu.classList.add('visible');
        } else {
            if (!toneMenu.contains(document.activeElement)) {
                 toneMenu.classList.remove('visible');
            }
        }
    });

    // Listener para os cliques nos botões do menu
    toneMenu.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-tone]');
        if (button) {
            const tone = button.dataset.tone;
            varyTone(tone);
        }
    });


    // --- 5. LÓGICA PARA RESETAR ROTEIRO ---
    const strategicInputIds = ['videoTheme', 'videoDescription', 'videoDuration', 'speakingPace', 'visualPacing', 'narrativeGoal', 'narrativeStructure', 'narrativeTheme', 'narrativeTone', 'narrativeVoice', 'centralQuestion', 'emotionalArc', 'shockingEndingHook', 'imageDescriptionEngine', 'imageStyleSelect', 'researchData', 'emotionalHook'];
    
    strategicInputIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            const eventType = (element.tagName === 'SELECT' || element.tagName === 'TEXTAREA') ? 'change' : 'input';
            element.addEventListener(eventType, (e) => {
                if (!isSettingStrategy) {
                    resetGeneratedScriptContent(e.target.id);
                }
            });
        }
    });
});

</script>
</body>
</html>