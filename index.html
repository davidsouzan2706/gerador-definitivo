<!DOCTYPE html>
<html lang="pt-br">
<head>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üöÄ</text></svg>">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Roteiros Virais v3.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        
    
        /* ================================================================= */
        /* ============== ESTE √â O CSS COMPLETO E FINAL ================== */
        /* ============== SUBSTITUA TUDO NA SUA TAG <style> POR ISTO ===== */
        /* ================================================================= */

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --accent: #ec4899;
            --success: #10b981;
            --danger: #ef4444;
            --dark-bg: #f8fafc;
            --dark-surface: #ffffff;
            --dark-border: #e2e8f0;
            --dark-text-header: #1e293b;
            --dark-text-body: #334155;
            --dark-text-muted: #64748b;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --transition: all 0.2s ease-in-out;
        }

        .dark {
            --primary: #818cf8;
            --primary-dark: #6366f1;
            --secondary: #a78bfa;
            --accent: #f472b6;
            --dark-bg: #0f172a;
            --dark-surface: #1e293b;
            --dark-border: #334155;
            --dark-text-header: #f1f5f9;
            --dark-text-body: #cbd5e1;
            --dark-text-muted: #94a3b8;
        }

        /* --- ESTILOS GERAIS --- */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg);
            color: var(--dark-text-body);
            transition: var(--transition);
        }
        .container { max-width: 1024px; margin: 0 auto; }
        h1, h2, h3, h4, h5, h6 { color: var(--dark-text-header); }

        /* --- COMPONENTES PRINCIPAIS --- */
        .card {
            background-color: var(--dark-surface);
            border: 1px solid var(--dark-border);
            border-radius: 12px;
            box-shadow: var(--shadow);
            padding: 1.5rem;
            transition: var(--transition);
        }
        .section-title {
            position: relative;
            padding-bottom: 0.75rem;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid var(--dark-border);
        }
        .section-title h2 { font-size: 1.25rem; font-weight: 700; }
        .section-title::after {
            content: ''; position: absolute; bottom: -1px; left: 0;
            width: 70px; height: 2px; background: var(--primary); transition: var(--transition);
        }

        /* --- BOT√ïES --- */
        .btn {
            display: inline-flex; align-items: center; justify-content: center;
            gap: 0.5rem; padding: 0.65rem 1.25rem; border-radius: 8px;
            font-weight: 600; cursor: pointer; transition: var(--transition);
            border: none; white-space: nowrap;
        }
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-primary:hover { background-color: var(--primary-dark); transform: translateY(-2px); }
        .btn-secondary { background-color: var(--secondary); color: white; }
        .btn-secondary:hover { background-color: #7c3aed; }
        .dark .btn-secondary:hover { background-color: #9333ea; }

        /* --- FORMUL√ÅRIOS E INPUTS --- */
        .input-group { margin-bottom: 1rem; }
        .input-group label {
            display: block; margin-bottom: 0.5rem; font-weight: 600;
            font-size: 0.875rem; color: var(--dark-text-header);
        }
        .input-group input, .input-group select, .input-group textarea {
            width: 100%; padding: 0.75rem; border-radius: 8px;
            border: 1px solid var(--dark-border); background: var(--dark-surface);
            transition: var(--transition); color: var(--dark-text-body);
        }
        .input-group input::placeholder, .input-group textarea::placeholder { color: var(--dark-text-muted); opacity: 1; }
        .input-group input:focus, .input-group select:focus, .input-group textarea:focus {
            outline: none; border-color: var(--primary);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent);
        }

        /* --- ABAS (TABS) --- */
        .tab-button {
            padding: 0.5rem 0.25rem; margin-bottom: 0.5rem;
            border-bottom: 3px solid transparent; color: var(--dark-text-muted);
            font-weight: 500; transition: var(--transition); background: none; border-radius: 0;
        }
        .tab-button:hover { color: var(--primary); }
        .tab-active { border-bottom-color: var(--primary); color: var(--primary); font-weight: 600; }
        .tab-pane.hidden { display: none; }

        /* --- ACCORDION & SCRIPT SECTIONS --- */
        .accordion-item {
            border-bottom: 1px solid var(--dark-border);
        }
        .accordion-header {
            display: flex; /* <-- A LINHA M√ÅGICA QUE FALTAVA */
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            cursor: pointer;
            transition: var(--transition);
        }
        .accordion-header:hover { 
            background-color: color-mix(in srgb, var(--dark-surface) 95%, var(--dark-text-muted)); 
        }

        .header-title-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-grow: 1; /* Garante que o grupo do t√≠tulo ocupe todo o espa√ßo */
        }
        .header-title-group h3 { font-weight: 600; font-size: 1.1rem; }
        .header-title-group .text-xs { color: var(--dark-text-muted); font-size: 0.75rem; white-space: nowrap; }
        
        .header-actions-group {
            display: flex;
            align-items: center;
            gap: 1rem; /* Espa√ßo entre os bot√µes e a seta */
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .header-buttons button {
            background: none; border: none; padding: 0.25rem;
            color: var(--dark-text-muted); cursor: pointer; transition: var(--transition);
        }
        .header-buttons button:hover { color: var(--primary); }

        .accordion-arrow { 
            transition: transform 0.3s;
            transform-origin: center;
         }
        .accordion-arrow.open { 
            transform: rotate(180deg);
        }
        
        .accordion-body {
            padding: 0 1.5rem 1.5rem 1.5rem;
            display: none;
        }
        .accordion-body.open { display: block; }

        /* --- TOAST NOTIFICATION --- */
        .toast {
            position: fixed; bottom: 1.5rem; right: 1.5rem;
            background-color: var(--dark-surface); color: var(--dark-text-header);
            padding: 1rem 1.5rem; border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            z-index: 1000; opacity: 0; transform: translateY(100%);
            transition: all 0.4s cubic-bezier(0.21, 1.05, 0.51, 1.04);
            border-left: 4px solid var(--primary);
        }
        .toast.show { opacity: 1; transform: translateY(0); }

        /* --- OUTROS --- */
        .loading-spinner {
            width: 24px; height: 24px;
            border: 3px solid color-mix(in srgb, var(--primary) 20%, transparent);
            border-top-color: var(--primary);
            border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .progress-bar { height: 8px; background: var(--dark-border); border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); border-radius: 4px; transition: width 0.3s ease; }

        /* --- PLACEHOLDER STYLES (A VERS√ÉO CORRETA E FINAL) --- */
        /* 1. Reduz a altura do CARD quando ele √© um placeholder */
        .card.card-placeholder {
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
        }

        /* 2. Remove a margem extra do t√≠tulo para um visual mais limpo */
        .card.card-placeholder > .flex {
            margin-bottom: 0 !important;
        }

        /* 3. Esconde o texto descritivo para economizar espa√ßo */
        .card.card-placeholder .asset-card-placeholder {
            display: none;
        }

        /* --- MAPA EMOCIONAL STYLES --- */
        .emotional-map-item {
            border-left: 4px solid var(--primary);
            background-color: color-mix(in srgb, var(--dark-bg) 50%, var(--dark-surface));
        }

        .paragraph-preview {
            font-style: italic;
            color: var(--dark-text-muted);
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
            border-bottom: 1px dashed var(--dark-border);
            padding-bottom: 0.75rem;
        }

        .analysis-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .tag {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px; /* pill shape */
            font-size: 0.75rem;
            font-weight: 600;
        }

        .tag-emotion {
            background-color: color-mix(in srgb, var(--primary) 20%, transparent);
            color: var(--primary);
        }

        .tag-pace {
            background-color: color-mix(in srgb, var(--secondary) 20%, transparent);
            color: var(--secondary);
        }

/* --- ESTILOS DO CONTE√öDO DO ACORDE√ÉO --- */
        .generated-content-wrapper {
            background-color: var(--dark-bg);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--dark-border);
            line-height: 1.6;
            margin-bottom: 1.5rem;
        }

        .accordion-body > div > div { /* Alvo: container de cada passo */
            padding-top: 1.5rem;
            padding-bottom: 1.5rem;
            border-top: 1px dashed var(--dark-border);
        }

        .accordion-body > div > div:first-child {
            border-top: none; /* Remove a borda do primeiro item */
            padding-top: 0;
        }

        .accordion-body h5 {
            font-size: 1rem;
            font-weight: 700;
            color: var(--dark-text-header);
            margin-bottom: 0.25rem;
        }

        .accordion-body p.text-xs {
            font-size: 0.8rem;
            color: var(--dark-text-muted);
            margin-bottom: 1rem;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }


                /* --- AN√ÅLISE DE RETEN√á√ÉO STYLES --- */
        .retention-paragraph-live {
            position: relative;
            padding: 0.5rem;
            border-radius: 6px;
            transition: background-color 0.3s;
            cursor: default;
        }

        .retention-green { background-color: color-mix(in srgb, var(--success) 10%, transparent); }
        .retention-yellow { background-color: color-mix(in srgb, #f59e0b 15%, transparent); }
        .retention-red { background-color: color-mix(in srgb, var(--danger) 15%, transparent); }

        .retention-tooltip {
            position: absolute;
            bottom: 100%;
            left: 0;
            transform: translateY(-10px);
            background-color: var(--dark-surface);
            color: var(--dark-text-body);
            padding: 0.75rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            width: 90%;
            z-index: 10;
            font-size: 0.8rem;
            border: 1px solid var(--dark-border);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, transform 0.3s;
        }
        
        /* NOVO ESTILO PARA O BOT√ÉO DENTRO DO TOOLTIP */
        .retention-tooltip .optimize-btn {
            display: block;
            width: 100%;
            margin-top: 0.75rem;
            padding: 0.5rem;
            border: none;
            background-color: var(--primary);
            color: white;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
        }
        .retention-tooltip .optimize-btn:hover {
            background-color: var(--primary-dark);
        }

        /* A M√ÅGICA DO MOUSE-HOVER */
        .retention-paragraph-live:hover .retention-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(-5px);
        }

        /* EFEITO DE DESTAQUE PARA GRUPOS */
        .highlight-group {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
            box-shadow: 0 0 15px color-mix(in srgb, var(--primary) 30%, transparent);
        }

        /* A M√ÅGICA DO MOUSE-HOVER */
        .retention-paragraph-live:hover .retention-tooltip,
        .retention-paragraph-live:hover .retention-action-btn {
            opacity: 1;
            visibility: visible;
            transform: translateY(-50%) scale(1); /* para o bot√£o */
        }
        
        .retention-paragraph-live:hover .retention-tooltip {
             transform: translateY(-5px); /* para o tooltip */
        }

        /* --- ESTILO PARA O GRUPO DE SUGEST√ïES DESTACADO --- */
        .highlight-group {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
            box-shadow: 0 0 15px color-mix(in srgb, var(--primary) 30%, transparent);
        }



    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow-sm">
            <div class="container mx-auto px-4 py-4 flex justify-between items-center">
                <h1 class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">
                    <i class="fas fa-video mr-2"></i>Gerador de Roteiros Virais
                </h1>
                <div class="flex items-center space-x-4">
                    <button id="darkModeToggle" class="theme-toggle">
                        <i id="moonIcon" class="fas fa-moon text-gray-700 dark:text-gray-300"></i>
                        <i id="sunIcon" class="fas fa-sun text-gray-700 dark:text-gray-300 hidden"></i>
                    </button>
                </div>
            </div>
        </header>

        <!-- Progress Bar -->
        <div class="container mx-auto px-4 py-4">
            <div class="mb-6">
                <div class="flex justify-between text-sm mb-1">
                    <span>Progresso do Projeto</span>
                    <span id="progressText">0%</span>
                </div>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <main class="container mx-auto px-4 pb-20">
            <!-- Estrat√©gia Section -->


<!-- SE√á√ÉO 0: INSPIRA√á√ÉO (BRAINSTORM) -->
<section id="inspirationSection" class="mb-12">
    <div class="text-center mb-8">
        <h2 class="text-2xl font-bold mb-2">Precisa de Inspira√ß√£o?</h2>
        <p class="text-gray-600 dark:text-gray-400">Comece por aqui. Descreva o nicho ou os temas gerais do seu canal e deixe a IA sugerir v√≠deos com alto potencial.</p>
    </div>
    <div class="card">
        <div class="input-group">
            <label for="nicheDescription">Nicho do Canal ou Temas de Interesse:</label>
            <textarea id="nicheDescription" rows="4" placeholder="Ex: Arqueologia B√≠blica e mist√©rios n√£o resolvidos; Finan√ßas pessoais para jovens crist√£os; An√°lise de serm√µes e teologia pr√°tica..."></textarea>
        </div>
        <div class="text-center mt-6">
            <button id="generateIdeasBtn" class="btn btn-primary">
                <i class="fas fa-lightbulb mr-2"></i>Gerar Ideias de V√≠deo
            </button>
        </div>
        
        <!-- Container para a sa√≠da das ideias -->
        <div id="ideasOutput" class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- As ideias geradas pela IA aparecer√£o aqui -->
        </div>
    </div>
</section>

<!-- Linha divis√≥ria -->
<div class="relative flex py-5 items-center">
    <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
    <span class="flex-shrink mx-4 text-gray-400 dark:text-gray-500 font-semibold">OU COMECE DIRETAMENTE AQUI</span>
    <div class="flex-grow border-t border-gray-300 dark:border-gray-700"></div>
</div>


<!-- ================================================================= -->
<!-- SUBSTITUA SUA SE√á√ÉO 1 INTEIRA POR ESTE BLOCO CORRIGIDO -->
<!-- ================================================================= -->

<!-- SE√á√ÉO 1: DEFINIR ESTRAT√âGIA -->
<section class="mb-10">
    <div class="section-title">
        <h2 class="text-xl font-bold">1. Definir Estrat√©gia</h2>
    </div>
    
    <!-- A navega√ß√£o das abas (continua a mesma) -->
    <div class="border-b border-gray-200 dark:border-gray-700 mb-6">
        <nav id="inputTabsNav" class="-mb-px flex flex-wrap md:flex-nowrap space-x-6" aria-label="Tabs">
            <button data-tab="input-tab-basico" class="tab-button tab-active">
                <i class="fas fa-info-circle mr-2"></i> B√°sico
            </button>
            <button data-tab="input-tab-estrategia" class="tab-button">
                <i class="fas fa-lightbulb mr-2"></i> Estrat√©gia Narrativa
            </button>
            <button data-tab="input-tab-tecnicos" class="tab-button">
                <i class="fas fa-sliders-h mr-2"></i> Detalhes T√©cnicos
            </button>
        </nav>
    </div>
    
    <!-- O conte√∫do das abas (AGORA CORRIGIDO) -->
    <div id="inputTabContent" class="card">
        <!-- Aba 1: B√°sico -->
        <div id="input-tab-basico" class="tab-pane active-pane">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="input-group"><label for="channelName">Nome do Canal:</label><input type="text" id="channelName" value="The Biblical Unveiling"></div>
                <div class="input-group"><label for="videoTheme">Tema do V√≠deo:</label><input type="text" id="videoTheme" placeholder="Ex: A Arca da Alian√ßa Foi Encontrada?"></div>
                <div class="input-group"><label for="languageSelect">Idioma do Roteiro:</label><select id="languageSelect"><option value="pt-br">Portugu√™s (Brasil)</option><option value="en" selected>English</option></select></div>
                <div class="input-group"><label for="videoDuration">Dura√ß√£o Desejada:</label><select id="videoDuration"><option value="">-- Selecione --</option><option value="short">Curto (~1-3 min)</option><option value="medium">M√©dio (~4-7 min)</option><option value="long">Longo (~8-12 min)</option></select></div>
                <div class="input-group md:col-span-2"><label for="videoDescription">Descri√ß√£o do V√≠deo (para inspira√ß√£o):</label><textarea id="videoDescription" rows="4" placeholder="Cole uma breve descri√ß√£o do v√≠deo aqui..."></textarea></div>
            </div>
        </div>

        <!-- Aba 2: Estrat√©gia Narrativa -->
        <div id="input-tab-estrategia" class="tab-pane hidden"> <!-- A classe 'hidden' √© importante -->
             <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="input-group md:col-span-2"><label for="targetAudience">P√∫blico-Alvo:</label><input type="text" id="targetAudience" value="Interessados em mist√©rios e hist√≥ria." readonly></div>
                <div class="input-group"><label for="narrativeGoal">1. Objetivo da Narrativa:</label><select id="narrativeGoal"><option value="storytelling">Storytelling</option><option value="storyselling">Storyselling</option></select></div>
                <div class="input-group"><label for="narrativeStructure">2. Estrutura Espec√≠fica:</label><select id="narrativeStructure"></select></div>
                <div class="input-group md:col-span-2"><label for="narrativeTheme">3. Tema Principal:</label><input type="text" id="narrativeTheme" placeholder="Ex: Supera√ß√£o, Luta contra injusti√ßa..."></div>
                <div class="input-group"><label for="narrativeTone">4. Tom da Narra√ß√£o:</label><select id="narrativeTone"><option value="inspirador" selected>Inspirador</option><option value="serio">S√©rio</option><option value="emocional">Emocional</option></select></div>
                 <div class="input-group"><label for="narrativeVoice">5. Voz do Narrador:</label><input type="text" id="narrativeVoice" placeholder="Ex: S√°bio e experiente..."></div>
                <div class="input-group md:col-span-2"><label for="centralQuestion">Pergunta Central (Opcional):</label><textarea id="centralQuestion" rows="2" placeholder="Qual a pergunta que o seu v√≠deo deve responder?"></textarea></div>
                <div class="input-group md:col-span-2"><label for="emotionalArc">Arco Emocional Desejado (Opcional):</label><textarea id="emotionalArc" rows="2" placeholder="Ex: Curiosidade -> Tens√£o -> Surpresa"></textarea></div>
                <div class="input-group md:col-span-2"><label for="shockingEndingHook">O Desfecho Chocante (Hook Opcional):</label><input type="text" id="shockingEndingHook" placeholder="Ex: ...e foi por isso que a Arca nunca deveria ser encontrada."></div>
             </div>
        </div>

        <!-- Aba 3: Detalhes T√©cnicos -->
        <div id="input-tab-tecnicos" class="tab-pane hidden"> <!-- A classe 'hidden' √© importante -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                 <div class="input-group"><label for="languageStyle">Estilo de Linguagem:</label><select id="languageStyle"><option value="inspirador" selected>Inspirador</option><option value="formal">Formal</option></select></div>
                <div class="input-group"><label for="videoObjective">Objetivo do V√≠deo:</label><select id="videoObjective"><option value="informar" selected>Informar</option><option value="emocionar">Emocionar</option></select></div>
                 <div class="input-group"><label for="speakingPace">Ritmo de Fala:</label><select id="speakingPace"><option value="moderate" selected>Moderado</option><option value="slow">Lento</option><option value="fast">R√°pido</option></select></div>
                <div class="input-group md:col-span-2"><label for="imageDescriptionEngine">Motor de Descri√ß√£o de Imagem:</label><textarea id="imageDescriptionEngine" rows="2" placeholder="Ex: 'fotografias reais', 'close-up emocional'"></textarea></div>
                <div class="input-group md:col-span-2"><label for="imageStyleSelect">Motor de Qualidade de Imagem:</label><select id="imageStyleSelect"><option value="cinematic" selected>Cinematogr√°fico</option><option value="custom">Personalizado</option><option value="none">Nenhum</option></select></div>
            </div>
        </div>
    </div>
    
    <!-- O bot√£o final (continua o mesmo) -->
    <div class="mt-6 text-center">
        <button id="analyzeStrategyBtn" class="btn btn-primary"><i class="fas fa-cogs"></i> Definir Estrat√©gia com IA</button>
    </div>
</section>

<!-- PAINEL DO PROJETO (inicialmente escondido) -->
<div id="projectDashboard" class="hidden mt-12">

    <!-- SE√á√ÉO 2: CRIAR ROTEIRO -->
    <section class="mb-10">
        <div class="section-title"><h2 class="text-xl font-bold">2. Criar Roteiro</h2></div>
        
        <!-- Card do Esbo√ßo Estrat√©gico -->
        <div id="strategicOutlineCard" class="card card-placeholder mb-6"> <!-- CLASSE ADICIONADA AQUI -->
            <div class="flex justify-between items-center mb-3">
                <h3 class="font-semibold text-lg">Esbo√ßo Estrat√©gico</h3>
                <button id="generateOutlineBtn" class="btn btn-secondary btn-small">Criar Esbo√ßo</button>
            </div>
            <div id="outlineContent"><div class="asset-card-placeholder">Clique para gerar o esbo√ßo.</div></div>
        </div>
        
        <!-- Container onde os placeholders do roteiro (Introdu√ß√£o, etc.) ser√£o injetados -->
        <div id="scriptSectionsContainer" class="space-y-4"></div>
    </section>

    <!-- SE√á√ÉO 3: RECURSOS E METADADOS -->
    <section>
        <div class="section-title"><h2 class="text-xl font-bold">3. Recursos e Metadados</h2></div>
        
        <!-- Mapa Emocional -->
        <div class="card card-placeholder mb-6"> <!-- CLASSE ADICIONADA AQUI -->
             <div class="flex justify-between items-center mb-3">
                <h3 class="font-semibold text-lg">Mapa Emocional</h3>
                <button id="mapEmotionsBtn" class="btn btn-secondary btn-small">Mapear</button>
            </div>
            <div id="emotionalMapContent"><div class="asset-card-placeholder">Gere o roteiro completo para habilitar.</div></div>
        </div>

        <!-- Grid para os outros recursos -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            
            <!-- T√≠tulos & Thumbnails -->
            <div class="card card-placeholder"> <!-- CLASSE ADICIONADA AQUI -->
                <div class="flex justify-between items-center mb-3">
                    <h3 class="font-semibold text-lg">T√≠tulos & Thumbnails</h3>
                    <button id="generateTitlesAndThumbnailsBtn" class="btn btn-secondary btn-small">Gerar</button>
                </div>
                <div id="titlesThumbnailsContent"><div class="asset-card-placeholder">Gere o roteiro para habilitar.</div></div>
            </div>

            <!-- Descri√ß√£o & Hashtags -->
            <div class="card card-placeholder"> <!-- CLASSE ADICIONADA AQUI -->
                <div class="flex justify-between items-center mb-3">
                    <h3 class="font-semibold text-lg">Descri√ß√£o & Hashtags</h3>
                    <button id="generateDescriptionBtn" class="btn btn-secondary btn-small">Gerar</button>
                </div>
                <div id="videoDescriptionContent"><div class="asset-card-placeholder">Gere o roteiro para habilitar.</div></div>
            </div>

            <!-- Trilha Sonora -->
            <div class="card card-placeholder md:col-span-2"> <!-- CLASSE ADICIONADA AQUI -->
                <div class="flex justify-between items-center mb-3">
                    <h3 class="font-semibold text-lg">Trilha Sonora</h3>
                    <button id="generateSoundtrackBtn" class="btn btn-secondary btn-small">Gerar</button>
                </div>
                <div id="soundtrackContent"><div class="asset-card-placeholder">Gere o roteiro para habilitar.</div></div>
            </div>
        </div>
    </section>
</div>
        </main>

        <!-- Floating Action Bar -->
        <div class="floating-action-bar">
            <button class="theme-toggle bg-indigo-500 text-white">
                <i class="fas fa-save"></i>
            </button>
        </div>

        <!-- Toast Notification -->
        <div id="toast" class="toast">
            <span id="toastMessage">Mensagem de notifica√ß√£o</span>
        </div>
    </div>

    <!-- Confirmation Dialog Overlay -->
        <div id="confirmationDialogOverlay" style="display: none; position: fixed; inset: 0; background-color: rgba(0,0,0,0.7); z-index: 2000; align-items: center; justify-content: center;">
            <div class="card max-w-sm w-full animate-fade-in">
                <h3 id="confirmationTitle" class="text-xl font-bold mb-4">T√≠tulo da Confirma√ß√£o</h3>
                <p id="confirmationMessage" class="mb-6">Deseja limpar o trabalho j√° realziado?</p>
                <div class="flex justify-end gap-4">
                    <button id="confirmBtnNo" class="btn btn-secondary">N√£o</button>
                    <button id="confirmBtnYes" class="btn btn-primary">Sim</button>
                </div>
            </div>
        </div>




    <script type="module">

        // ==========================================================
        // ==================== SETUP INICIAL =======================
        // ==========================================================
        // Vari√°veis de estado globais
        let generatedTitlesAndThumbnails = null;
        let allImagePrompts = {}; 
        let strategicOutline = null;
        let elements = {};
        let buttons = {};
        let totalScriptSeconds = 0;
        let promptPaginationState = {};
        let isSettingStrategy = false; // <-- NOSSO NOVO SINALIZADOR
    
        // Bloco de estilo cinematogr√°fico para prompts de imagem
        const CINEMATIC_STYLE_BLOCK = `
Ultra-realistic, high-resolution photographic image. Captured with natural lighting and cinematic composition. Rich textures and fine surface details ‚Äî visible skin pores, fabric fibers, weathered materials, realistic reflections, and organic imperfections. Sharp focus with subtle depth of field. True-to-life colors with refined tonal range. Every element should look authentic, physical, and believable ‚Äî as if taken with a high-end DSLR camera. No exaggerated features, no artificial smoothness ‚Äî only pure, grounded realism.`;
        // Labels para descri√ß√£o de imagem em diferentes idiomas
        const imageDescriptionLabels = { 'pt-br': 'Descri√ß√£o da Imagem:', 'pt-pt': 'Descri√ß√£o da Imagem:', 'en': 'Image Description:' };

// ==========================================================
        // NOVO: MAPA DE CONTAGEM DE PALAVRAS PARA CONTROLAR DURA√á√ÉO
        // ==========================================================
        const wordCountMap = {
            // ~2.5 min @ 150 WPM = ~375 palavras
            'short': {
                intro: 60,
                development: 190,
                climax: 75,
                conclusion: 50
            },
            // ~5.5 min @ 150 WPM = ~825 palavras
            'medium': {
                intro: 120,
                development: 420,
                climax: 165,
                conclusion: 120
            },
            // ~10 min @ 150 WPM = ~1500 palavras
            'long': {
                intro: 225,
                development: 750,
                climax: 300,
                conclusion: 225
            },
            // ~16 min @ 150 WPM = ~2400 palavras
            'extra-long': {
                intro: 360,
                development: 1200,
                climax: 480,
                conclusion: 360
            },
            // ~30 min @ 150 WPM = ~4500 palavras
            'documentary': {
                intro: 450,
                development: 2700,
                climax: 900,
                conclusion: 450
            }
        };


        // ==========================================================
        // ================== FUN√á√ïES DE UTILIDADE ==================
        // ==========================================================
        /**
         * Exibe uma notifica√ß√£o toast na parte inferior da tela.
         * @param {string} message - A mensagem a ser exibida.
         */
        window.showToast = (message) => {
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');
    if (!toast || !toastMessage) return;
    toastMessage.textContent = message;
    toast.classList.add('show');
    setTimeout(() => { toast.classList.remove('show'); }, 3000);
};


// =========================================================================
        // PASSO 2: ADICIONE ESTA NOVA FUN√á√ÉO INTELIGENTE AO SEU SCRIPT
        // =========================================================================
        window.optimizeGroup = async (button, suggestionText) => {
            const safeSelector = suggestionText.replace(/"/g, '\\"');
            const paragraphsToOptimize = document.querySelectorAll(`[data-suggestion-group="${safeSelector}"]`);

            if (paragraphsToOptimize.length === 0) {
                window.showToast("Erro: par√°grafos para otimizar n√£o encontrados.");
                return;
            }

            const originalButtonText = button.innerHTML;
            button.innerHTML = '<div class="loading-spinner" style="width:16px; height:16px; border-width: 2px; margin: auto;"></div>';
            button.disabled = true;

            try {
                const originalBlock = Array.from(paragraphsToOptimize).map(p => p.textContent.trim()).join('\n\n');
                const prompt = `Voc√™ √© um Roteirista especialista em reescrita. Sua tarefa √© pegar um bloco de par√°grafos e reescrev√™-lo para corrigir um problema espec√≠fico, mantendo a mensagem central.
                
                **PROBLEMA A SER CORRIGIDO (Sugest√£o):** "${suggestionText}"
                **BLOCO DE TEXTO ORIGINAL:**
                ---
                ${originalBlock}
                ---

                **REGRAS:**
                1. Reescreva o bloco de texto inteiro para que ele flua melhor e resolva o problema apontado na sugest√£o.
                2. Voc√™ pode juntar par√°grafos, dividi-los ou reorden√°-los se isso melhorar a clareza e o impacto.
                3. Responda APENAS com o novo bloco de texto reescrito. Sem coment√°rios ou introdu√ß√µes.`;

                const rawResult = await callGroqAPI(prompt, 2000);
                const newContent = removeMetaComments(rawResult.trim());
                const newParagraphs = newContent.split('\n').filter(p => p.trim() !== '');

                const firstParagraph = paragraphsToOptimize[0];
                const contentWrapper = firstParagraph.parentElement;
                
                // Substitui o primeiro par√°grafo e aplica as classes de sucesso
                firstParagraph.textContent = newParagraphs[0] || '';
                firstParagraph.className = 'retention-paragraph-live retention-green highlight-change';
                firstParagraph.removeAttribute('data-suggestion-group');

                // Adiciona os novos par√°grafos (se houver mais de um)
                let lastElement = firstParagraph;
                for (let i = 1; i < newParagraphs.length; i++) {
                    const newDiv = document.createElement('div');
                    newDiv.textContent = newParagraphs[i];
                    // >>>>> AQUI EST√Å A CORRE√á√ÉO M√ÅGICA <<<<<
                    // Aplica as mesmas classes de sucesso aos par√°grafos adicionais
                    newDiv.className = 'retention-paragraph-live retention-green highlight-change';
                    contentWrapper.insertBefore(newDiv, lastElement.nextSibling);
                    lastElement = newDiv;
                }

                // Remove os par√°grafos antigos restantes
                for (let i = 1; i < paragraphsToOptimize.length; i++) {
                    paragraphsToOptimize[i].remove();
                }

                window.showToast("Bloco de par√°grafos otimizado!");

            } catch (error) {
                window.showToast(`Falha ao otimizar: ${error.message}`);
                button.innerHTML = 'Erro!';
            }
        };


// ==========================================================
    // ================== FUN√á√ïES DE UTILIDADE E UI ==================
    // ==========================================================
    
    // ... (suas fun√ß√µes existentes como showToast, updateProgressBar, etc.)


        /**
         * Percorre todas as se√ß√µes de roteiro geradas e atualiza o tempo de leitura exibido.
         */
        const updateAllReadingTimes = () => {
            // Pega todas as se√ß√µes de roteiro que j√° foram geradas
            const scriptSections = document.querySelectorAll('#scriptSectionsContainer .accordion-item');
            
            scriptSections.forEach(item => {
                const contentWrapper = item.querySelector('.generated-content-wrapper');
                const timeDisplay = item.querySelector('.header-content .text-xs'); // Alvo espec√≠fico do tempo

                if (contentWrapper && timeDisplay) {
                    const newTime = calculateReadingTime(contentWrapper.textContent);
                    timeDisplay.textContent = newTime;
                }
            });
        }


     /**
     * Valida os inputs essenciais antes de gerar conte√∫do.
     * Busca os elementos no momento da execu√ß√£o para garantir que existam.
     */
    const validateInputs = () => {
        const channelName = document.getElementById('channelName')?.value.trim();
        const videoTheme = document.getElementById('videoTheme')?.value.trim();
        const videoDescription = document.getElementById('videoDescription')?.value.trim();
        const videoDuration = document.getElementById('videoDuration')?.value;

        if (!channelName) {
            window.showToast("Por favor, insira o nome do canal.");
            return false;
        }
        if (!videoTheme) {
            window.showToast("Por favor, insira o tema do v√≠deo.");
            return false;
        }
        if (!videoDescription) {
            window.showToast("Por favor, insira a descri√ß√£o do v√≠deo (para inspira√ß√£o).");
            return false;
        }
        if (!videoDuration || videoDuration === "") {
            window.showToast("Por favor, selecione a Dura√ß√£o Desejada do v√≠deo.");
            return false;
        }
        return true;
    };



/**
         * Limpa apenas os outputs gerados do projeto, mantendo os inputs principais.
         */
        const resetProjectOutputs = () => {
            console.log("Resetando outputs do projeto para nova estrat√©gia...");

            // Limpa vari√°veis de estado
            strategicOutline = null;
            allImagePrompts = {};
            generatedTitlesAndThumbnails = null;
            totalScriptSeconds = 0;
            promptPaginationState = {};
            window.emotionalMap = null;

            // Limpa a UI dos outputs
            const contentContainers = [
                'scriptSectionsContainer', 'outlineContent', 'titlesThumbnailsContent', 
                'videoDescriptionContent', 'soundtrackContent', 'emotionalMapContent'
            ];
            
            contentContainers.forEach(id => {
                const container = document.getElementById(id);
                if (container) {
                    if (id === 'scriptSectionsContainer') {
                        // RECONSTR√ìI os placeholders em vez de apenas limpar
                        container.innerHTML = `
                            <div id="introSection" class="script-section"></div>
                            <div id="developmentSection" class="script-section"></div>
                            <div id="climaxSection" class="script-section"></div>
                            <div id="conclusionSection" class="script-section"></div>
                            <div id="ctaSection" class="script-section hidden"></div> 
                        `;
                    } else {
                        // Recria o placeholder se ele existir
                        const placeholderText = {
                            'outlineContent': "Clique em 'Criar Esbo√ßo' para a IA planejar a estrutura do roteiro.",
                            'titlesThumbnailsContent': "Clique em 'Gerar' para ver as sugest√µes",
                            'videoDescriptionContent': "Clique em 'Gerar' para ver a descri√ß√£o",
                            'soundtrackContent': "Clique em 'Gerar' para criar sugest√µes de trilha para o roteiro completo.",
                            'emotionalMapContent': "Clique em 'Mapear' para a IA analisar a jornada emocional do roteiro."
                        };
                        container.innerHTML = `<div class="asset-card-placeholder">${placeholderText[id] || ''}</div>`;
                    }
                }
            });

            // Adiciona a l√≥gica para resetar os bot√µes
            resetCompletionIcons();
            updateProgressBar();
            
            const conclusionModule = document.getElementById('conclusionStrategyModule');
            if(conclusionModule) conclusionModule.classList.add('hidden');
        };


        /**
         * Exibe uma caixa de di√°logo de confirma√ß√£o e aguarda a resposta do usu√°rio.
         * @param {string} title - O t√≠tulo da caixa de di√°logo.
         * @param {string} message - A mensagem de confirma√ß√£o.
         * @returns {Promise<boolean>} - Retorna true se o usu√°rio clicar "Sim", false caso contr√°rio.
         */
        const showConfirmationDialog = (title, message) => {
            return new Promise(resolve => {
                const overlay = document.getElementById('confirmationDialogOverlay');
                const titleEl = document.getElementById('confirmationTitle');
                const messageEl = document.getElementById('confirmationMessage');
                const btnYes = document.getElementById('confirmBtnYes');
                const btnNo = document.getElementById('confirmBtnNo');

                // Garante que todos os elementos existem antes de continuar
                if (!overlay || !titleEl || !messageEl || !btnYes || !btnNo) {
                    console.error("Elementos do pop-up de confirma√ß√£o n√£o foram encontrados no HTML.");
                    resolve(false); // Resolve como 'false' para n√£o travar a aplica√ß√£o
                    return;
                }

                titleEl.textContent = title;
                messageEl.textContent = message;
                overlay.style.display = 'flex';

                // Fun√ß√£o para limpar e fechar o di√°logo
                const closeDialog = (result) => {
                    overlay.style.display = 'none';
                    // Remove os listeners para evitar chamadas duplicadas
                    clonedBtnYes.replaceWith(btnYes);
                    clonedBtnNo.replaceWith(btnNo);
                    resolve(result);
                };

                // TRUQUE PARA GARANTIR LISTENERS LIMPOS:
                // Clonamos os bot√µes para remover quaisquer event listeners antigos
                const clonedBtnYes = btnYes.cloneNode(true);
                const clonedBtnNo = btnNo.cloneNode(true);

                // Adicionamos os novos listeners aos clones
                clonedBtnYes.addEventListener('click', () => closeDialog(true));
                clonedBtnNo.addEventListener('click', () => closeDialog(false));

                // Substitu√≠mos os bot√µes originais pelos clones com os novos listeners
                btnYes.replaceWith(clonedBtnYes);
                btnNo.replaceWith(clonedBtnNo);
            });
        };

        /**
         * Compara um texto gerado pela IA (com anota√ß√µes) com o texto original
         * para garantir que o conte√∫do n√£o foi alterado.
         * @param {string} originalText - O texto base.
         * @param {string} annotatedText - O texto com anota√ß√µes gerado pela IA.
         * @returns {{isValid: boolean, cleanTextFromAI: string}} - Retorna se √© v√°lido e o texto da IA sem anota√ß√µes.
         */
        const auditGeneratedText = (originalText, annotatedText) => {
            // Remove todas as anota√ß√µes [em colchetes] do texto da IA
            const cleanTextFromAI = annotatedText.replace(/\[.*?\]/g, '').trim();
            
            // Remove m√∫ltiplos espa√ßos e quebras de linha para uma compara√ß√£o mais justa
            const normalizedOriginal = originalText.replace(/\s+/g, ' ').trim();
            const normalizedCleanAI = cleanTextFromAI.replace(/\s+/g, ' ').trim();

            // Compara os dois textos normalizados
            const isValid = normalizedOriginal === normalizedCleanAI;
            
            return { isValid, cleanTextFromAI };
        };


        /**
         * Copia um texto para a √°rea de transfer√™ncia.
         * @param {string} text - O texto a ser copiado.
         */
        window.copyTextToClipboard = async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                window.showToast('Copiado!');
            } catch (err) {
                // Fallback para navegadores mais antigos ou contextos restritos (ex: iframes)
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                document.body.appendChild(ta);
                ta.focus();
                ta.select();
                try {
                    document.execCommand('copy');
                    window.showToast('Copiado!');
                } finally {
                    document.body.removeChild(ta);
                }
            }
        };

        /**
         * Fornece feedback visual em um bot√£o ap√≥s uma a√ß√£o de c√≥pia.
         * @param {HTMLElement} buttonElement - O elemento do bot√£o que foi clicado.
         */
        window.showCopyFeedback = (buttonElement) => {
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = 'Copiado!';
            buttonElement.classList.add('btn-success');
            buttonElement.disabled = true; // Desabilita o bot√£o temporariamente

            setTimeout(() => {
                buttonElement.innerHTML = originalText;
                buttonElement.classList.remove('btn-success');
                buttonElement.disabled = false;
            }, 2000); // Reverte ap√≥s 2 segundos
        };



        // ==========================================================
        // >>>>> ADICIONE ESTE NOVO BLOCO <<<<<
        // ==========================================================
        /**
         * Mostra um spinner de carregamento em QUALQUER bot√£o, salvando seu conte√∫do original.
         * @param {HTMLElement} button - O elemento do bot√£o a ser modificado.
         */
        const showButtonLoading = (button) => {
            if (!button) return;
            // Salva o HTML original do bot√£o (incluindo √≠cones e texto)
            button.setAttribute('data-original-html', button.innerHTML);
            button.disabled = true;
            // Define o spinner como o novo conte√∫do.
            button.innerHTML = '<div class="loading-spinner" style="width:18px; height:18px; border-width: 2px;"></div>';
        };

        /**
         * Esconde o spinner de carregamento de um bot√£o, restaurando seu conte√∫do original.
         * @param {HTMLElement} button - O elemento do bot√£o a ser restaurado.
         */
        const hideButtonLoading = (button) => {
            if (!button) return;
            // Restaura o HTML original que salvamos
            if (button.hasAttribute('data-original-html')) {
                button.innerHTML = button.getAttribute('data-original-html');
                button.removeAttribute('data-original-html');
            }
            button.disabled = false;
        };

        /**
         * Marca um bot√£o (original e flutuante) como conclu√≠do (cor verde).
         * @param {string} originalId - O ID do bot√£o original.
         */
        const markButtonAsCompleted = (originalId) => {
            const originalButton = document.getElementById(originalId);
            const floatButton = document.getElementById(`float_${originalId}`);

            [originalButton, floatButton].forEach(btn => {
                if (btn) {
                    btn.classList.remove('btn-primary', 'btn-secondary');
                    btn.classList.add('btn-success');
                }
            });
            updateProgressBar(); 
        };



        /**
         * Reseta os √≠cones de conclus√£o de todos os bot√µes (original e flutuante) para suas cores padr√£o.
         */
        const resetCompletionIcons = () => {
            const passo1_buttons_ids = ['generateIntroBtn', 'generateDevelopmentBtn', 'climaxBtn', 'conclusionBtn', 'generateCTABtn'];
            
            for (const buttonId in buttons) { // Iterar sobre todos os bot√µes
                const isPasso1 = passo1_buttons_ids.includes(buttonId);
                const originalButton = document.getElementById(buttonId);
                const floatButton = document.getElementById(`float_${buttonId}`);

                // Remove a classe de sucesso e adiciona a classe correta (primary/secondary)
                [originalButton, floatButton].forEach(btn => {
                    if (btn) {
                        btn.classList.remove('btn-success');
                        if (isPasso1) {
                            btn.classList.remove('btn-secondary');
                            btn.classList.add('btn-primary');
                        } else {
                            btn.classList.remove('btn-primary');
                            btn.classList.add('btn-secondary');
                        }
                    }
                });
            }
        };
        
        /**
         * Verifica se as se√ß√µes principais do roteiro foram geradas.
         * @returns {boolean} True se todas as se√ß√µes principais foram geradas, caso contr√°rio, false.
         */
        const isScriptComplete = () => {
            return ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection'].every(id => { // CTA is now part of conclusionSection
                const section = document.getElementById(id);
                return section && !section.classList.contains('hidden') && section.querySelector('.generated-content-wrapper')?.textContent.trim() !== '';
            });
        };

        /**
         * Atualiza o estado de habilita√ß√£o/desabilita√ß√£o dos bot√µes com base no estado do roteiro. (VERS√ÉO CORRIGIDA)
         */
        const updateButtonStates = () => {
            const allMainScriptGenerated = isScriptComplete();
            const buttonsToToggle = ['generateTitlesAndThumbnailsBtn', 'mapEmotionsBtn', 'generateDescriptionBtn', 'generateSoundtrackBtn'];
            
            buttonsToToggle.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = !allMainScriptGenerated;
            });

            // L√≥gica para mostrar/esconder o m√≥dulo de conclus√£o
            const introSec = document.getElementById('introSection');
            const devSec = document.getElementById('developmentSection');
            const climaxSec = document.getElementById('climaxSection');

            const mainSectionsDone = 
                (introSec && introSec.innerHTML.trim() !== '') &&
                (devSec && devSec.innerHTML.trim() !== '') &&
                (climaxSec && climaxSec.innerHTML.trim() !== '');

            const conclusionModule = document.getElementById('conclusionStrategyModule');
            if (conclusionModule) {
                if (mainSectionsDone && conclusionModule.classList.contains('hidden')) { 
                    
                    const climaxSection = document.getElementById('climaxSection');
                    if (climaxSection) {
                        climaxSection.parentNode.insertBefore(conclusionModule, climaxSection.nextSibling);
                    }
                    
                    conclusionModule.classList.remove('hidden');
                    conclusionModule.classList.add('animate-fade-in');
                    
                    // ==========================================================
                    // >>>>> A CORRE√á√ÉO CR√çTICA EST√Å AQUI <<<<<
                    // ==========================================================
                    // Agora que o m√≥dulo est√° vis√≠vel, N√ìS CONFIGURAMOS OS LISTENERS.
                    document.querySelectorAll('input[name="conclusionType"]').forEach(radio => {
                        radio.addEventListener('change', handleConclusionStrategyChange);
                    });
                    // E chamamos a fun√ß√£o uma vez para definir o estado inicial.
                    handleConclusionStrategyChange();
                    // ==========================================================

                    conclusionModule.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    window.showToast("√öltimo passo: Defina o objetivo da sua conclus√£o!");

                } else if (!mainSectionsDone && !conclusionModule.classList.contains('hidden')) {
                    conclusionModule.classList.add('hidden');
                }
            }
        };

        /**
         * Mostra um alerta em tela cheia com uma mensagem.
         * @param {string} message - A mensagem a ser exibida.
         */
        const showFullScreenAlert = (message) => {
            elements.fullScreenAlertMessage.textContent = message;
            elements.fullScreenAlertOverlay.classList.add('visible');
        };

        /** Esconde o alerta em tela cheia. */
        const hideFullScreenAlert = () => {
            elements.fullScreenAlertOverlay.classList.remove('visible');
        };

        /** Alterna a visibilidade do campo de estilo de imagem personalizado. */
        const toggleCustomImageStyleVisibility = () => {
            elements.customImageStyleContainer.style.display = elements.imageStyleSelect.value === 'custom' ? 'block' : 'none';
        };

        /**
         * Coleta e concatena o texto puro de todas as se√ß√µes do roteiro na ordem correta.
         * @returns {string} A transcri√ß√£o completa e limpa.
         */
        const getTranscriptOnly = () => {
            let transcript = '';
            const sectionOrder = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection']; // CTA is now part of conclusionSection
            
            sectionOrder.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                const contentWrapper = section?.querySelector('.generated-content-wrapper');
                if (contentWrapper?.textContent.trim()) {
                    // Adiciona o texto da se√ß√£o e duas quebras de linha para separar os par√°grafos.
                    transcript += contentWrapper.textContent.trim() + '\n\n';
                }
            });
            
            return transcript.trim();
        };
    
        /**
         * Calcula o tempo de leitura estimado de um texto, considerando o ritmo de fala.
         */
        const calculateReadingTime = (text) => {
            if (!text) return "";

            const paceMap = {
                slow: 120,
                moderate: 150,
                fast: 180
            };
            
            const selectedPace = document.getElementById('speakingPace').value || 'moderate';
            const wordsPerMinute = paceMap[selectedPace];
            
            const words = text.trim().split(/\s+/).length;
            const totalSeconds = (words / wordsPerMinute) * 60;
            
            if (totalSeconds < 1) return "";
            
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.round(totalSeconds % 60);
            
            let timeString = "~";
            if (minutes > 0) timeString += ` ${minutes} min`;
            if (seconds > 0) timeString += ` ${seconds} seg`;
            
            return timeString.trim();
        };

    // ==========================================================
        // ==================== L√ìGICA DAS ABAS =====================
        // ==========================================================
        const setupTabs = () => {
            const tabButtons = document.querySelectorAll('#tabs .tab-button');
            const tabPanes = document.querySelectorAll('#tab-content .tab-pane');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('active-tab'));
                    tabPanes.forEach(pane => pane.classList.remove('active-pane'));

                    button.classList.add('active-tab');
                    const tabId = button.getAttribute('data-tab');
                    const activePane = document.getElementById(tabId);
                    if (activePane) {
                        activePane.classList.add('active-pane');
                    }
                });
            });
        };


         /**
         * Analisa o roteiro completo para criar um "mapa emocional" para guiar a produ√ß√£o.
         */
const mapEmotionsAndPacing = async (button) => {
            const fullTranscript = getTranscriptOnly();
            if (!fullTranscript) {
                showToast("Gere o roteiro completo primeiro para criar o mapa emocional.");
                return;
            }

            const outputContainer = document.getElementById('emotionalMapContent');
            
            showButtonLoading(button);
            outputContainer.innerHTML = `<div class="loading-spinner-small mx-auto my-4"></div>`;

            const paragraphs = fullTranscript.split('\n\n').filter(p => p.trim() !== '');

            const prompt = `Voc√™ √© um Diretor de Cena. Sua tarefa √© analisar um roteiro e criar um "beat sheet" emocional. Para cada par√°grafo, defina a 'emo√ß√£o' chave e o 'ritmo' da narra√ß√£o.
            
            **REGRAS CR√çTICAS:**
            1.  Sua resposta DEVE ser um array JSON.
            2.  O array deve ter um objeto para CADA um dos ${paragraphs.length} par√°grafos do roteiro.
            3.  Cada objeto deve ter TR√äS chaves: "paragraph_index" (o n√∫mero do √≠ndice, come√ßando em 0), "emotion" (string, ex: "Curiosidade Intensa"), e "pace" (string, ex: "R√°pido e Incisivo").

            **ROTEIRO PARA ANALISAR:**
            ${paragraphs.map((p, index) => `PARAGRAFO ${index}: "${p}"`).join('\n\n')}

            Responda apenas com o array JSON, garantindo um objeto para cada par√°grafo de 0 a ${paragraphs.length - 1}.`;

            try {
                const rawResult = await callGroqAPI(prompt, 3000);
                const analysis = cleanGeneratedText(rawResult, true);

                if (!analysis || !Array.isArray(analysis) || analysis.length > paragraphs.length) {
                    throw new Error("A IA retornou um mapa emocional em formato inv√°lido ou incompleto.");
                }

                window.emotionalMap = analysis;
                
                // >>>>> GERA√á√ÉO DO HTML CORRIGIDA E MELHORADA <<<<<
                let mapHtml = '<div class="space-y-4">';
                analysis.forEach(item => {
                    const paragraphText = paragraphs[item.paragraph_index];
                    if (!paragraphText) return; // Pula se o par√°grafo n√£o existir

                    mapHtml += `
                        <div class="emotional-map-item card !p-3">
                            <p class="paragraph-preview">"${paragraphText}"</p>
                            <div class="analysis-tags">
                                <span class="tag tag-emotion">
                                    <i class="fas fa-theater-masks mr-2"></i>${item.emotion}
                                </span>
                                <span class="tag tag-pace">
                                    <i class="fas fa-tachometer-alt mr-2"></i>${item.pace}
                                </span>
                            </div>
                        </div>
                    `;
                });
                mapHtml += '</div>';
                
                outputContainer.innerHTML = mapHtml;
                markButtonAsCompleted(button.id);

            } catch (error) {
                outputContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar o mapa emocional: ${error.message}</p>`;
            } finally {
                hideButtonLoading(button);
            }
        };



            const generateSoundtrack = async (button) => {
            const fullTranscript = getTranscriptOnly();
            if (!fullTranscript) {
                window.showToast("Gere o roteiro completo primeiro para sugerir uma trilha sonora coerente.");
                return;
            }

            const outputContainer = document.getElementById('soundtrackContent');
            
            showButtonLoading(button);
            outputContainer.innerHTML = `<div class="loading-spinner-small mx-auto my-4"></div>`;

            const prompt = `Voc√™ √© um especialista em prompts para IAs de gera√ß√£o de m√∫sica (como Suno/Udio). Sua tarefa √© analisar o roteiro completo de um v√≠deo e criar 3 prompts de texto distintos e detalhados que capturem a ess√™ncia emocional da narrativa.

            **REGRAS DE FORMATA√á√ÉO (N√ÉO NEGOCI√ÅVEIS):**
            1. Sua resposta DEVE SER um array JSON v√°lido.
            2. O array deve conter EXATAMENTE 3 strings.
            3. CADA string deve ser um par√°grafo √∫nico, bem escrito e descritivo.

            **Roteiro completo para analisar:**
            ---
            ${fullTranscript}
            ---`;

            try {
                const rawResult = await callGroqAPI(prompt, 800);
                const analysis = cleanGeneratedText(rawResult, true);

                if (!analysis || !Array.isArray(analysis)) {
                    throw new Error("A IA retornou um formato de trilha sonora inesperado.");
                }

                let suggestionsHtml = '<ul class="soundtrack-list space-y-2">';
                analysis.forEach(suggestion => {
                    suggestionsHtml += `<li>${suggestion}</li>`;
                });
                suggestionsHtml += '</ul>';
                
                outputContainer.innerHTML = suggestionsHtml;
                markButtonAsCompleted(button.id);

            } catch (error) {
                outputContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar sugest√µes: ${error.message}</p>`;
            } finally {
                hideButtonLoading(button);
            }
        };



     /**
         * Gera a Conclus√£o e o CTA juntos, com base na estrat√©gia final escolhida,
         * e formata o texto corretamente para an√°lise posterior.
         */
                const generateConclusionAndCta = async (button) => {
            if (!validateInputs()) return;
            showButtonLoading(button);

            const conclusionType = document.querySelector('input[name="conclusionType"]:checked').value;
            const conclusionSpecifics = document.getElementById('conclusionSpecifics').value.trim();

            let strategyDirective = '';
            switch (conclusionType) {
                case 'lesson':
                    strategyDirective = `O objetivo √© refor√ßar uma li√ß√£o ou reflex√£o central. Detalhe fornecido pelo usu√°rio: '${conclusionSpecifics}'`;
                    break;
                case 'answer':
                    const question = elements.centralQuestion.value.trim() || 'a pergunta central do v√≠deo';
                    strategyDirective = `O objetivo √© responder de forma clara √† pergunta central do v√≠deo ('${question}'). Detalhe fornecido pelo usu√°rio: '${conclusionSpecifics}'`;
                    break;
                case 'cliffhanger':
                    strategyDirective = `O objetivo √© criar um gancho ou mist√©rio para o pr√≥ximo v√≠deo. Detalhe fornecido pelo usu√°rio: '${conclusionSpecifics}'`;
                    break;
            }
            
            const baseContext = getBasePromptContext();
            const prompt = `${baseContext}
            Voc√™ √© um mestre roteirista. Sua tarefa √© escrever a **Conclus√£o e o Call to Action (CTA)** do v√≠deo, JUNTOS, em um √∫nico bloco de texto fluido.
            **Diretiva Estrat√©gica para o Final:** ${strategyDirective}
            **REGRAS CR√çTICAS:** Responda APENAS com o texto final para ser falado. Sem metadados, sem labels (como "Conclus√£o:", "CTA:"), apenas o texto.`;

            try {
                const maxTokens = 800;
                let result = await callGroqAPI(prompt, maxTokens);
                result = removeMetaComments(result.trim());

                const paragraphs = result.split('\n').filter(p => p.trim() !== '');
                const contentWithSpans = paragraphs.map((p, index) => 
                    `<div id="conclusion-p-${index}">${p}</div>`
                ).join('');

                document.getElementById('conclusionSection').innerHTML = generateSectionHtmlContent('conclusion', 'Conclus√£o e CTA', contentWithSpans);
                document.getElementById('ctaSection').innerHTML = ''; 

                markButtonAsCompleted('conclusionBtn');
                markButtonAsCompleted('generateCTABtn');

                document.getElementById('conclusionStrategyModule').classList.add('hidden');
                window.showToast("Conclus√£o e CTA gerados com sucesso!");
                updateButtonStates();

            } catch(error) {
                window.showToast(`Falha ao gerar a conclus√£o: ${error.message}`);
            } finally {
                hideButtonLoading(button);
            }
        };

    // ==========================================================
        // NOVA FUN√á√ÉO PARA ATUALIZAR A BARRA DE PROGRESO
        // ==========================================================
                const updateProgressBar = () => {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            if (!progressFill || !progressText) return;

            const taskButtonIds = [
                'analyzeStrategyBtn',
                'generateOutlineBtn',
                'generateIntroBtn',
                'generateDevelopmentBtn',
                'climaxBtn',
                'conclusionBtn',
                'generateTitlesAndThumbnailsBtn',
                'mapEmotionsBtn',
                'generateDescriptionBtn',
                'generateSoundtrackBtn'
            ];
            const totalTasks = taskButtonIds.length;
            let completedTasks = 0;
            
            taskButtonIds.forEach(id => {
                const button = document.getElementById(id);
                if (button && button.classList.contains('btn-success')) {
                    completedTasks++;
                }
            });


            const percentage = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

            // Atualiza a UI
            if (elements.progressBar && elements.progressText) {
                elements.progressBar.style.width = `${percentage}%`;
                elements.progressText.textContent = `${percentage}%`;

                if (percentage === 100) {
                    elements.progressBar.textContent = "Projeto Pronto!"; 
                    elements.progressBar.style.color = '#ffffff';
                    elements.progressBar.style.textAlign = 'center';
                    elements.progressBar.style.backgroundColor = 'var(--primary-color)';
                } else {
                    elements.progressBar.textContent = '';
                    elements.progressBar.style.backgroundColor = 'var(--success-color)';
                }
            }
        };

        // ==========================================================
        // >>>>> SUBSTITUA SUA FUN√á√ÉO setupInputTabs POR ESTA <<<<<
        // ==========================================================
        const setupInputTabs = () => {
            const nav = document.getElementById('inputTabsNav');
            if (!nav) return;

            const tabButtons = nav.querySelectorAll('.tab-button');
            const tabPanes = document.getElementById('inputTabContent').querySelectorAll('.tab-pane');

            nav.addEventListener('click', (event) => {
                const button = event.target.closest('.tab-button');
                if (!button) return;

                // 1. Remove a classe ativa de TODOS os bot√µes
                tabButtons.forEach(btn => btn.classList.remove('tab-active'));
                
                // 2. Esconde TODOS os pain√©is de conte√∫do
                tabPanes.forEach(pane => pane.classList.add('hidden'));

                // 3. Adiciona a classe ativa APENAS no bot√£o clicado
                button.classList.add('tab-active');
                
                // 4. Mostra APENAS o painel de conte√∫do correspondente
                const tabId = button.getAttribute('data-tab');
                const activePane = document.getElementById(tabId);
                if (activePane) {
                    activePane.classList.remove('hidden');
                }
            });
        };

        const handleConclusionStrategyChange = () => {
            const conclusionSpecificsContainer = document.getElementById('conclusionInputContainer');
            const answerRadioButtonLabel = document.querySelector('input[value="answer"]').parentElement;
            const answerRadioButton = document.querySelector('input[value="answer"]');

            // 1. L√≥gica para desabilitar a op√ß√£o "Responder Pergunta" se n√£o houver pergunta
            const centralQuestionText = document.getElementById('centralQuestion').value.trim();
            if (!centralQuestionText) {
                answerRadioButton.disabled = true;
                answerRadioButtonLabel.classList.add('opacity-50', 'cursor-not-allowed');
                answerRadioButtonLabel.title = "Defina a 'Pergunta Central' nos campos principais para usar esta op√ß√£o.";
                // Se a op√ß√£o desabilitada estava selecionada, muda para a primeira
                if(answerRadioButton.checked) {
                    document.querySelector('input[value="lesson"]').checked = true;
                }
            } else {
                answerRadioButton.disabled = false;
                answerRadioButtonLabel.classList.remove('opacity-50', 'cursor-not-allowed');
                answerRadioButtonLabel.title = "";
            }
            
            const selectedValue = document.querySelector('input[name="conclusionType"]:checked').value;
            
            // 2. L√≥gica para mostrar/esconder o textarea e mudar o placeholder
            if (conclusionSpecificsContainer) {
                conclusionSpecificsContainer.classList.toggle('hidden', !['lesson', 'answer', 'cliffhanger'].includes(selectedValue));
            }
            
            const textarea = document.getElementById('conclusionSpecifics');
            if (textarea) {
                const placeholders = {
                    lesson: "Ex: A li√ß√£o √© que a resili√™ncia √© a nossa maior for√ßa...",
                    answer: "Ex: A resposta √© que a Arca foi levada para a Eti√≥pia, mas o verdadeiro segredo √©...",
                    cliffhanger: "Ex: ...mas se a Arca foi encontrada, o que aconteceu com o que estava DENTRO dela?"
                };
                textarea.placeholder = placeholders[selectedValue] || "";
            }
        };

        /**
         * Alterna a visibilidade de um corpo de acorde√£o e a rota√ß√£o de sua seta. (VERS√ÉO CORRIGIDA E ROBUSTA)
         * @param {string} bodyId - O ID do elemento do corpo do acorde√£o.
         * @param {string} arrowId - O ID do elemento da seta do acorde√£o.
         */
        window.toggleAccordion = (bodyId, arrowId) => {
            const body = document.getElementById(bodyId);
            const arrow = document.getElementById(arrowId);
            // CORRE√á√ÉO: Encontra o cabe√ßalho subindo na √°rvore DOM
            const header = body ? body.closest('.accordion-item').querySelector('.accordion-header') : null;

            if (body && arrow && header) {
                const isOpen = body.classList.toggle('open');
                arrow.classList.toggle('open', isOpen);
                header.classList.toggle('active', isOpen);
            }
        };

        /**
 * Renderiza a p√°gina correta de prompts para uma determinada se√ß√£o. (VERS√ÉO CORRIGIDA)
 * @param {string} sectionElementId - O ID da se√ß√£o (ex: 'introSection').
 */
const renderPaginatedPrompts = (sectionElementId) => {
    const sectionElement = document.getElementById(sectionElementId);
    if (!sectionElement) return;

    const itemsPerPage = 4;
    const prompts = allImagePrompts[sectionElementId] || [];
    const currentPage = promptPaginationState[sectionElementId] || 0;
    const totalPages = Math.ceil(prompts.length / itemsPerPage);

    const promptItemsContainer = sectionElement.querySelector('.prompt-items-container');
    const navContainer = sectionElement.querySelector('.prompt-nav-container');

    if (!promptItemsContainer || !navContainer) return;

    promptItemsContainer.innerHTML = ''; // Limpa o conte√∫do atual

    // --- NOVA L√ìGICA DE C√ÅLCULO GLOBAL ---
    // 1. Define o √≠ndice de in√≠cio no array completo de prompts
    const startIndex = currentPage * itemsPerPage;
    const promptsToShow = prompts.slice(startIndex, startIndex + itemsPerPage);

    // 2. Calcula a dura√ß√£o total de TODOS os prompts ANTES da p√°gina atual
    let cumulativeSeconds = 0;
    if (startIndex > 0) {
        const previousPrompts = prompts.slice(0, startIndex);
        cumulativeSeconds = previousPrompts.reduce((total, p) => total + (parseInt(p.estimated_duration, 10) || 18), 0);
    }
    // --- FIM DA NOVA L√ìGICA ---

    promptsToShow.forEach((promptData, index) => {
        const globalIndex = startIndex + index; // √çndice no array completo
        const currentSceneNumber = globalIndex + 1; // N√∫mero da cena correto

        // Calcula o timestamp para esta cena espec√≠fica
        const minutes = Math.floor(cumulativeSeconds / 60);
        const seconds = cumulativeSeconds % 60;
        const timestamp = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

        const styleBlockContent = promptData.styleBlock || '';
        const promptHtml = `
            <div class="prompt-item card !p-3 animate-fade-in">
                <div class="prompt-header">
                    <span class="tag tag-scene"><i class="fas fa-film mr-2"></i>Cena ${String(currentSceneNumber).padStart(2, '0')}</span>
                    <span class="tag tag-time"><i class="fas fa-clock mr-2"></i>${timestamp}</span>
                    <button class="copy-btn-small" onclick="copyTextToClipboard(document.getElementById('prompt-content-${sectionElementId}-${globalIndex}')?.textContent + ' ' + document.getElementById('style-block-${sectionElementId}-${globalIndex}')?.textContent); window.showCopyFeedback(this)" title="Copiar Prompt">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
                <p class="paragraph-preview">"${promptData.scriptPhrase}"</p>
                <div class="prompt-details">
                    <p class="prompt-label">${imageDescriptionLabels[elements.languageSelect.value] || 'Image Description:'}</p>
                    <p id="prompt-content-${sectionElementId}-${globalIndex}">${promptData.imageDescription}</p>
                    ${styleBlockContent ? `<p class="style-block-indicator">[Estilo Cinematogr√°fico Aplicado]</p>` : ''}
                    <pre id="style-block-${sectionElementId}-${globalIndex}" class="hidden">${styleBlockContent}</pre>
                </div>
            </div>
        `;
        promptItemsContainer.innerHTML += promptHtml;

        // Atualiza os segundos acumulados para a PR√ìXIMA itera√ß√£o do loop
        cumulativeSeconds += (parseInt(promptData.estimated_duration, 10) || 18);
    });
    
    // Atualiza os controles de navega√ß√£o (c√≥digo existente, permanece igual)
    navContainer.innerHTML = `
        <button class="btn btn-secondary btn-small" onclick="window.navigatePrompts('${sectionElementId}', -1)" ${currentPage === 0 ? 'disabled' : ''}>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/></svg>
        </button>
        <span class="text-sm font-medium text-gray-600 dark:text-gray-400">P√°gina ${currentPage + 1} de ${totalPages}</span>
        <button class="btn btn-secondary btn-small" onclick="window.navigatePrompts('${sectionElementId}', 1)" ${currentPage + 1 >= totalPages ? 'disabled' : ''}>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg>
        </button>
    `;
    
    // REMOVIDO: A chamada para reNumberAllScenes() foi removida pois agora √© desnecess√°ria
};

/**
 * Valida se o array de prompts recebido da IA tem a estrutura correta.
 * @param {any} data - O dado parseado do JSON.
 * @returns {boolean} - True se for um array v√°lido de prompts, false caso contr√°rio.
 */
const validatePromptsArray = (data) => {
    // √â um array? Ele n√£o est√° vazio? O primeiro item √© um objeto com as chaves que precisamos?
    return Array.isArray(data) && data.length > 0 && data.every(item => 
        item && typeof item === 'object' && 'scriptPhrase' in item && 'imageDescription' in item
    );
};

/**
 * Reseta o conte√∫do do roteiro gerado quando um input estrat√©gico √© alterado.
 * @param {string} sourceId - O ID do elemento que causou a mudan√ßa.
 */
const resetGeneratedScriptContent = (sourceId) => {
    // S√≥ reseta se j√° houver conte√∫do gerado para n√£o incomodar o usu√°rio no in√≠cio.
    if (!strategicOutline && !document.querySelector('#scriptSectionsContainer .accordion-item')) {
        return;
    }

    console.log(`Input estrat√©gico '${sourceId}' alterado. Resetando conte√∫do do roteiro.`);

    // 1. Limpa as vari√°veis de estado
    strategicOutline = null;
    allImagePrompts = {};
    promptPaginationState = {};
    totalScriptSeconds = 0;

    // 2. Limpa a UI do esbo√ßo e das se√ß√µes
    const outlineContent = document.getElementById('outlineContent');
    if (outlineContent) {
        outlineContent.innerHTML = `<div class="asset-card-placeholder">A estrat√©gia mudou. Clique em 'Criar Esbo√ßo' novamente.</div>`;
    }

    const scriptContainer = document.getElementById('scriptSectionsContainer');
    if (scriptContainer) {
        scriptContainer.innerHTML = `
            <div id="introSection" class="script-section"></div>
            <div id="developmentSection" class="script-section"></div>
            <div id="climaxSection" class="script-section"></div>
            <div id="conclusionSection" class="script-section"></div>
            <div id="ctaSection" class="script-section hidden"></div>
        `;
    }
    
    // 3. Reseta os bot√µes de gera√ß√£o para o estado inicial
    const buttonsToReset = [
        'generateOutlineBtn', 'generateIntroBtn', 'generateDevelopmentBtn', 
        'climaxBtn', 'conclusionBtn', 'generateCTABtn', 
        'generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn'
    ];
    
    buttonsToReset.forEach(id => {
        const btn = document.getElementById(id);
        const floatBtn = document.getElementById(`float_${id}`);
        [btn, floatBtn].forEach(b => {
            if (b) {
                b.classList.remove('btn-success');
                // Adiciona a classe correta (primary ou secondary)
                if (['generateDescriptionBtn', 'generateTitlesAndThumbnailsBtn', 'generateOutlineBtn'].includes(id)) {
                    b.classList.add('btn-secondary');
                } else {
                    b.classList.add('btn-primary');
                }
            }
        });
    });

    // 4. Atualiza a UI e notifica o usu√°rio
    updateProgressBar();
    updateButtonStates();
    const sourceLabel = document.querySelector(`label[for='${sourceId}']`)?.textContent || sourceId;
    window.showToast(`'${sourceLabel}' mudou. O roteiro foi resetado.`);
};


/**
 * Invalida e limpa os prompts de imagem de uma se√ß√£o quando seu texto √© alterado.
 * @param {HTMLElement} sectionElement - O elemento da se√ß√£o (ex: o div com id="introSection").
 */
const invalidateAndClearPrompts = (sectionElement) => {
    if (!sectionElement) return;

    const sectionId = sectionElement.id;
    const promptContainer = sectionElement.querySelector('.prompt-container');

    // 1. Remove os prompts da mem√≥ria (do estado global)
    if (allImagePrompts[sectionId]) {
        delete allImagePrompts[sectionId];
        console.log(`Prompts para a se√ß√£o '${sectionId}' invalidados e removidos da mem√≥ria.`);
    }
    
    // 2. Limpa a interface do usu√°rio, se os prompts j√° foram renderizados
    if (promptContainer && promptContainer.innerHTML.trim() !== '') {
        promptContainer.innerHTML = `
            <div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border-l-4 border-yellow-400">
                <p class="text-sm text-yellow-700 dark:text-yellow-300 font-semibold">
                    Aten√ß√£o: O roteiro foi modificado.
                </p>
                <p class="text-xs text-yellow-600 dark:text-yellow-400 mt-1">
                    Por favor, clique em "Gerar Prompts de Imagem" novamente para criar novos recursos visuais com base no texto atualizado.
                </p>
            </div>
        `;
    }
};


/**
         * Invalida e limpa a sugest√£o de performance, exibindo um aviso.
         */
        const invalidateAndClearPerformance = (sectionElement) => {
            if (!sectionElement) return;

            const performanceContainer = sectionElement.querySelector('.section-performance-output');
            if (performanceContainer && performanceContainer.innerHTML.trim() !== '') {
                performanceContainer.innerHTML = `
                    <div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border-l-4 border-yellow-400">
                        <p class="text-sm text-yellow-700 dark:text-yellow-300 font-semibold">
                            Aten√ß√£o: O roteiro foi modificado.
                        </p>
                        <p class="text-xs text-yellow-600 dark:text-yellow-400 mt-1">
                            Por favor, clique em "Sugerir Performance" novamente para criar novas anota√ß√µes com base no texto atualizado.
                        </p>
                    </div>
                `;
            }
        };

        /**
         * Lida com os cliques nas setas de navega√ß√£o dos prompts.
         * @param {string} sectionElementId - O ID da se√ß√£o.
         * @param {number} direction - -1 para a esquerda, 1 para a direita.
         */
        window.navigatePrompts = (sectionElementId, direction) => {
            const prompts = allImagePrompts[sectionElementId] || [];
            const itemsPerPage = 4;
            const totalPages = Math.ceil(prompts.length / itemsPerPage);
            let currentPage = promptPaginationState[sectionElementId] || 0;

            const newPage = currentPage + direction;

            // Valida√ß√£o dos limites
            if (newPage >= 0 && newPage < totalPages) {
                promptPaginationState[sectionElementId] = newPage;
                renderPaginatedPrompts(sectionElementId);
            }
        };
    
                // =========================================================================
        // PASSO 1: SUBSTITUA A FUN√á√ÉO generateSectionHtmlContent INTEIRA POR ESTA
        // =========================================================================
        const generateSectionHtmlContent = (sectionId, title, content) => {
            const mainBodyId = `${sectionId}Body`;
            const mainArrowId = `${sectionId}Arrow`;
            
            const analysisToolsHtml = `
                <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700 space-y-6">
                    <div class="text-center">
                        <h5 class="font-semibold text-base mb-2 text-gray-800 dark:text-gray-200">Passo 1: Diagn√≥stico e Criativo</h5>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Analise a reten√ß√£o e, se precisar, enrique√ßa trechos. Selecione um trecho e clique.</p>
                        <div class="flex items-center justify-center gap-2 flex-wrap">
                            <button class="btn btn-secondary btn-small" onclick="window.analyzeSectionRetention(this, '${sectionId}Section')">Analisar Reten√ß√£o</button>
                            <button class="btn btn-secondary btn-small" onclick="window.enrichText(this)">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M9.5 2.672a.5.5 0 1 0 1 0V.843a.5.5 0 0 0-1 0v1.829Zm4.5.035A.5.5 0 0 0 13.293 2L12 3.293a.5.5 0 1 0 .707.707L14 2.707a.5.5 0 0 0 0-.707ZM7.293 4A.5.5 0 1 0 8 3.293L6.707 2A.5.5 0 0 0 6 2.707L7.293 4Zm-.621 2.5a.5.5 0 0 0 0 .707l1.293 1.293a.5.5 0 0 0 .707-.707L7.38 6.207a.5.5 0 0 0-.707 0Z"/><path d="M12.026 8.5H11a.5.5 0 0 0 0 1h1.026a.5.5 0 0 0 0-1Zm-1.633.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293Zm-3.134 3.367a.5.5 0 1 0-.707.707l1.293 1.293a.5.5 0 0 0 .707-.707l-1.293-1.293Zm1.633-.293a.5.5 0 1 1 .707.707l-1.293 1.293a.5.5 0 0 1-.707-.707l1.293-1.293A.5.5 0 0 1 8.89 11.86Z"/></svg>
                                <span class="button-text">Enriquecer Texto</span>
                            </button>
                            ${sectionId === 'development' ? `<button class="btn btn-primary btn-small" onclick="window.addDevelopmentChapter(this)"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8.5 4.5a.5.5 0 0 0-1 0v3h-3a.5.5 0 0 0 0 1h3v3a.5.5 0 0 0 1 0v-3h3a.5.5 0 0 0 0-1h-3v-3z"/></svg> Adicionar Cap√≠tulo</button>` : ''}
                        </div>
                        <div id="analysis-output-${sectionId}" class="section-analysis-output mt-3 text-left"></div>
                    </div>
                    <div class="pt-4 border-t border-dashed border-gray-200 dark:border-gray-700 text-center">
                         <h5 class="font-semibold text-base mb-2 text-gray-800 dark:text-gray-200">Passo 2: Estrutura de Narra√ß√£o</h5>
                        <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Ap√≥s a estrutura estar boa, adicione sugest√µes de performance para guiar a narra√ß√£o.</p>
                        <div class="flex items-center justify-center gap-2"><button class="btn btn-secondary btn-small" onclick="window.suggestPerformance(this, '${sectionId}Section')">Sugerir Performance</button></div>
                        <div class="section-performance-output mt-3 text-left"></div> 
                    </div>
                </div>
            `;
            const promptsSectionHtml = `
                <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700 text-center">
                    <h5 class="font-semibold text-base mb-2 text-gray-800 dark:text-gray-200">Passo 3: Recursos Visuais</h5>
                    <p class="text-xs text-gray-500 dark:text-gray-400 mb-3">Crie o storyboard visual para esta se√ß√£o do roteiro.</p>
                    <button class="btn btn-secondary btn-small" data-action="generate-prompts" data-section-id="${sectionId}Section">Gerar Prompts de Imagem</button>
                    <div class="prompt-container mt-4 text-left"></div>
                </div>
            `;
            // >>> √çCONES CORRIGIDOS AQUI <<<
            const regenerateBtnHtml = `<button class="regenerate-btn" data-action="regenerate" data-section-id="${sectionId}Section" title="Re-gerar esta se√ß√£o"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/></svg></button>`;
            const copyBtnHtml = `<button class="copy-btn" data-action="copy" title="Copiar Roteiro"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5-.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg></button>`;

            return `<div class="accordion-item card !p-0 mb-4">
                        <div class="accordion-header">
                            <div class="header-title-group">
                                <h3>${title}</h3>
                                <span class="text-xs font-normal text-gray-500">${calculateReadingTime(content)}</span>
                            </div>
                            <div class="header-actions-group">
                                <div class="header-buttons">
                                    ${regenerateBtnHtml}
                                    ${copyBtnHtml}
                                </div>
                                <svg id="${mainArrowId}" class="accordion-arrow" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>
                            </div>
                        </div>
                        <div id="${mainBodyId}" class="accordion-body">
                            <div class="generated-content-wrapper" contenteditable="true">${content}</div>
                            ${analysisToolsHtml}
                            ${promptsSectionHtml}
                        </div>
                    </div>`;
        };
    
        // ==========================================================
        // >>>>> SUBSTITUA SUA FUN√á√ÉO cleanGeneratedText INTEIRA POR ESTA VERS√ÉO BLINDADA <<<<<
        // ==========================================================
        const cleanGeneratedText = (text, expectJson = false) => {
            if (!text) return null;
            if (!expectJson) return text.trim();

            // 1. Encontra o primeiro caractere de in√≠cio de um JSON ('{' ou '[')
            const startIndex = text.search(/[\{\[]/);
            if (startIndex === -1) {
                console.error("Nenhum caractere de in√≠cio JSON ('{' ou '[') encontrado no texto da IA.");
                console.error("Texto problem√°tico:", text);
                throw new Error("A IA n√£o retornou um formato JSON reconhec√≠vel.");
            }

            const firstChar = text[startIndex];
            const matchingLastChar = firstChar === '{' ? '}' : ']';
            
            let level = 1;
            let endIndex = -1;

            // 2. Percorre o resto da string para encontrar o caractere de fechamento correspondente
            for (let i = startIndex + 1; i < text.length; i++) {
                const char = text[i];
                if (char === firstChar) {
                    level++;
                } else if (char === matchingLastChar) {
                    level--;
                }
                
                if (level === 0) {
                    endIndex = i;
                    break; // Encontramos o final do JSON
                }
            }

            if (endIndex === -1) {
                console.error("O JSON retornado pela IA n√£o foi fechado corretamente.");
                console.error("Texto problem√°tico:", text);
                throw new Error("A IA retornou um JSON malformado (n√£o fechado).");
            }
            
            // 3. Extrai a string JSON com precis√£o cir√∫rgica
            const jsonString = text.substring(startIndex, endIndex + 1);

            // 4. Tenta fazer o parse. Se falhar aqui, o problema √© interno (ex: v√≠rgulas)
            try {
                return JSON.parse(jsonString);
            } catch (e) {
                console.error("Falha ao fazer o parse do JSON extra√≠do cirurgicamente:", e.message);
                console.error("JSON extra√≠do:", jsonString);
                // Aqui podemos tentar uma √∫ltima cirurgia para v√≠rgulas, se necess√°rio
                try {
                    let repairedString = jsonString.replace(/,\s*([}\]])/g, "$1"); // Remove trailing commas
                    return JSON.parse(repairedString);
                } catch (finalError) {
                    throw new Error("A IA retornou um JSON com sintaxe interna inv√°lida.");
                }
            }
        };

                /**
         * Remove coment√°rios meta da IA do texto gerado. (VERS√ÉO BLINDADA)
         * @param {string} text - O texto gerado pela IA.
         * @returns {string} O texto sem os coment√°rios meta.
         */
        const removeMetaComments = (text) => {
            if (!text) return "";
            const patternsToRemove = [
                /^(aqui est√°|aqui vai|claro, aqui est√°|certo, aqui est√°|eis o|sure, here is|here's|here are|below is|certainly, here is) .*?:\s*\n?/im,
                // NOVO PADR√ÉO MAIS AGRESSIVO PARA PEGAR O TEXTO INJETADO
                /Here is the (generated )?script for the "[^"]+" section:\s*\n?/gi,
                /^introdu√ß√£o:\s*\n?/im,
                /^desenvolvimento:\s*\n?/im,
                /^cl√≠max:\s*\n?/im,
                /^conclus√£o:\s*\n?/im,
                /^\*\*roteiro anotado:\*\*\s*\n?/im
            ];
            let cleanedText = text;
            patternsToRemove.forEach(pattern => {
                cleanedText = cleanedText.replace(pattern, '');
            });
            // Remove aspas do in√≠cio e fim, caso a IA envolva a resposta inteira nelas
            if (cleanedText.startsWith('"') && cleanedText.endsWith('"')) {
                cleanedText = cleanedText.substring(1, cleanedText.length - 1);
            }
            return cleanedText.trim();
        };

        // --- IN√çCIO DO NOVO M√ìDULO DE NARRATIVA ---

        const narrativeStructures = {
            storytelling: {
                documentary: "Document√°rio (Factual e Investigativo)",
                heros_journey: "Jornada do Her√≥i (Estrutura √âpica)",
                pixar_spine: "Espinha Dorsal - Pixar (Estrutura Emocional)",
                mystery_loop: "Mist√©rio (com Loop Aberto)",
                twist: "Narrativa com Virada (Twist)"
            },
            storyselling: {
                underdog_victory: "Vit√≥ria do Vira-lata (Conex√£o e Supera√ß√£o)",
                discovery_mentor: "A Grande Descobrir / Mentor Secreto",
                if_not_found_create: "N√£o Encontrei, Ent√£o Criei (Hist√≥ria de Origem)",
                pas: "Problema-Agita√ß√£o-Solu√ß√£o (PAS)",
                bab: "Antes-Depois-Ponte (BAB)"
            }
        };

        const narrativeTooltips = {
            documentary: "Constr√≥i um argumento com fatos, evid√™ncias e uma narra√ß√£o autorit√°ria. Perfeito para v√≠deos expositivos.",
            heros_journey: "Conta uma hist√≥ria de transforma√ß√£o e supera√ß√£o. √ìtimo para narrativas inspiradoras.",
            pixar_spine: "Estrutura emocional de 8 passos (Era uma vez... todo dia... at√© que...). Pergunta para arcos de personagem r√°pidos.",
            mystery_loop: "Apresenta uma pergunta no in√≠cio e a responde no final. Excelente para reter a aten√ß√£o.",
            twist: "Constr√≥i uma expectativa e a quebra com uma revela√ß√£o surpreendente no final.",
            underdog_victory: "Mostra algu√©m com limita√ß√µes que venceu contra tudo e todos. Gera alta conex√£o emocional.",
            discovery_mentor: "Revela um grande segredo ou uma descoberta que mudou tudo. Posi√ß√£o de autoridade.",
            if_not_found_create: "Conta a hist√≥ria de origem de um produto ou servi√ßo criado a partir de uma necessidade pessoal.",
            pas: "Foca em um problema que o p√∫blico tem, agita a dor e apresenta a solu√ß√£o. Perfeito para vendas diretas.",
            bab: "Mostra um cen√°rio 'antes' (o problema), um 'depois' (o resultado ideal) e seu conte√∫do como 'a ponte' para chegar l√°."
        };

        const updateNarrativeStructureOptions = () => {
            const goalSelect = document.getElementById('narrativeGoal');
            const structureSelect = document.getElementById('narrativeStructure');
            if (!goalSelect || !structureSelect) return;

            const goal = goalSelect.value;
            structureSelect.innerHTML = ''; // Limpa as op√ß√µes atuais

            const structures = narrativeStructures[goal];
            for (const key in structures) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = structures[key];
                structureSelect.appendChild(option);
            }
            
            updateMainTooltip();
        };

        const updateMainTooltip = () => {
            const goalSelect = document.getElementById('narrativeGoal');
            const tooltip = document.getElementById('narrativeStructureTooltip');
            if (!goalSelect || !tooltip) return;

            const goal = goalSelect.value;
            const structures = narrativeStructures[goal];
            
            let tooltipContent = '';
            for (const key in structures) {
                tooltipContent += `${structures[key]}: ${narrativeTooltips[key]}

`;
            }
            
            tooltip.setAttribute('data-tooltip', tooltipContent.trim());
        };

        // --- FIM DO NOVO M√ìDULO DE NARRATIVA ---

                /**
         * Constr√≥i o contexto base do prompt com base nos inputs do usu√°rio.
         * (VERS√ÉO FINAL AUTO-SUFICIENTE)
         */
        const getBasePromptContext = () => {
            const channelName = document.getElementById('channelName')?.value.trim() || "";
            const videoTheme = document.getElementById('videoTheme')?.value.trim() || "";
            const targetAudience = document.getElementById('targetAudience')?.value.trim() || "";
            const language = document.getElementById('languageSelect')?.value || "en";
            const languageStyle = document.getElementById('languageStyle')?.value || "";
            const videoObjective = document.getElementById('videoObjective')?.value || "";
            const speakingPace = document.getElementById('speakingPace')?.value || "";
            const narrativeStructure = document.getElementById('narrativeStructure')?.value || "";
            const narrativeTheme = document.getElementById('narrativeTheme')?.value.trim() || "";
            const narrativeTone = document.getElementById('narrativeTone')?.value || "";
            const narrativeVoice = document.getElementById('narrativeVoice')?.value.trim() || "";
            const shockingEndingHook = document.getElementById('shockingEndingHook')?.value.trim() || "";
            const videoDescription = document.getElementById('videoDescription')?.value.trim() || "";
            const centralQuestion = document.getElementById('centralQuestion')?.value.trim() || "";
            const emotionalArc = document.getElementById('emotionalArc')?.value.trim() || "";
            const imageDescriptionEngine = document.getElementById('imageDescriptionEngine')?.value.trim() || "";
            const imageStyleSelect = document.getElementById('imageStyleSelect')?.value || "";
            const customImageStyle = document.getElementById('customImageStyle')?.value.trim() || "";

            let context = `
            You are an expert YouTube scriptwriter for the channel "${channelName}".
            Your goal is to create highly engaging and viral video content.
            
            **Core Project Details:**
            - Video Topic: "${videoTheme}"
            - Target Audience: "${targetAudience}"
            - Language: "${language}"
            - Video Objective: "${videoObjective}"
                        
            **Narrative & Style Instructions:**
            - Narrative Structure to use: "${narrativeStructure}"
            - Speaking Pace: "${speakingPace}"
            `;

            if (narrativeTheme) {
                context += `\n- Core Theme (The Big Idea): "${narrativeTheme}"`;
            }
            if (narrativeTone) {
                context += `\n- Narrative Tone (The Feeling): "${narrativeTone}"`;
            }
            if (narrativeVoice) {
                context += `\n- Narrator's Voice (The Personality): "${narrativeVoice}"`;
            }
            if (shockingEndingHook) {
                context += `\n- Shocking Ending Hook to use: "${shockingEndingHook}"`;
            }
            if (videoDescription) {
                context += `\n\n**Additional Information & Inspiration:**\n- Inspiration/Context: "${videoDescription}"`;
            }
            if (centralQuestion) {
                context += `\n- Central Question to guide the entire script: "${centralQuestion}"`;
            }
            if (emotionalArc) {
                context += `\n- Desired Emotional Arc: "${emotionalArc}"`;
            }
            
            if (imageStyleSelect === 'cinematic' || imageStyleSelect === 'custom') {
                context += `\n\n**Visual Style Instructions:**`;
                if (imageDescriptionEngine) {
                    context += `\n- Image Description Keywords: "${imageDescriptionEngine}"`;
                }
                if (imageStyleSelect === 'cinematic') {
                    context += `\n- Image Style: ${CINEMATIC_STYLE_BLOCK}`;
                } else if (imageStyleSelect === 'custom' && customImageStyle) {
                    context += `\n- Custom Image Style: ${customImageStyle}`;
                }
            }

            return context;
        };
    
        /**
         * Constr√≥i o prompt espec√≠fico para cada sec√ß√£o do roteiro ou tipo de conte√∫do.
         * @param {string} sectionName - O nome da sec√ß√£o (ex: 'intro', 'titles_thumbnails').
         * @param {string} sectionTitle - O t√≠tulo da sec√ß√£o para o prompt.
         * @param {string|null} outlineDirective - Uma diretriz espec√≠fica do esbo√ßo estrat√©gico para esta sec√ß√£o.
         * @returns {{prompt: string, maxTokens: number}} O prompt e o limite de tokens.
         */
        const constructScriptPrompt = (sectionName, sectionTitle, outlineDirective = null) => {
            const baseContext = getBasePromptContext();
            const videoDuration = elements.videoDuration.value;
            const selectedLanguage = elements.languageSelect.value;
            const narrativeStructure = elements.narrativeStructure.value; // Corrected to use elements.narrativeStructure

            const targetWords = wordCountMap[videoDuration]?.[sectionName];

            let durationInstruction = '';
            if (targetWords) {
                // Cria uma instru√ß√£o MUITO MAIS FORTE e expl√≠cita para a IA
                durationInstruction = `\n\n**CRITICAL TIMING CONSTRAINT:** The generated text for this section MUST be approximately **${targetWords} words** long to fit the video's schedule. This is a strict requirement.`;
            }

            let prompt = `${baseContext}

        Voc√™ √© um mestre roteiro de YouTube. Sua tarefa √© escrever o texto para a se√ß√£o **"${sectionTitle}"** do roteiro.
            ${durationInstruction}

**REGRAS CR√çTICAS E INEGOCI√ÅVEIS:**
1.  **FOCO TOTAL:** Sua resposta deve ser APENAS e SOMENTE o texto para a se√ß√£o **"${sectionTitle}"**.
2.  **SEM EXTRAS:** √â estritamente proibido incluir pre√¢mbulos (como "Aqui est√° a introdu√ß√£o:"), resumos, tradu√ß√µes ou qualquer outro texto que n√£o seja o pr√≥prio roteiro. A viola√ß√£o desta regra resultar√° em falha.
3.  **FORMATO LIMPO:** N√£o inclua r√≥tulos de cena, de √°udio ou de narrador (como [CENA], (M√∫sica sobe), Narrador:). Apenas o texto a ser falado.

Siga estas regras e gere o roteiro para a se√ß√£o "${sectionTitle}" agora.`;
            let maxTokens = 2000;

            if (outlineDirective) {
                prompt += `\n\n**IMPORTANT STRATEGIC GUIDELINE:** For this specific section, you MUST follow this strategic plan: "${outlineDirective}"`;
            }

            prompt += `\n\nIMPORTANT: Do NOT include any scene descriptions, visual/audio cues (e.g., [SHOT], (Camera pan), (Music swells)), or speaker labels (e.g., "Narrator:", "Host:") in the generated script content. Provide only the spoken text.`;
            prompt += `\n\nABSOLUTELY NO META-COMMENTS. Do not add any explanatory text about the script itself. Your entire response must be ONLY the text to be spoken in the video, and nothing else.`;

            if (elements.centralQuestion.value.trim()) {
                prompt += `\nIf a 'Central Question' is provided, ensure every section of the script (Introduction, Development, Climax) directly contributes to exploring or answering this question. The entire video must revolve around this central theme.`;
            }

            // --- IN√çCIO DA NOVA L√ìGICA DE NARRATIVA ---
            switch (narrativeStructure) {
                case 'documentary':
                    prompt += `\n\nNARRATIVE STYLE: Use a 'Documentary' structure.
                    - **Introduction:** Start with a powerful, factual statement or a thought-provoking question that establishes the central theme. Present the "thesis" of the documentary.
                    - **Development:** Build the narrative by presenting evidence, data, and historical context in a logical sequence. Structure it like an an investigation, revealing information progressively. Use language that suggests authority and credibility (e.g., "Evidence suggests...", "Historical records show...", "Experts believe...").
                    - **Climax:** Present the most compelling piece of evidence or the central conclusion of your argument. This should be the moment where the "thesis" from the introduction is proven or deeply explored.
                    - **Conclusion:** Summarize the key findings and arguments. End with a broader reflection on the implications of the topic, leaving the viewer with a new understanding or perspective.`;
                    break;
                case 'pixar_spine':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Pixar Spine' structure.
                    - **Introduction:** Era uma vez... (Introduce the main character and their ordinary world). Todo dia... (Describe their routine and the status quo).
                    - **Development:** At√© que um dia... (The inciting incident that changes everything). E por causa disso... (The character's journey begins, facing a series of challenges and events). E por causa disso... (The stakes get higher).
                    - **Climax:** At√© que finalmente... (The character faces the final confrontation or overcomes the main obstacle).
                    - **Conclusion:** E desde ent√£o... (Describe the new normal and the character's transformation).`;
                    break;
                case 'underdog_victory':
                     prompt += `\n\nNARRATIVE STYLE: Use the 'Victory of the Underdog' structure.
                    - **Introduction:** Present a character or entity in a disadvantaged, underestimated, or limited situation (the 'underdog').
                    - **Development:** Detail the immense challenges, the unfair obstacles, and the moments of doubt and struggle they faced. Emphasize their resilience and determination.
                    - **Climax:** The moment of ultimate triumph, where the underdog overcomes the final, greatest obstacle against all odds.
                    - **Conclusion:** Reflect on the victory, connecting it to a universal message of hope, perseverance, or potential, inspiring the audience with a "if they can do it, so can I" feeling.`;
                    break;
                case 'discovery_mentor':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Great Discovery / Secret Mentor' structure.
                    - **Introduction:** Start with the "before" state - a life of struggle, confusion, or mediocrity. Hint that a breakthrough is coming.
                    - **Development:** Describe the moment of discovery or the encounter with a mentor. Explain the 'secret' or the new perspective that was revealed. Show how this new knowledge was applied and the first signs of change.
                    - **Climax:** Detail the peak result or the ultimate transformation achieved by applying this secret knowledge.
                    - **Conclusion:** Share the core lesson of the discovery and offer it to the audience, positioning the content as a guide to achieve similar results.`;
                    break;
                case 'if_not_found_create':
                     prompt += `\n\nNARRATIVE STYLE: Use the 'I Couldn't Find It, So I Created It' structure.
                    - **Introduction (The Problem):** Describe a personal and relatable problem you (or the protagonist) faced. Explain the frustration of searching for a solution and finding nothing adequate.
                    - **Development (The Creation):** Detail the journey of deciding to create your own solution. Describe the trial and error, the hard work, and the key insights learned along the way.
                    - **Climax (The Solution):** Present the final, successful creation (the product, the service, the method). Show how it solved the original problem perfectly.
                    - **Conclusion (The Offer):** Offer this solution to the audience, who likely share the same original problem.`;
                    break;
                case 'mystery_loop':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Mystery/Open Loop' structure.
                    - In the **Introduction**, present a compelling central question or mystery and promise the answer by the end.
                    - In the **Development**, build suspense by exploring clues and theories, occasionally reminding the viewer of the central question.
                    - In the **Climax**, deliver the satisfying answer to the question posed in the introduction.`;
                    break;
                case 'pas':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Problem-Agitate-Solution' structure.
                    - Frame the **Introduction** around a clear 'Problem' that the audience can relate to.
                    - Use the first part of the **Development** to 'Agitate' this problem, explaining its importance and complexity.
                    - Frame the rest of the **Development** and the **Climax** as the 'Solution' or the revealing insight that addresses the initial problem.`;
                    break;
                case 'twist':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'False Climax & Twist' structure.
                    - In the **Development**, build evidence towards a seemingly obvious conclusion (the 'false climax').
                    - In the **Climax**, introduce a surprising new piece of information or a counter-argument that completely changes the expected outcome (the 'twist').
                    - The **Conclusion** should reflect on the implications of this new, unexpected truth.`;
                    break;
                case 'heros_journey':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Hero's Journey' structure.
                    - **Introduction:** Present the 'Ordinary World' and the 'Call to Adventure'. Introduce the central character or concept.
                    - **Development:** This is the 'Special World'. Describe the trials, allies, and enemies. Build the character's transformation through challenges.
                    - **Climax:** The 'Ordeal' or the final battle. The moment of greatest tension and the hero's ultimate test.
                    - **Conclusion:** The 'Return with the Elixir'. Show the resolution, what was learned, and how the 'Ordinary World' has changed because of the journey.
                    `;
                    break;
                case 'bab':
                    prompt += `\n\nNARRATIVE STYLE: Use the 'Before-After-Bridge' (BAB) structure.
                    - **Introduction (Before):** Describe the 'Before' state. A world without the knowledge or solution you're about to present. Paint a picture of the problem or the lack of understanding.
                    - **Development (After):** Describe the 'After' state. A desirable world where the problem is solved or the knowledge is revealed. Show the benefits and the ideal outcome.
                    - **Climax & Conclusion (The Bridge):** Present your content as 'The Bridge'. Explain how your video's information is the exact path to get from the 'Before' state to the 'After' state. This is the solution, the 'how-to'.`;
                    break;
            }

            // ==========================================================
            // >>>>> C√ìDIGO FINAL E CORRIGIDO PARA O SWITCH <<<<<
            // ==========================================================
            switch (sectionName) {
                case 'outline': // Este n√£o muda
                    prompt = `${baseContext}

Voc√™ √© um mestre roteirista e estrategista de conte√∫do. Sua tarefa √© criar um "beat sheet" ou um esbo√ßo estrat√©gico detalhado para o v√≠deo. Analise todos os par√¢metros fornecidos (tema, p√∫blico, estilo narrativo, etc.) para criar a estrutura mais impactante poss√≠vel.

Responda APENAS com um objeto JSON. O objeto deve conter chaves para cada parte principal do roteiro: "introduction", "development", "climax", "conclusion", e "cta".

O valor de cada chave deve ser uma string descrevendo o objetivo, o conte√∫do e a emo√ß√£o daquela sec√ß√£o espec√≠fica. Seja conciso, mas estrat√©gico.

Exemplo de formato JSON esperado:
{
  "introduction": "Come√ßar com uma pergunta ret√≥rica chocante sobre a mortalidade, seguida por uma promessa de que a hist√≥ria de L√°zaro det√©m uma resposta inesperada. Gancho emocional: curiosidade e um toque de medo existencial.",
  "development": "Construir a narrativa explorando o luto das irm√£s de L√°zaro, humanizando a hist√≥ria. Apresentar a chegada tardia de Jesus como um ponto de tens√£o e d√∫vida. Foco na emo√ß√£o de perda antes do milagre.",
  "climax": "O momento de maior tens√£o no t√∫mulo. Descrever a ordem de Jesus com autoridade e o espanto da multid√£o. O milagre deve ser o pico emocional e visual do v√≠deo.",
  "conclusion": "Resumir a li√ß√£o: o milagre n√£o √© sobre desafiar a morte, mas sobre o poder da f√©. Conectar a hist√≥ria de L√°zaro √† jornada de f√© pessoal do espectador.",
  "cta": "Fazer uma chamada para a√ß√£o suave, pedindo para o espectador compartilhar sua pr√≥pria hist√≥ria de supera√ß√£o ou f√© nos coment√°rios, criando uma comunidade."
}
`;
                    maxTokens = 1500;
                    break;

                case 'intro':
                    const shockingHook = document.getElementById('shockingEndingHook')?.value.trim();
                    if (shockingHook) {
                        prompt += `
                        \n\n**CRITICAL INSTRUCTION FOR THE INTRODUCTION:**
                        You MUST start the script EXACLTY with the following "Shocking Ending" phrase, without any preamble: "${shockingHook}"
                        After stating that phrase, use the rest of the introduction to build a deep sense of mystery and curiosity, making the audience desperate to know the chain of events that led to that ending. Do not explain the ending, only create the hook.
                        `;
                    } else {
                        prompt += `
                        The introduction should hook the viewer immediately, clearly state the video's intriguing question or mystery, and set the stage for what's to come. It must be captivating and create curiosity.
                        `;
                    }
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 500; // CORRIGIDO
                    break;

                case 'development':
                    prompt += `
                    The development section should delve into the core topic, presenting facts, arguments, and historical context. It should maintain a strong narrative flow, building suspense and providing compelling information. Break down complex ideas into easily digestible parts.
                    `;
                    maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 1500; // CORRIGIDO
                    break;

                case 'climax':
                    prompt += `
                    The climax should be the most impactful part of the video, revealing key insights, surprising twists, or the most compelling evidence related to the video theme. It should be dramatic and leave the viewer with a sense of awe or profound understanding.
                    `;
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 500; // CORRIGIDO
                    break;

                case 'conclusion':
                    prompt += `
                    The conclusion should summarize the main points, provide a final thought or reflection, and leave the viewer with a lasting impression. Ensure the conclusion is complete and well-rounded, providing a sense of closure.
                    `;
                    if (selectedLanguage === 'pt-br' || selectedLanguage === 'pt-pt') {
                        prompt += `\n**IMPORTANT: The response for this section MUST be in Portuguese.**`;
                    }
                    maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 500; // CORRIGIDO
                    break;

                case 'cta':
                    prompt += `
                    The Call to Action (CTA) should be clear and concise, encouraging viewers to subscribe, like, comment, or share. It should be compelling and feel like a natural conclusion to the video, **but ensure it is a complete and well-rounded paragraph.**
                    `;
                    maxTokens = targetWords ? Math.ceil(targetWords * 1.8) : 400; // CORRIGIDO
                    break;

                                case 'titles_thumbnails':
                    // >>>>> PROMPT BLINDADO <<<<<
                    prompt = `${baseContext}
                    Voc√™ √© uma API de gera√ß√£o de metadados. Sua √∫nica fun√ß√£o √© retornar um objeto JSON.

                    **REGRAS DE FORMATA√á√ÉO (INEGOCI√ÅVEIS E ESTRICTAS):**
                    1.  Sua resposta DEVE ser APENAS e SOMENTE o c√≥digo de um objeto JSON.
                    2.  O objeto DEVE come√ßar com uma chave de abertura \`{\` e terminar com uma chave de fechamento \`}\`.
                    3.  O objeto DEVE conter EXATAMENTE duas chaves de n√≠vel superior: \`"titles"\` e \`"thumbnails"\`.
                    4.  O valor de \`"titles"\` DEVE ser um array de strings.
                    5.  O valor de \`"thumbnails"\` DEVE ser um array de objetos, onde cada objeto tem as chaves "title" e "description".

                    **EXEMPLO DE RESPOSTA PERFEITA:**
                    {
                  "titles": [
                  "T√≠tulo de Exemplo 1",
                  "T√≠tulo de Exemplo 2"
                    ],
                    "thumbnails": [
                     {
                      "title": "THUMB 1",
                  "description": "Descri√ß√£o da thumbnail 1."
                 }
                ]
                }

                    Analise o contexto fornecido e gere 5 t√≠tulos e 5 ideias de thumbnail, seguindo as regras de formata√ß√£o acima SEM QUALQUER DESVIO.`;
                    maxTokens = 1500; // Aumentamos um pouco por seguran√ßa
                    break;

                case 'description':
                const languageName = new Intl.DisplayNames([selectedLanguage], { type: 'language' }).of(selectedLanguage);
                prompt = `${baseContext}\n\nGenerate a compelling YouTube video description (around 150-200 words) and 10 relevant hashtags.
    
                **CRITICAL LANGUAGE RULE: Your entire response, including the headers "Description:" and "Hashtags:", MUST be in ${languageName}.**

                Output format:
                Description:
                [Your description here]

                Hashtags:
                #hashtag1 #hashtag2 ...
                `;
                maxTokens = 700;
                break;
            }
            return { prompt, maxTokens };
        };

        /**
         * Faz uma chamada √† API Groq atrav√©s de uma fun√ß√£o Netlify.
         * @param {string} prompt - O prompt a ser enviado para a IA.
         * @param {number} maxTokens - O n√∫mero m√°ximo de tokens para a resposta.
         * @returns {Promise<string>} A resposta bruta da IA.
         * @throws {Error} Se a chamada √† API falhar.
         */
        const callGroqAPI = async (prompt, maxTokens) => {
            const proxyUrl = "/.netlify/functions/groq"; // Endpoint do proxy

            const payload = {
                prompt: prompt,
                maxTokens: maxTokens
            };

            const request = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetch(proxyUrl, request);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: { message: 'Erro desconhecido do servidor proxy.' } }));
                    throw new Error(`Erro na API via Proxy: ${errorData.error?.message || 'Erro do servidor'}`);
                }
                const result = await response.json();
                const rawContent = result.choices?.[0]?.message?.content;
                if (rawContent) { return rawContent; }
                else { throw new Error("Resposta inesperada da API Groq."); }
            } catch (error) {
                console.error("Fetch da API via Netlify Function falhou:", error);
                window.showToast(`Falha na API: ${error.message}`);
                throw error;
           }
        };

        /**
         * Valida os inputs essenciais antes de gerar conte√∫do.
         * @returns {boolean} True se os inputs s√£o v√°lidos, caso contr√°rio, false.
         */
             
        /**
         * Itera sobre todas as se√ß√µes do roteiro na ordem correta,
         * renumera globalmente todas as cenas E recalcula o timestamp
         * com base na dura√ß√£o estimada pela IA para cada cena.
         */
        
    
        /**
         * Escapa um objeto JSON para ser usado com seguran√ßa dentro de um atributo onclick.
         * @param {object} idea - O objeto da ideia a ser escapado.
         * @returns {string} Uma string JSON segura para HTML.
         */
        const escapeIdeaForOnclick = (idea) => {
            // Primeiro, converte o objeto para uma string JSON
            const jsonString = JSON.stringify(idea);
            // Em seguida, substitui os caracteres que quebram o HTML
            // Escapa aspas duplas, aspas simples e barras invertidas
            return jsonString.replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/\\/g, '&#92;');
        };

        // ==========================================================
        // ===== COLE ESTA FUN√á√ÉO FALTANTE NO SEU JAVASCRIPT =====
        // ==========================================================
        /**
         * Lida com a visibilidade da barra de a√ß√£o flutuante com base na posi√ß√£o de rolagem.
         */
        window.handleFloatingActionBar = () => {
            const bar = document.getElementById('floatingActionBar');
            // O gatilho para a barra aparecer ser√° a grade de inputs principais
            const triggerElement = document.getElementById('mainInputsTabs'); 

            if (!bar || !triggerElement) {
                return; // Sai da fun√ß√£o se os elementos n√£o existirem
            }

            // Ponto de gatilho: quando o final do 'mainInputsGrid' passar pelo topo da tela
            const triggerPoint = triggerElement.offsetTop + triggerElement.offsetHeight;

            if (window.scrollY > triggerPoint) {
                bar.classList.add('visible');
            } else {
                bar.classList.remove('visible');
            }
        };


         // ==========================================================
        // >>>>> PASSO 1: SUBSTITUA A FUN√á√ÉO createScriptSectionPlaceholder <<<<<
        // ==========================================================
        /**
         * Cria e retorna o HTML de um placeholder para uma se√ß√£o do roteiro.
         * @param {string} sectionId - O ID base da se√ß√£o (ex: 'intro').
         * @param {string} title - O t√≠tulo da se√ß√£o (ex: 'Introdu√ß√£o').
         * @param {string} buttonId - O ID do bot√£o principal que gera esta se√ß√£o (ex: 'generateIntroBtn').
         * @returns {string} O HTML do placeholder da se√ß√£o.
         */
        const createScriptSectionPlaceholder = (sectionId, title, buttonId) => {
            const containerId = `${sectionId}Section`;
            
            // Adicionamos a classe 'card-placeholder' para que o CSS funcione
            return `
                <div id="${containerId}" class="script-section card card-placeholder mb-4 animate-fade-in flex justify-between items-center">
                    <h3 class="font-semibold text-lg text-gray-700 dark:text-gray-300">${title}</h3>
                    <button id="${buttonId}" class="btn btn-primary">
                        <i class="fas fa-magic mr-2"></i>Gerar
                    </button>
                </div>
            `;
        };



        /**
         * Adiciona um novo cap√≠tulo ao desenvolvimento, expandindo o roteiro. (VERS√ÉO CORRIGIDA)
         * @param {HTMLElement} button - O bot√£o que foi clicado.
         */
        window.addDevelopmentChapter = async (button) => {
            const devSection = document.getElementById('developmentSection');
            const contentWrapper = devSection.querySelector('.generated-content-wrapper');
            const existingText = contentWrapper.textContent;

            if (!existingText) {
                showToast("Gere o desenvolvimento inicial primeiro.");
                return;
            }

            button.disabled = true;
            button.innerHTML = '<div class="loading-spinner" style="width:16px; height:16px; border-width: 2px;"></div>';

            try {
                // ==========================================================
                // >>>>> AQUI EST√Å A CORRE√á√ÉO DO PROBLEMA 1 (PROMPT) <<<<<
                // ==========================================================
                const basePrompt = constructScriptPrompt('development', 'Desenvolvimento').prompt;
                const continuationPrompt = `${basePrompt}
                \n\n**CRITICAL CONTINUATION INSTRUCTION: THIS IS THE MOST IMPORTANT RULE.**
                You are writing the NEXT chapter of a script that already exists. 
                - **DO NOT** repeat, rephrase, or summarize previous information.
                - You **MUST** introduce new information, new evidence, a new event, or a deeper analysis that moves the story forward.
                - Assume the viewer already knows everything written so far. Your task is to build upon it.
                
                **Here is the END of the current script, to give you context on where to continue from:**
                \n"...${existingText.slice(-700)}" 
                
                Now, write the next chapter of the development section, ensuring it is entirely new content.`;
                // ==========================================================
                
                const rawResult = await callGroqAPI(continuationPrompt, 4000); // Aumentamos os tokens para garantir que n√£o corte
                const newChapter = removeMetaComments(rawResult.trim());
                
                const existingParagraphsCount = contentWrapper.querySelectorAll('div[id]').length;
                const newParagraphs = newChapter.split('\n').filter(p => p.trim() !== '');
                const newContentWithDivs = newParagraphs.map((p, index) => 
                    `<div id="development-p-${existingParagraphsCount + index}">${p}</div>`
                ).join('');

                contentWrapper.insertAdjacentHTML('beforeend', `<br>${newContentWithDivs}`); // Adiciona espa√ßo
                
                // ==========================================================
                // >>>>> AQUI EST√Å A CORRE√á√ÉO DO PROBLEMA 2 (INVALIDA√á√ÉO) <<<<<
                // ==========================================================
                // window.emotionalMap = null; // Invalida o mapa antigo
                invalidateAndClearPerformance(devSection); // Limpa a UI de performance
                invalidateAndClearPrompts(devSection); // Limpa a UI de prompts
                // ==========================================================

                updateAllReadingTimes();
                showToast("Novo cap√≠tulo adicionado!");

            } catch (error) {
                showToast(`Falha ao adicionar cap√≠tulo: ${error.message}`);
            } finally {
                button.disabled = false;
                button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8.5 4.5a.5.5 0 0 0-1 0v3h-3a.5.5 0 0 0 0 1h3v3a.5.5 0 0 0 1 0v-3h3a.5.5 0 0 0 0-1h-3v-3z"/></svg> Adicionar Cap√≠tulo`;
            }
        };



        /**
         * Escapa uma string de texto plano para ser usada em um documento RTF,
         * lidando corretamente com caracteres non-ASCII e especiais.
         * @param {string} text - O texto a ser escapado.
         * @returns {string} O texto formatado para RTF.
         */
        const escapeRtf = (text) => {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                // Escapa caracteres especiais do RTF
                if (charCode === 92 || charCode === 123 || charCode === 125) { // Backslash, {, }
                    result += '\\' + text.charAt(i);
                }
                // Converte caracteres non-ASCII para o formato hexadecimal do RTF
                else if (charCode > 127) {
                    let hex = charCode.toString(16);
                    if (hex.length < 2) {
                        hex = '0' + hex;
                    }
                    result += "\\'" + hex;
                }
                // Mant√©m caracteres ASCII padr√£o
                else {
                    result += text.charAt(i);
                }
            }
            return result;
        };

        // ==========================================================
        // ================== FUN√á√ïES PRINCIPAIS ====================
        // ==========================================================
        
            const handleSuggestionMouseOver = (event) => {
            const targetParagraph = event.currentTarget;
            const suggestionGroupText = targetParagraph.dataset.suggestionGroup;
            if (!suggestionGroupText) return;

            const contentWrapper = targetParagraph.closest('.generated-content-wrapper');
            if (!contentWrapper) return;
            
            // >>>>> AQUI EST√Å A CORRE√á√ÉO CR√çTICA <<<<<
            // Escapa as aspas duplas no texto da sugest√£o antes de us√°-lo no seletor
            const safeSuggestionSelector = suggestionGroupText.replace(/"/g, '\\"');

            // Encontra todos os par√°grafos com a mesma sugest√£o (usando o seletor seguro) e os destaca
            contentWrapper.querySelectorAll(`[data-suggestion-group="${safeSuggestionSelector}"]`).forEach(p => {
                p.classList.add('highlight-group');
            });
        };

        const handleSuggestionMouseOut = (event) => {
            const targetParagraph = event.currentTarget;
            const contentWrapper = targetParagraph.closest('.generated-content-wrapper');
            if (!contentWrapper) return;
            
            // Remove o destaque de todos os par√°grafos
            contentWrapper.querySelectorAll('.highlight-group').forEach(p => {
                p.classList.remove('highlight-group');
            });
        };

        window.analyzeSectionRetention = async (button, sectionId) => {
            const sectionElement = document.getElementById(sectionId);
            const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');
            
            // >>>>> GUARDA DE PROTE√á√ÉO ROBUSTA (AQUI EST√Å A CORRE√á√ÉO) <<<<<
            if (!contentWrapper || !contentWrapper.textContent.trim()) {
                window.showToast("Gere o roteiro desta se√ß√£o antes de analisar a reten√ß√£o.");
                return;
            }

            const paragraphs = Array.from(contentWrapper.querySelectorAll('div')); 
            if (paragraphs.length === 0) {
                window.showToast("N√£o h√° par√°grafos para analisar.");
                return;
            }
            // >>>>> FIM DA GUARDA DE PROTE√á√ÉO <<<<<

            showButtonLoading(button);

            try {
                const paragraphsWithIndexes = paragraphs.map((p, index) => ({ index: index, text: p.textContent.trim() }));
                
                const prompt = `You are a Retention Editor API. Analyze the following paragraphs and return a valid JSON array. For each, provide "paragraphIndex", "retentionScore" ('green', 'yellow', or 'red'), and a concise "suggestion" in Portuguese (Brazil). Your entire response must be ONLY the JSON array.

                Analyze this data:
                ${JSON.stringify(paragraphsWithIndexes, null, 2)}`;
                
                const rawResult = await callGroqAPI(prompt, 2500);
                let analysis = cleanGeneratedText(rawResult, true);

                if (!analysis || !Array.isArray(analysis)) throw new Error("An√°lise da IA em formato inv√°lido.");

                // L√ìGICA DE UNIFICA√á√ÉO POR ADJAC√äNCIA
                if (analysis.length > 0) {
                    let currentGroup = [];
                    for (let i = 0; i < analysis.length; i++) {
                        const currentItem = analysis[i];
                        const previousItem = i > 0 ? analysis[i - 1] : null;

                        if (previousItem && currentItem.retentionScore === previousItem.retentionScore && currentItem.retentionScore !== 'green') {
                            currentGroup.push(currentItem);
                        } else {
                            if (currentGroup.length > 1) {
                                const unifiedSuggestion = currentGroup[0].suggestion;
                                currentGroup.forEach(groupItem => groupItem.suggestion = unifiedSuggestion);
                            }
                            currentGroup = [currentItem];
                        }
                    }
                    if (currentGroup.length > 1) {
                        const unifiedSuggestion = currentGroup[0].suggestion;
                        currentGroup.forEach(groupItem => groupItem.suggestion = unifiedSuggestion);
                    }
                }

                const newParagraphs = paragraphs.map(p => {
                    const newP = p.cloneNode(true);
                    newP.className = '';
                    newP.innerHTML = p.innerHTML.replace(/<div class="retention-tooltip">.*?<\/div>|<button class="retention-action-btn optimize-btn">.*?<\/button>/g, '');
                    p.parentNode.replaceChild(newP, p);
                    return newP;
                });

                analysis.forEach((item, index) => {
                    const p = newParagraphs[item.paragraphIndex]; 
                    if (p) {
                        p.classList.add('retention-paragraph-live', `retention-${item.retentionScore}`);
                        p.dataset.suggestionGroup = item.suggestion;

                        if (item.retentionScore === 'yellow' || item.retentionScore === 'red') {
                            const previousItem = index > 0 ? analysis[index - 1] : null;
                            if (!previousItem || item.suggestion !== previousItem.suggestion) {
                                const scoreLabels = { yellow: "PONTO DE ATEN√á√ÉO", red: "PONTO DE RISCO" };
                                const tooltipTitle = scoreLabels[item.retentionScore] || 'AN√ÅLISE';
                                const buttonHtml = `<button class="optimize-btn" onclick="event.stopPropagation(); window.optimizeGroup(this, '${item.suggestion.replace(/'/g, "\\'")}')">Otimizar Bloco com IA</button>`;
                                const tooltipHtml = `<div class="retention-tooltip"><strong>${tooltipTitle}:</strong> ${item.suggestion}${buttonHtml}</div>`;
                                p.insertAdjacentHTML('beforeend', tooltipHtml);
                            }
                        }
                    }
                });

                newParagraphs.forEach(p => {
                    if (p.dataset.suggestionGroup) {
                        p.addEventListener('mouseover', handleSuggestionMouseOver);
                        p.addEventListener('mouseout', handleSuggestionMouseOut);
                    }
                });

                window.showToast("An√°lise de reten√ß√£o conclu√≠da!");
            } catch (error) {
                window.showToast(`Falha na an√°lise: ${error.message}`);
            } finally {
                hideButtonLoading(button);
            }
        };

/**
         * Pega um par√°grafo, otimiza com IA e substitui seu conte√∫do.
         * (VERS√ÉO CORRIGIDA E ANEXADA AO 'WINDOW')
         */
        window.optimizeParagraph = async (paragraphId, suggestion) => {
            const paragraphElement = document.getElementById(paragraphId);
            if (!paragraphElement) return;

            const button = paragraphElement.querySelector('.retention-action-btn');
            if (button) {
                button.disabled = true;
                button.innerHTML = `<div class="loading-spinner" style="width:16px; height:16px; border-width: 2px;"></div>`;
            }

            const originalText = paragraphElement.firstChild.textContent.trim();
            const languageName = document.getElementById('languageSelect').options[document.getElementById('languageSelect').selectedIndex].text;
            const prompt = `You are an expert copywriter. Rewrite the "Original Paragraph" below based on the "Improvement Suggestion".
        
            **CRITICAL RULE: You MUST respond in ${languageName}.** Do not change the language.

             **Original Paragraph:**
             "${originalText}"

              **Improvement Suggestion:**
               "${suggestion}"

           Respond ONLY with the rewritten paragraph, in ${languageName}.`;

            try {
                const rewrittenText = await callGroqAPI(prompt, 1000);
                paragraphElement.firstChild.textContent = removeMetaComments(rewrittenText);
                
                // Feedback visual
                paragraphElement.classList.remove('retention-yellow', 'retention-red');
                paragraphElement.classList.add('retention-green');
                paragraphElement.querySelector('.retention-tooltip')?.remove();
                button?.remove();
                
                invalidateAndClearPrompts(paragraphElement.closest('.script-section'));
                invalidateAndClearPerformance(paragraphElement.closest('.script-section'));

                window.showToast("Par√°grafo otimizado!");
            } catch (error) {
                window.showToast(`Falha ao otimizar: ${error.message}`);
                if (button) button.innerHTML = '‚ö†Ô∏è'; // √çcone de erro
            }
        };
    
         // ==========================================================
        // >>>>> SUBSTITUA SUA FUN√á√ÉO suggestPerformance INTEIRA POR ESTA VERS√ÉO <<<<<
        // ==========================================================
        window.suggestPerformance = async (button, sectionId) => {
            const sectionElement = document.getElementById(sectionId);
            const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');
            const outputContainer = sectionElement?.querySelector('.section-performance-output');

            if (!contentWrapper || !contentWrapper.textContent.trim() || !outputContainer) {
                window.showToast("Gere o roteiro desta se√ß√£o primeiro.");
                return;
            }

            showButtonLoading(button);
            outputContainer.innerHTML = `<div class="loading-spinner-small mx-auto my-4"></div>`;
            
            try {
                const paragraphElements = Array.from(contentWrapper.querySelectorAll('div[id]'));
                const originalParagraphs = paragraphElements.map(p => p.textContent.trim().replace(/\[.*?\]/g, '').trim());

                if (originalParagraphs.length === 0) { throw new Error("N√£o foram encontrados par√°grafos estruturados para an√°lise."); }

                const batchSize = 15;
                const apiPromises = [];

                for (let i = 0; i < originalParagraphs.length; i += batchSize) {
                    const paragraphBatch = originalParagraphs.slice(i, i + batchSize);
                    let promptContext = '';
                    paragraphBatch.forEach((p, indexInBatch) => {
                        const globalIndex = i + indexInBatch;
                        // N√ÉO precisamos mais do mapa emocional. O prompt √© mais simples.
                        promptContext += `Par√°grafo ${globalIndex}: "${p}"\n\n`;
                    });

                    // >>>>> ESTE √â O NOVO PROMPT, MAIS SIMPLES E INDEPENDENTE <<<<<
                            const prompt = `Voc√™ √© uma API de an√°lise de roteiro. Sua resposta DEVE ser um array JSON.

        **REGRAS DE FORMATA√á√ÉO (INEGOCI√ÅVEIS E ESTRICTAS):**
        1.  Sua resposta final DEVE ser um array JSON v√°lido, come√ßando com \`[\` e terminando com \`]\`.
        2.  Sua resposta N√ÉO PODE conter nenhum texto, coment√°rio ou explica√ß√£o antes ou depois do JSON.
        3.  O array deve conter EXATAMENTE ${paragraphBatch.length} objetos.
        4.  Cada objeto DEVE ter duas chaves: "general_annotation" (uma string) e "emphasis_words" (um array com no m√°ximo 1 string).
        5.  **VERIFICA√á√ÉO FINAL:** Antes de responder, verifique se cada objeto JSON \`{...}\` est√° completamente fechado com sua chave \`}\` antes da pr√≥xima v√≠rgula ou do colchete final \`]\`.

        **EXEMPLO DE RESPOSTA PERFEITA:**
        [
          {
            "general_annotation": "[Tom de surpresa]",
            "emphasis_words": ["inacredit√°vel"]
          },
          {
            "general_annotation": "[Tom de suspense]",
            "emphasis_words": ["segredo"]
          }
        ]

        Analise os ${paragraphBatch.length} par√°grafos a seguir e retorne o array JSON.

        **ROTEIRO (LOTE ATUAL):**
        ${promptContext}`;
                    // Fim do novo prompt

                    apiPromises.push(callGroqAPI(prompt, 3000).then(res => cleanGeneratedText(res, true)));
                }

                const allBatchResults = await Promise.all(apiPromises);
                const annotations = allBatchResults.flat();

                if (!Array.isArray(annotations) || annotations.length !== originalParagraphs.length) { 
                    console.error(`Falha na contagem: JS esperava ${originalParagraphs.length} anota√ß√µes, mas a IA retornou ${annotations ? annotations.length : 0}.`);
                    throw new Error("A IA n√£o retornou o n√∫mero correto de anota√ß√µes ap√≥s juntar os lotes."); 
                }
                
                let annotatedParagraphs = [];
                originalParagraphs.forEach((p, index) => {
                    const annotationData = annotations[index];
                    let annotatedParagraph = p;

                    if (annotationData && annotationData.emphasis_words && Array.isArray(annotationData.emphasis_words) && annotationData.emphasis_words.length > 0) {
                        annotationData.emphasis_words.forEach(word => {
                            const escapedWord = word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                            const wordRegex = new RegExp(`\\b(${escapedWord})\\b`, 'gi');
                            annotatedParagraph = annotatedParagraph.replace(wordRegex, `[√™nfase em '${word}']$1`);
                        });
                    }
                    const finalParagraph = `${annotationData.general_annotation || ''}\n${annotatedParagraph}`;
                    annotatedParagraphs.push(finalParagraph.trim());
                });

                const finalAnnotatedText = annotatedParagraphs.join('\n');
                
                const originalTextForAudit = originalParagraphs.join('\n');
                const { isValid } = auditGeneratedText(originalTextForAudit.replace(/\n/g, ' '), finalAnnotatedText.replace(/\n/g, ' '));

                if (!isValid) { throw new Error("Falha cr√≠tica na auditoria interna. O texto foi corrompido durante a montagem."); }
                
                const highlightedText = finalAnnotatedText.replace(/(\[.*?\])/g, '<span class="text-indigo-500 dark:text-indigo-400 font-semibold italic">$1</span>');

                outputContainer.innerHTML = `
                    <div class="card-background p-4 mt-2 rounded-lg border-l-4 border-indigo-500">
                        <h5 class="font-bold text-sm mb-2 text-gray-700 dark:text-gray-200">Sugest√£o de Performance:</h5>
                        <div class="performance-output-scrollable">
                            <p class="text-gray-800 dark:text-gray-200 leading-relaxed whitespace-pre-wrap">${highlightedText}</p>
                        </div>
                    </div>`;

                if (sectionElement) { invalidateAndClearPrompts(sectionElement); }

            } catch (error) {
                outputContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao sugerir performance: ${error.message}</p>`;
            } finally {
                hideButtonLoading(button);
            }
        };

    
        /**
         * Pega o texto selecionado pelo usu√°rio, pede para a IA reescrev√™-lo com uma analogia/met√°fora,
         * substitui o texto original e invalida a an√°lise anterior. (VERS√ÉO CORRIGIDA)
         * @param {HTMLElement} buttonElement - O bot√£o que foi clicado.
         */
                window.enrichText = async (buttonElement) => {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();

            if (!selectedText) {
                window.showToast("Por favor, selecione primeiro o texto que deseja enriquecer.");
                return;
            }

            showButtonLoading(buttonElement);

            try {
                const prompt = `Voc√™ √© um Mestre Roteirista e poeta. Sua tarefa √© reescrever o "Par√°grafo Original" para incorporar a "Sugest√£o de Melhoria".

                **Par√°grafo Original:**
                "${selectedText}"

                **REGRAS:**
                - Mantenha o n√∫cleo da mensagem intacto.
                - A resposta deve ser APENAS o par√°grafo reescrito. Sem introdu√ß√µes, coment√°rios ou explica√ß√µes.`;

                const rawResult = await callGroqAPI(prompt, 500);
                const enrichedText = removeMetaComments(rawResult);

                if (selection.rangeCount > 0) {
                    document.execCommand('insertHTML', false, `<span class="highlight-change">${enrichedText}</span>`);
                }
                
                const accordionItem = buttonElement.closest('.accordion-item');
                if (accordionItem) {
                    const analysisOutput = accordionItem.querySelector('.section-analysis-output');
                    if (analysisOutput) {
                        const invalidationMessage = `<p class="text-sm text-yellow-500 italic p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md">O texto foi modificado. Por favor, clique em "Analisar Reten√ß√£o" novamente.</p>`;
                        analysisOutput.innerHTML = invalidationMessage;
                    }
                                        
                    const scriptSection = accordionItem.parentElement; 
                    invalidateAndClearPrompts(scriptSection);
                    invalidateAndClearPerformance(accordionItem.closest('.script-section'));
                }

                window.showToast("Texto enriquecido! An√°lise anterior resetada.");

            } catch (error) {
                window.showToast(`Falha ao enriquecer o texto: ${error.message}`);
            } finally {
                hideButtonLoading(buttonElement);
            }
        };

    
        /**
         * Gera e valida ideias de v√≠deo com base no nicho fornecido.
         * (VERS√ÉO COMPLETA E CORRIGIDA COM O LOADING CERTO)
         */
        const generateVideoIdeas = async (button) => {
            const nicheDescription = document.getElementById('nicheDescription').value.trim();
            if (!nicheDescription) {
                window.showToast("Por favor, descreva o nicho do seu canal.");
                return;
            }

            const outputContainer = document.getElementById('ideasOutput');
            outputContainer.innerHTML = `<div class="md:col-span-2 loading-spinner-small mx-auto my-4"></div>`;
            
            // >>>>> MUDAN√áA #1: Usando a nova fun√ß√£o de loading <<<<<
            showButtonLoading(button);

            try {
                const prompt = `Voc√™ √© um Estrategista de Conte√∫do Viral para o YouTube. Sua tarefa √© analisar a descri√ß√£o de um nicho e gerar 6 ideias de v√≠deo com alto potencial de engajamento.

                **Nicho/Descri√ß√£o:** "${nicheDescription}"

                Para cada ideia, voc√™ deve fornecer:
                1.  **title:** Um t√≠tulo "clickbait" mas inteligente (m√°ximo 70 caracteres).
                2.  **angle:** O √¢ngulo ou abordagem √∫nica em uma frase curta (m√°ximo 120 caracteres).
                3.  **targetAudience:** O p√∫blico-alvo espec√≠fico que esta ideia mais atrairia.
                4.  **viralityScore:** Uma nota de 0 a 10 sobre o potencial de viralidade.
                5.  **videoDescription:** Uma descri√ß√£o curta e otimizada para o YouTube.

                Responda APENAS com um array JSON. Cada objeto no array deve conter exatamente as chaves acima.`;

                const rawResult = await callGroqAPI(prompt, 4000);
                const ideas = cleanGeneratedText(rawResult, true);

                outputContainer.innerHTML = ''; 

                ideas.forEach((idea, index) => {
                    const ideaCard = `
                        <div class="card-background p-4 rounded-lg shadow-md border-l-4 border-indigo-500 animate-fade-in flex flex-col justify-between min-h-[140px]">
                            <div>
                                <div class="flex justify-between items-start gap-4">
                                    <h4 class="font-bold text-base text-gray-800 dark:text-gray-200 flex-grow">${index + 1}. ${idea.title}</h4>
                                    <button class="btn btn-primary btn-small flex-shrink-0 py-1 px-3" onclick="window.selectIdea(${escapeIdeaForOnclick(idea)})">
                                        Usar
                                    </button>
                                </div>
                                <p class="text-sm text-gray-500 dark:text-gray-400 italic mt-2">"${idea.angle}"</p>
                            </div>
                            <span class="font-bold text-sm text-indigo-500 bg-indigo-100 dark:bg-indigo-900 dark:text-indigo-300 py-1 px-2 rounded self-start mt-3">
                                Potencial: ${idea.viralityScore} / 10
                            </span>
                        </div>
                    `;
                    outputContainer.innerHTML += ideaCard;
                });

            } catch (error) {
                outputContainer.innerHTML = `<p class="md:col-span-2 text-red-500 text-sm">Falha ao gerar ideias: ${error.message}</p>`;
            } finally {
                // >>>>> MUDAN√áA #2: Usando a nova fun√ß√£o para esconder o loading <<<<<
                hideButtonLoading(button);
            }
        };
    
        /**
         * Preenche os campos do formul√°rio principal com a ideia selecionada.
         * @param {object} idea - O objeto da ideia contendo t√≠tulo, descri√ß√£o, etc.
         */
        window.selectIdea = (idea) => {
            // Usa o objeto 'elements' que j√° mapeamos no in√≠cio para seguran√ßa
            if (elements.videoTheme) elements.videoTheme.value = idea.title;
            if (elements.videoDescription) elements.videoDescription.value = idea.videoDescription;
            if (elements.targetAudience) elements.targetAudience.value = idea.targetAudience;

            // >>>>> A CORRE√á√ÉO EST√Å AQUI <<<<<
            // O ID correto do elemento de navega√ß√£o das abas √© 'inputTabsNav'
            const targetElement = document.getElementById('inputTabsNav');
            if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Usei 'center' para um melhor alinhamento
            }
            
            window.showToast("Ideia selecionada! Agora defina a estrat√©gia completa.");
        };

        

        /**
         * Lida com a gera√ß√£o de uma sec√ß√£o espec√≠fica do roteiro.
         * @param {HTMLElement} button - O bot√£o que acionou a gera√ß√£o.
         * @param {string} sectionName - O nome da sec√ß√£o (ex: 'intro').
         * @param {string} sectionTitle - O t√≠tulo da sec√ß√£o para exibi√ß√£o.
         * @param {string} elementId - O ID do elemento HTML onde o conte√∫do ser√° inserido (ex: 'intro').
         */
        // ==========================================================
        // >>>>> SUBSTITUA SUA FUN√á√ÉO handleGenerateSection POR ESTA <<<<<
        // ==========================================================
        const handleGenerateSection = async (button, sectionName, sectionTitle, elementId) => {
            if (!validateInputs()) return;
            if (!strategicOutline) {
                window.showToast("Crie o Esbo√ßo Estrat√©gico primeiro!");
                return;
            }
            
            showButtonLoading(button);
            
            const targetSectionElement = document.getElementById(`${elementId}Section`);

            // Limpeza pr√©via (c√≥digo existente, permanece igual)
            if (targetSectionElement) {
                const analysisOutput = targetSectionElement.querySelector('.section-analysis-output');
                const performanceOutput = targetSectionElement.querySelector('.section-performance-output');
                if (analysisOutput) analysisOutput.innerHTML = '';
                if (performanceOutput) performanceOutput.innerHTML = '';
            }

            try {
                const keyMap = { intro: 'introduction' };
                const outlineKey = keyMap[sectionName] || sectionName;
                const directive = strategicOutline[outlineKey];
                const { prompt, maxTokens } = constructScriptPrompt(sectionName, sectionTitle, directive);
                
                let rawResult = await callGroqAPI(prompt, maxTokens);
                let cleanedResult = removeMetaComments(rawResult.trim());

                const paragraphs = cleanedResult.split('\n').filter(p => p.trim() !== '');
                const contentWithDivs = paragraphs.map((p, index) => 
                    `<div id="${elementId}-p-${index}">${p}</div>`
                ).join('');
                
                if (targetSectionElement) {
                    const sectionHtml = generateSectionHtmlContent(elementId, sectionTitle, contentWithDivs);
                    targetSectionElement.innerHTML = sectionHtml;

                    // ==========================================================
                    // >>>>> IN√çCIO DA CORRE√á√ÉO CR√çTICA <<<
                    // ==========================================================
                    // N√≥s removemos as classes antigas do placeholder e adicionamos a classe definitiva.
                    targetSectionElement.classList.remove('script-section-placeholder', 'card', 'mb-4');
                    targetSectionElement.classList.add('script-section'); // Garante que a classe exista para os outros listeners
                    // ==========================================================
                    // >>>>> FIM DA CORRE√á√ÉO CR√çTICA <<<
                    // ==========================================================

                    targetSectionElement.querySelector('.accordion-item')?.classList.add('animate-fade-in');
                } else {
                    console.error(`Elemento alvo com ID '${elementId}Section' n√£o encontrado.`);
                    window.showToast("Erro interno: Se√ß√£o do roteiro n√£o encontrada.");
                    return;
                }
                
                markButtonAsCompleted(button.id);
                updateButtonStates();

            } catch (error) {
                window.showToast(`Falha ao gerar ${sectionTitle}: ${error.message}`);
                console.error(`Error generating ${sectionTitle}.`, error);
            } finally {
                hideButtonLoading(button);
            }
        };





        /**
         * Re-gera o conte√∫do de uma sec√ß√£o espec√≠fica do roteiro.
         * @param {string} sectionName - O nome da sec√ß√£o (ex: 'intro').
         * @param {string} sectionTitle - O t√≠tulo da sec√ß√£o.
         * @param {string} elementId - O ID do elemento HTML da sec√ß√£o.
         */
        // ==========================================================
// FUN√á√ÉO DE RE-GERA√á√ÉO CORRIGIDA
// ==========================================================
window.regenerateSection = (fullSectionId) => {
            const sectionName = fullSectionId.replace('Section', '');
            
            const sectionMap = {
                'intro': { title: 'Introdu√ß√£o', elementId: 'intro' },
                'development': { title: 'Desenvolvimento', elementId: 'development' },
                'climax': { title: 'Cl√≠max', elementId: 'climax' },
                'conclusion': { title: 'Conclus√£o e CTA', elementId: 'conclusion' }
            };

            const sectionInfo = sectionMap[sectionName];
            
            if (sectionInfo) {
                // Encontra o bot√£o de re-gerar que foi clicado, em vez de um bot√£o antigo
                const button = document.querySelector(`[data-action='regenerate'][data-section-id='${fullSectionId}']`);
                if (button) {
                     handleGenerateSection(button, sectionName, sectionInfo.title, sectionInfo.elementId);
                } else {
                    console.error(`Bot√£o de re-gerar n√£o encontrado para a se√ß√£o: ${fullSectionId}`);
                }
            } else {
                console.error(`Informa√ß√µes da se√ß√£o n√£o encontradas para: ${sectionName}`);
            }
        };



        /**
         * Gera um prompt por par√°grafo em lotes e depois aplica curadoria.
         * (VERS√ÉO CORRIGIDA COM ARGUMENTOS ALINHADOS)
         */
        window.generatePromptsForSection = async (button, sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            const contentWrapper = sectionElement?.querySelector('.generated-content-wrapper');
            const promptContainer = sectionElement?.querySelector('.prompt-container');
            
            if (!contentWrapper || !contentWrapper.textContent.trim() || !promptContainer) {
                window.showToast("Gere o conte√∫do do roteiro desta se√ß√£o primeiro.");
                return;
            }

            if (!window.emotionalMap || window.emotionalMap.length === 0) {
                window.showToast("Gere o Mapa Emocional primeiro na aba 'Roteiro' para criar prompts contextuais.");
                return;
            }

            showButtonLoading(button);
            promptContainer.innerHTML = `<div class="loading-spinner-small mx-auto my-4"></div>`;
            
            try {
                const paragraphElements = Array.from(contentWrapper.querySelectorAll('div[id]'));
                const originalParagraphs = paragraphElements.map(p => p.textContent.trim().replace(/\[.*?\]/g, '').trim());

                if (originalParagraphs.length === 0) {
                    throw new Error("N√£o foram encontrados par√°grafos estruturados para an√°lise.");
                }

                const firstParagraphId = paragraphElements[0]?.id;
                const baseIndexMatch = firstParagraphId?.match(/-p-(\d+)$/);
                const baseIndex = baseIndexMatch ? parseInt(baseIndexMatch[1], 10) : 0;

                const batchSize = 10;
                const apiPromises = [];

                for (let i = 0; i < originalParagraphs.length; i += batchSize) {
                    const paragraphBatch = originalParagraphs.slice(i, i + batchSize);
                    let promptContext = '';
                    paragraphBatch.forEach((p, indexInBatch) => {
                        const globalIndex = i + indexInBatch;
                        const mapIndex = baseIndex + globalIndex;
                        const emotionalContext = window.emotionalMap[mapIndex] || { emotion: 'Neutro', pace: 'Normal' };
                        promptContext += `Par√°grafo ${globalIndex}: "${p}"\nContexto (Emo√ß√£o: ${emotionalContext.emotion}, Ritmo: ${emotionalContext.pace})\n\n`;
                    });
                    
                    const prompt = `Voc√™ √© um Diretor de Fotografia que transforma texto em cenas. Sua tarefa √© criar um objeto JSON para CADA UM dos ${paragraphBatch.length} par√°grafos no lote abaixo.\n\nREGRAS DE FORMATA√á√ÉO (INEGOCI√ÅVEIS):\n1.  Sua resposta DEVE ser um array JSON contendo EXATAMENTE ${paragraphBatch.length} objetos.\n2.  Cada objeto DEVE corresponder a um par√°grafo do lote, na mesma ordem.\n3.  Cada objeto deve ter as chaves: "scriptPhrase" (o texto exato do par√°grafo), "imageDescription" (uma descri√ß√£o visual para a cena), e "estimated_duration" (uma estimativa em segundos).\n\nN√ÉO RESUMA. CRIE UM OBJETO PARA CADA PAR√ÅGRAFO.\n\nAnalise o lote a seguir e gere o array JSON.\n\nROTEIRO (LOTE ATUAL):\n---\n${promptContext}\n---`;
                    
                    apiPromises.push(callGroqAPI(prompt, 4000).then(res => cleanGeneratedText(res, true)));
                }

                const allBatchResults = await Promise.all(apiPromises);
                const allGeneratedPrompts = allBatchResults.flat();

                if (!Array.isArray(allGeneratedPrompts) || allGeneratedPrompts.length < originalParagraphs.length) {
                     console.error(`Falha na contagem de prompts: JS esperava ${originalParagraphs.length}, IA retornou ${allGeneratedPrompts.length}.`);
                    throw new Error("A IA n√£o retornou um prompt para cada par√°grafo.");
                }
                
                const desiredSecondsPerScene = 15;
                let curatedPrompts = [];
                let secondsAccumulator = 0;
                let currentScenePhrase = "";

                allGeneratedPrompts.forEach((promptData, index) => {
                    if (!promptData || !promptData.scriptPhrase) return;
                    const duration = parseInt(promptData.estimated_duration, 10) || 5;
                    currentScenePhrase += promptData.scriptPhrase + " ";
                    secondsAccumulator += duration;
                    if (secondsAccumulator >= desiredSecondsPerScene || index === allGeneratedPrompts.length - 1) {
                        let finalPrompt = { ...promptData };
                        finalPrompt.scriptPhrase = currentScenePhrase.trim();
                        finalPrompt.estimated_duration = secondsAccumulator;
                        curatedPrompts.push(finalPrompt);
                        currentScenePhrase = "";
                        secondsAccumulator = 0;
                    }
                });
                
                allImagePrompts[sectionElementId] = curatedPrompts.map((p) => ({ ...p, styleBlock: CINEMATIC_STYLE_BLOCK }));
                promptPaginationState[sectionElementId] = 0;
                
                promptContainer.innerHTML = `
                    <div class="prompt-pagination-wrapper space-y-4">
                        <div class="prompt-nav-container flex items-center justify-center gap-4"></div>
                        <div class="prompt-items-container space-y-4"></div>
                    </div>
                `;
                renderPaginatedPrompts(sectionElementId);

            } catch (error) {
                 promptContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar prompts: ${error.message}</p>`;
            } finally {
                hideButtonLoading(button);
            }
        };



    
        /**
         * Sugere trilhas sonoras para uma sec√ß√£o espec√≠fica do roteiro.
         * @param {string} sectionId - O ID do elemento HTML da sec√ß√£o (ex: 'introSection').
         */
        window.suggestSoundtrack = async (sectionId) => {
            const sectionElement = document.getElementById(sectionId);
            const scriptContent = sectionElement.querySelector('.generated-content-wrapper').textContent; 
            const soundtrackContainer = sectionElement.querySelector('.soundtrack-container');
            
            if (!scriptContent) {
                window.showToast("Gere o roteiro para esta sec√ß√£o primeiro.");
                return;
            }

            soundtrackContainer.innerHTML = `<div class="loading-spinner-small"></div>`; 

            const prompt = `Voc√™ √© um especialista em prompts para IAs de gera√ß√£o de m√∫sica (como Suno/Udio). Sua tarefa √© analisar o seguinte trecho de roteiro e criar 3 prompts de texto distintos e detalhados.

            **REGRAS DE FORMATA√á√ÉO (N√ÉO NEGOCI√ÅVEIS):**1.  Sua resposta DEVE SER um array JSON v√°lido.2.  O array deve conter EXATAMENTE 3 strings.3.  CADA string deve ser um par√°grafo √∫nico, bem escrito e descritivo, pronto para ser colado em uma IA de m√∫sica. N√ÉO use chaves, colchetes ou qualquer outra sintaxe de objeto DENTRO da string do prompt.

            **EXEMPLO DE RESPOSTA PERFEITA:**
            ["Generate an epic, cinematic orchestral piece in the style of Hans Zimmer... No vocals or percussion, focus on the emotional intensity of the strings and piano.","Create a contemplative, melancholic ambient track with a slow, mournful tempo... No bright or cheerful notes, focus on the darker, more introspective tones.","Craft an uplifting, inspirational electronic piece with a moderate tempo... avoid any jarring or harsh sounds, focusing on the soaring, inspirational quality of the melody."
            ]

                Agora, use o roteiro abaixo como inspira√ß√£o para criar 3 prompts seguindo EXATAMENTE este formato.

            Trecho do roteiro para analisar:
                    ---
                ${scriptContent}

                ---`;
            
            try {
                const rawResult = await callGroqAPI(prompt, 500);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const suggestions = JSON.parse(cleanedResult);

                // Adiciona tratamento de erro para garantir que suggestions √© um array de strings
                if (!Array.isArray(suggestions) || !suggestions.every(s => typeof s === 'string')) {
                    throw new Error("A IA retornou um formato de trilha sonora inesperado. Esperava um array de strings.");
                }

                soundtrackContainer.innerHTML = ''; // Limpa o spinner
                if (suggestions && suggestions.length > 0) {
                    // Agora envolvemos a lista em um div com as classes corretas para ter um fundo e padding.
                    let suggestionsHtml = '<div class="card-background p-4 rounded-lg shadow-inner">';
                    suggestionsHtml += '<ul class="soundtrack-list">';
                    suggestions.forEach(suggestion => {
                        suggestionsHtml += `<li>${suggestion}</li>`;
                    });
                    suggestionsHtml += '</ul>';
                    suggestionsHtml += '</div>'; 

                    soundtrackContainer.innerHTML = suggestionsHtml;
                } else {
                    soundtrackContainer.innerHTML = '<p class="text-gray-500 text-sm">Nenhuma sugest√£o de trilha sonora foi gerada.</p>';
                }
            } catch (error) {
                soundtrackContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao gerar sugest√µes: ${error.message}</p>`;
            }
        };

        /**
         * Copia a transcri√ß√£o para a √°rea de transfer√™ncia e
         * inicia o download de um arquivo .rtf limpo e com a codifica√ß√£o correta.
         */
        const handleCopyAndDownloadTranscript = () => {
            const transcriptText = getTranscriptOnly();

            if (!transcriptText) {
                window.showToast("Nenhum roteiro para copiar. Gere as se√ß√µes primeiro.");
                return;
            }

            copyTextToClipboard(transcriptText);
            window.showToast("Transcri√ß√£o copiada! Download do arquivo .rtf iniciado.");

            const fileName = (document.getElementById('videoTheme').value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro') + '_transcricao.rtf';
            
            // **A CORRE√á√ÉO EST√Å AQUI:**
            // 1. Escapa o texto para o formato RTF.
            // 2. Substitui as quebras de linha pelo comando de par√°grafo do RTF.
            const safeText = escapeRtf(transcriptText);
            const rtfContent = `{\\rtf1\\ansi\\deff0 {\\fonttbl{\\f0 Arial;}}\\f0\\fs24 ${safeText.replace(/\n/g, '\\par\r\n')}}`;
            
            const blob = new Blob([rtfContent], { type: 'application/rtf' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        };
    
        /**
         * Gera t√≠tulos de v√≠deo e ideias de thumbnail.
         */
                const generateTitlesAndThumbnails = async (button) => {
            if (!validateInputs()) return;
            showButtonLoading(button);

            try {
                const { prompt, maxTokens } = constructScriptPrompt('titles_thumbnails');
                
                const finalPrompt = prompt + `\n\nCRITICAL RULE: Inside the 'description' strings, you MUST use single quotes ('') for any internal quotes, or properly escape double quotes (\\\"). Failure to do so will result in an invalid JSON. Example: "A text overlay that says 'Hope is Here'".`;
                
                const result = await callGroqAPI(finalPrompt, maxTokens);
                const cleanedResult = cleanGeneratedText(result, true);
                
                if (!cleanedResult) {
                    throw new Error("A IA n√£o retornou um JSON v√°lido.");
                }
                
                const parsedContent = cleanedResult;
                generatedTitlesAndThumbnails = parsedContent;

                const targetContentElement = document.getElementById('titlesThumbnailsContent');
                if (targetContentElement) {
                    const titlesListHtml = parsedContent.titles.map((title, index) => `<p>${index + 1}. ${title}</p>`).join('');
                    const thumbnailsListHtml = parsedContent.thumbnails.map((thumb, index) => `
                        <div class="${index === 0 ? '' : 'thumbnail-item-separator'}"> 
                            <p class="font-semibold">"${thumb.title}"</p>
                            <p class="text-sm leading-tight">Descri√ß√£o: ${thumb.description}</p>
                        </div>
                    `).join('');

                    targetContentElement.innerHTML = `
                        <div class="space-y-4 text-sm">
                            <div>
                                <h4 class="font-bold text-base mb-2">Sugest√µes de T√≠tulos:</h4>
                                <div class="p-3 card-background rounded-md space-y-2">${titlesListHtml}</div>
                                <div class="mt-3">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeTitles()">Analisar CTR</button>
                                    <div id="ctrAnalysisResult" class="mt-3"></div>
                                </div>
                            </div>
                            <div>
                                <h4 class="font-bold text-base mb-2">Ideias de Thumbnail:</h4>
                                <div class="p-3 card-background rounded-md space-y-3">${thumbnailsListHtml}</div>
                                <div class="mt-3">
                                    <button class="btn btn-secondary btn-small" onclick="window.analyzeThumbnails()">Analisar Thumbnails</button>
                                    <div id="thumbnailAnalysisResult" class="mt-3"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    markButtonAsCompleted(button.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar T√≠tulos: ${error.message}`);
                console.error("Error generating Titles/Thumbnails.", error);
            } finally {
                hideButtonLoading(button);
                updateButtonStates();
            }
        };

        /**
         * Analisa o potencial de clique (CTR) dos t√≠tulos gerados.
         */
        window.analyzeTitles = async () => {
            if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.titles || generatedTitlesAndThumbnails.titles.length === 0) {
                window.showToast("Gere os t√≠tulos primeiro!");
                return;
            }

            const resultContainer = document.getElementById('ctrAnalysisResult');
            resultContainer.innerHTML = `<div class="loading-spinner-small"></div>`;

            const titlesString = generatedTitlesAndThumbnails.titles.join('\n');
            
            const prompt = `Voc√™ √© um especialista em marketing de conte√∫do para o YouTube. Analise a seguinte lista de t√≠tulos de v√≠deo. Para cada um, forne√ßa uma "nota de CTR" de 0 a 10 (onde 10 √© um clique quase garantido) e uma sugest√£o curta e objetiva para melhor√°-lo, focando em curiosidade, urg√™ncia e benef√≠cio claro.

            Responda APENAS com um array JSON. Cada objeto no array deve ter as chaves "titulo_original", "nota_ctr" e "sugestao_melhora".

            T√≠tulos para analisar:
            ---
            ${titlesString}
            ---`;

            try {
                const rawResult = await callGroqAPI(prompt, 2000);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const analysis = cleanedResult;

                let analysisHtml = '<div class="space-y-4">';
                analysis.forEach(item => {
                    // --- IN√çCIO DA CORRE√á√ÉO NA RENDERIZA√á√ÉO ---
                    analysisHtml += `
                        <div class="p-3 card-background rounded-md shadow-sm">
                            <p class="font-semibold text-gray-800 dark:text-gray-200">${item.titulo_original}</p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de CTR:</strong> <span class="text-indigo-500 font-bold">${item.nota_ctr} / 10</span></p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugest√£o:</strong> ${item.sugestao_melhora}</p>
                        </div>
                    `;


            // --------------------------------------
                    // --- FIM DA CORRE√á√ÉO NA RENDERIZA√á√ÉO ---
            // --------------------------------------



                });
                analysisHtml += '</div>';
                resultContainer.innerHTML = analysisHtml;

            } catch (error) {
                resultContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao analisar os t√≠tulos: ${error.message}</p>`;
            }
        };

        /**
         * Analisa o potencial de clique (CTR) das ideias de thumbnail geradas.
         */
        window.analyzeThumbnails = async () => {
            if (!generatedTitlesAndThumbnails || !generatedTitlesAndThumbnails.thumbnails || generatedTitlesAndThumbnails.thumbnails.length === 0) {
                window.showToast("Gere as ideias de thumbnail primeiro!");
                return;
            }

            const resultContainer = document.getElementById('thumbnailAnalysisResult');
            resultContainer.innerHTML = `<div class="loading-spinner-small"></div>`;

            const thumbnailsString = generatedTitlesAndThumbnails.thumbnails.map(t => `T√≠tulo: ${t.title}, Descri√ß√£o: ${t.description}`).join('\n---\n');
            
            // --- IN√çCIO DA CORRE√á√ÉO NO PROMPT ---
            const prompt = `Voc√™ √© um Diretor de Arte e especialista em YouTube. Analise a seguinte lista de ideias para thumbnails. Para cada uma, forne√ßa uma "nota de potencial visual" de 0 a 10 (onde 10 √© uma imagem irresist√≠vel) e uma sugest√£o curta para maximizar o impacto visual, focando em contraste, emo√ß√£o facial, clareza e curiosidade.

            Responda APENAS com um array JSON. Cada objeto no array deve ter as chaves "titulo", "nota_visual" e "sugestao_melhora". A chave "titulo" DEVE conter o t√≠tulo original da ideia que voc√™ analisou.

            Ideias para analisar:
            ---
            ${thumbnailsString}
            ---`;
            // --- FIM DA CORRE√á√ÉO NO PROMPT ---

            try {
                const rawResult = await callGroqAPI(prompt, 2500);
                const cleanedResult = cleanGeneratedText(rawResult, true);
                const analysis = cleanedResult;

                let analysisHtml = '<div class="space-y-4">';
                analysis.forEach(item => {
                    // --- IN√çCIO DA CORRE√á√ÉO NA RENDERIZA√á√ÉO ---
                    analysisHtml += `
                        <div class="p-3 card-background rounded-md shadow-sm">
                            <p class="font-semibold text-gray-800 dark:text-gray-200">"${item.titulo || 'Ideia Sem T√≠tulo'}"</p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Nota de Potencial Visual:</strong> <span class="text-indigo-500 font-bold">${item.nota_visual} / 10</span></p>
                            <p class="text-sm mt-1 text-gray-600 dark:text-gray-400"><strong>Sugest√£o:</strong> ${item.sugestao_melhora}</p>
                        </div>
                    `;
                    // --- FIM DA CORRE√á√ÉO NA RENDERIZA√á√ÉO ---
                });
                analysisHtml += '</div>';
                resultContainer.innerHTML = analysisHtml;

            } catch (error) {
                resultContainer.innerHTML = `<p class="text-red-500 text-sm">Falha ao analisar as thumbnails: ${error.message}</p>`;
            }
        };
        /**
         * Gera a descri√ß√£o do v√≠deo e hashtags.
         */
                const generateVideoDescription = async (button) => {
            if (!validateInputs()) return;
            showButtonLoading(button);

            try {
                let result = await callGroqAPI(constructScriptPrompt('description').prompt, constructScriptPrompt('description').maxTokens);
                result = cleanGeneratedText(result, false);
                result = removeMetaComments(result);
                
                const targetContentElement = document.getElementById('videoDescriptionContent');
                if (targetContentElement) {
                    targetContentElement.innerHTML = `<div class="p-3 text-sm card-background rounded-md whitespace-pre-wrap">${result}</div>`;
                    markButtonAsCompleted(button.id);
                }
            } catch (error) {
                window.showToast(`Falha ao gerar Descri√ß√£o: ${error.message}`);
                console.error("Error generating Video Description.", error);
            } finally {
                hideButtonLoading(button);
                updateButtonStates();
            }
        };

        // ==========================================================
        // >>>>> SUBSTITUA O BLOCO try DA SUA FUN√á√ÉO generateStrategicOutline POR ESTE <<<<<
        // ==========================================================
        const generateStrategicOutline = async (button) => {
            if (!validateInputs()) return;
            
            showButtonLoading(button);
            
            const outlineContentDiv = document.getElementById('outlineContent'); // Corrigido para buscar o elemento aqui
            if (outlineContentDiv) {
                outlineContentDiv.innerHTML = `<div class="loading-spinner-small mx-auto"></div>`;
            } else {
                window.showToast("Erro: Container do esbo√ßo n√£o encontrado.");
                hideButtonLoading(button);
                return;
            }

            try {
                const { prompt, maxTokens } = constructScriptPrompt('outline', 'Esbo√ßo Estrat√©gico');
                const rawResult = await callGroqAPI(prompt, maxTokens);
                
                strategicOutline = cleanGeneratedText(rawResult, true);

                if (!strategicOutline || typeof strategicOutline !== 'object') {
                    console.error("A IA retornou um esbo√ßo em formato inv√°lido:", rawResult);
                    throw new Error("A IA falhou em gerar um esbo√ßo v√°lido.");
                }

                const titleTranslations = {
                    'introduction': 'Introdu√ß√£o',
                    'development': 'Desenvolvimento',
                    'climax': 'Cl√≠max',
                    'conclusion': 'Conclus√£o',
                    'cta': 'CTA'
                };
                
                let outlineHtml = '<ul class="space-y-4 text-sm">';
                for (const key in strategicOutline) {
                    if (Object.hasOwnProperty.call(strategicOutline, key)) {
                        const translatedTitle = titleTranslations[key] || (key.charAt(0).toUpperCase() + key.slice(1));
                        let contentText = strategicOutline[key] || '';
                        
                        outlineHtml += `
                            <li>
                                <div>
                                    <strong class="text-indigo-600 dark:text-indigo-400">${translatedTitle}:</strong>
                                    <span class="text-gray-600 dark:text-gray-300">${contentText}</span>
                                </div>
                            </li>
                        `;
                    }
                }
                outlineHtml += '</ul>';
                
                outlineContentDiv.innerHTML = outlineHtml;
                markButtonAsCompleted(button.id);

                // ==========================================================
                // >>>>> IN√çCIO DA CORRE√á√ÉO <<<
                // Esta √© a l√≥gica que faltava!
                // ==========================================================
                const scriptContainer = document.getElementById('scriptSectionsContainer');
                if (scriptContainer) {
                    // Limpa qualquer conte√∫do antigo e prepara para os placeholders
                    scriptContainer.innerHTML = ''; 

                    // Cria os placeholders para cada se√ß√£o do roteiro
                    scriptContainer.innerHTML += createScriptSectionPlaceholder('intro', 'Introdu√ß√£o', 'generateIntroBtn');
                    scriptContainer.innerHTML += createScriptSectionPlaceholder('development', 'Desenvolvimento', 'generateDevelopmentBtn');
                    scriptContainer.innerHTML += createScriptSectionPlaceholder('climax', 'Cl√≠max', 'climaxBtn');
                    scriptContainer.innerHTML += createScriptSectionPlaceholder('conclusion', 'Conclus√£o e CTA', 'conclusionBtn');
                    
                    // Nota: O bot√£o de CTA agora pode ser o mesmo da Conclus√£o, simplificando a UI.
                    // A fun√ß√£o 'generateConclusionAndCta' j√° lida com os dois.
                }
                // ==========================================================
                // >>>>> FIM DA CORRE√á√ÉO <<<
                // ==========================================================


            } catch (error) {
                window.showToast(`Falha ao gerar Esbo√ßo: ${error.message}`);
                console.error("Error generating Outline.", error);
                if (outlineContentDiv) {
                    outlineContentDiv.innerHTML = `<div class="asset-card-placeholder text-red-500">Erro ao gerar o esbo√ßo. Tente novamente.</div>`;
                }
            } finally {
                hideButtonLoading(button);
                updateButtonStates();
            }
        };


        /**
         * Realiza o download do roteiro como PDF.
         */
        const downloadPdf = async () => {
            // 1. Criar um container tempor√°rio para a impress√£o
            let printContainer = document.createElement('div');
            printContainer.id = 'print-container';

            // 2. Coletar e formatar TODO o conte√∫do que queremos imprimir
            let htmlToPrint = `<h1 style="text-align: center; font-size: 22pt; margin-bottom: 24px;">${elements.videoTheme.value}</h1>`;

            // Adicionar o esbo√ßo estrat√©gico
            if (strategicOutline) {
                const titleTranslations = {
                    'introduction': 'Introdu√ß√£o',
                    'development': 'Desenvolvimento',
                    'climax': 'Cl√≠max',
                    'conclusion': 'Conclus√£o',
                    'cta': 'CTA'
                };
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Esbo√ßo Estrat√©gico</div>
                        <div class="print-section-content">
                            <ul style="list-style-type: disc; padding-left: 20px;">`;
                for (const key in strategicOutline) {
                    const translatedTitle = titleTranslations[key] || (key.charAt(0).toUpperCase() + key.slice(1));
                    htmlToPrint += `<li><strong>${translatedTitle}:</strong> ${strategicOutline[key]}</li>`;
                }
                htmlToPrint += `</ul></div></div>`;
            }

            // Adicionar o roteiro principal
            document.querySelectorAll('#scriptSectionsContainer .accordion-item').forEach(item => {
                const title = item.querySelector('h3')?.textContent;
                const content = item.querySelector('.generated-content-wrapper')?.textContent;
                if (title && content) {
                    htmlToPrint += `
                        <div class="print-section">
                            <div class="print-section-title">${title}</div>
                            <div class="print-section-content"><pre>${content}</pre></div>
                        </div>`;
                }
            });
            
            // Adicionar Descri√ß√£o e Hashtags
            const videoDescriptionContent = document.getElementById('videoDescriptionContent');
            if (videoDescriptionContent && videoDescriptionContent.textContent.trim() !== 'Clique em \'Gerar\' para ver a descri√ß√£o') {
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">Descri√ß√£o & Hashtags</div>
                        <div class="print-section-content">${videoDescriptionContent.innerHTML}</div>
                    </div>`;
            }

            // Adicionar T√≠tulos e Thumbnails
            const titlesThumbnailsContent = document.getElementById('titlesThumbnailsContent');
            if (titlesThumbnailsContent && titlesThumbnailsContent.textContent.trim() !== 'Clique em \'Gerar\' para ver as sugest√µes') {
                htmlToPrint += `
                    <div class="print-section">
                        <div class="print-section-title">T√≠tulos & Thumbnails</div>
                        <div class="print-section-content">${titlesThumbnailsContent.innerHTML}</div>
                    </div>`;
            }

            // 3. Injetar o HTML no container e adicion√°-lo ao body
            printContainer.innerHTML = htmlToPrint;
            document.body.appendChild(printContainer);

            // 4. Chamar a impress√£o
            window.print();

            // 5. Remover o container tempor√°rio ap√≥s a impress√£o (com um pequeno atraso para garantir a renderiza√ß√£o)
            setTimeout(() => {
                document.body.removeChild(printContainer);
            }, 500); // 500ms de atraso
        };

        /**
         * Reseta o estado da aplica√ß√£o para um novo roteiro. (VERS√ÉO CORRIGIDA E RECONSTRUTIVA)
         */
        const resetApplicationState = () => {
            // Fun√ß√£o para resetar um elemento de forma segura
            const safeReset = (elementId, value = '') => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.value = value;
                }
            };

            // Reseta todos os inputs para seus valores padr√£o de forma segura
            safeReset('channelName', 'The Biblical Unveiling');
            safeReset('videoTheme');
            safeReset('videoDescription');
            safeReset('targetAudience', 'Pessoas Interessadas em Arqueologia B√≠blica e Hist√≥ria Antiga, Crist√£os e Pessoas de F√©, Entusiastas de Ci√™ncia e Ceticismo (com mente aberta), Curiosos em Geral e Amantes de Mist√©rios.');
            safeReset('languageSelect', 'en');
            safeReset('videoObjective', 'informar');
            safeReset('videoDuration', '');
            safeReset('speakingPace', 'moderate');
            
            safeReset('narrativeGoal', 'storytelling');
            updateNarrativeStructureOptions();
            
            safeReset('narrativeTheme');
            safeReset('narrativeTone', 'inspirador');
            safeReset('narrativeVoice');
            
            safeReset('centralQuestion');
            safeReset('emotionalArc');
            safeReset('shockingEndingHook');
            safeReset('imageDescriptionEngine');
            safeReset('imageStyleSelect', 'cinematic');
            safeReset('customImageStyle');
            toggleCustomImageStyleVisibility();
            
            const nicheDesc = document.getElementById('nicheDescription');
            const ideasOut = document.getElementById('ideasOutput');
            if (nicheDesc) nicheDesc.value = '';
            if (ideasOut) ideasOut.innerHTML = '';

            strategicOutline = null;
            allImagePrompts = {};
            generatedTitlesAndThumbnails = null;
            totalScriptSeconds = 0;
            promptPaginationState = {}; // Reset pagination state

            // ==========================================================
            // A CORRE√á√ÉO CR√çTICA EST√Å AQUI
            // ==========================================================
            const contentContainers = [
                'scriptSectionsContainer', 'outlineContent', 
                'titlesThumbnailsContent', 'videoDescriptionContent'
            ];
            contentContainers.forEach(id => {
                const container = document.getElementById(id);
                if (container) {
                    if (id === 'scriptSectionsContainer') {
                        // RECONSTR√ìI os placeholders em vez de apenas limpar
                        container.innerHTML = `
                            <div id="introSection" class="script-section"></div>
                            <div id="developmentSection" class="script-section"></div>
                            <div id="climaxSection" class="script-section"></div>
                            <div id="conclusionSection" class="script-section"></div>
                            <div id="ctaSection" class="script-section hidden"></div> 
                        `;
                    } else if (id === 'outlineContent') {
                        container.innerHTML = `<div class="asset-card-placeholder">Clique em 'Criar Esbo√ßo' para a IA planejar a estrutura do roteiro.</div>`;
                    } else if (id === 'titlesThumbnailsContent') {
                        container.innerHTML = `<div class="asset-card-placeholder">Clique em 'Gerar' para ver as sugest√µes</div>`;
                    } else if (id === 'videoDescriptionContent') {
                        container.innerHTML = `<div class="asset-card-placeholder">Clique em 'Gerar' para ver a descri√ß√£o</div>`;
                    } else {
                        container.innerHTML = '';
                    }
                }
            });
            // ==========================================================
            // FIM DA CORRE√á√ÉO
            // ==========================================================

            document.querySelectorAll('.section-analysis-output, .section-performance-output').forEach(output => {
                output.innerHTML = '';
            });

            resetCompletionIcons();
            updateProgressBar();
            
            if (elements.projectDashboard) {
                 elements.projectDashboard.classList.add('hidden');
            }

            window.showToast("Pronto para um novo roteiro!");
            window.scrollTo({ top: 0, behavior: 'smooth' });
        };

        /**
         * Exporta o estado atual do projeto para um ficheiro JSON.
         */
        const exportProject = () => {
            const projectData = {
                inputs: {},
                outputs: {},
                memory: {
                    allImagePrompts: allImagePrompts,
                    generatedTitlesAndThumbnails: generatedTitlesAndThumbnails,
                    strategicOutline: strategicOutline, // Exporta o esbo√ßo
                    promptPaginationState: promptPaginationState // Export pagination state
                }
            };

            // Salva o estado dos inputs
            for (const key in elements) {
                if (elements[key] && typeof elements[key].value !== 'undefined') {
                    projectData.inputs[key] = elements[key].value;
                }
            }
            // Salva o conte√∫do gerado (HTML interno das sec√ß√µes)
            const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection']; // CTA is now part of conclusionSection
            scriptSectionIds.forEach(id => {
                const sectionElement = document.getElementById(id);
                if (sectionElement) {
                    projectData.outputs[id] = sectionElement.innerHTML;
                }
            });

            // Salva o conte√∫do do esbo√ßo
            projectData.outputs.strategicOutlineContent = elements.outlineContent.innerHTML;

            // Salva o conte√∫do dos cart√µes de recursos
            projectData.outputs.titlesThumbnailsContent = document.getElementById('titlesThumbnailsContent').innerHTML;
            projectData.outputs.videoDescriptionContent = document.getElementById('videoDescriptionContent').innerHTML;
            // Removed storyboardContent export
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(projectData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            const fileName = elements.videoTheme.value.trim().replace(/[^a-zA-Z0-9]/gi, '_').toLowerCase() || 'roteiro_viral';
            downloadAnchorNode.setAttribute("download", `${fileName}_projeto.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            document.body.removeChild(downloadAnchorNode);
            downloadAnchorNode.remove();
            window.showToast("Projeto exportado com sucesso!");
        };

        /**
         * Renderiza os prompts de imagem para uma sec√ß√£o espec√≠fica na UI.
         * Usado ap√≥s carregar um projeto.
         * @param {string} sectionElementId - O ID do elemento HTML da sec√ß√£o.
         */
        const renderImagePromptsForSection = (sectionElementId) => {
            const sectionElement = document.getElementById(sectionElementId);
            if (!sectionElement) return;

            const promptContainer = sectionElement.querySelector('.prompt-container');
            if (!promptContainer) return;

            // Re-cria a estrutura de pagina√ß√£o se ela n√£o existir
            if (!promptContainer.querySelector('.prompt-pagination-wrapper')) {
                promptContainer.innerHTML = `
                    <div class="prompt-pagination-wrapper space-y-4">
                        <div class="prompt-nav-container flex items-center justify-center gap-4">
                            <!-- Controles de navega√ß√£o ser√£o inseridos aqui -->
                        </div>
                        <div class="prompt-items-container space-y-4">
                            <!-- Os 4 prompts da p√°gina atual ser√£o inseridos aqui -->
                        </div>
                    </div>
                `;
            }

            // Renderiza a p√°gina atual de prompts
            renderPaginatedPrompts(sectionElementId);
        };

        /**
         * Importa um projeto de um ficheiro JSON.
         * @param {Event} event - O evento de mudan√ßa do input de ficheiro.
         */
        const importProject = (event) => {
            const file = event.target.files[0];
            if (!file) { return; }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const projectData = JSON.parse(e.target.result);
                    
                    resetApplicationState();

                    // Restaura os inputs
                    const inputIds = [
                        'channelName', 'videoTheme', 'videoDescription', 'targetAudience', 
                        'languageSelect', 'videoObjective', 'videoDuration', 'speakingPace', 
                        'narrativeGoal', 'narrativeStructure', 'narrativeTheme', 'narrativeTone', 
                        'narrativeVoice', 'centralQuestion', 'emotionalArc', 'shockingEndingHook', 'imageDescriptionEngine', 
                        'imageStyleSelect', 'customImageStyle'
                    ];
                    inputIds.forEach(id => {
                        const element = document.getElementById(id);
                        if (element && projectData.inputs[id] !== undefined) {
                            element.value = projectData.inputs[id];
                        }
                    });
                    
                    // Atualiza os dropdowns da narrativa
                    updateNarrativeStructureOptions();
                    const structureSelect = document.getElementById('narrativeStructure');
                    if (structureSelect && projectData.inputs['narrativeStructure']) {
                        structureSelect.value = projectData.inputs['narrativeStructure'];
                        // Ensure the tooltip is updated after setting the structure value
                        updateMainTooltip();
                    }

                    // Restaura o conte√∫do gerado
                    const outputIds = [
                        'introSection', 'developmentSection', 'climaxSection', 'conclusionSection', // CTA is now part of conclusionSection
                        'outlineContent', 'titlesThumbnailsContent', 'videoDescriptionContent'
                    ];
                    outputIds.forEach(id => {
                        const element = document.getElementById(id);
                        if (element && projectData.outputs[id]) {
                            element.innerHTML = projectData.outputs[id]; 
                        }
                    });
                    
                    strategicOutline = projectData.memory.strategicOutline || null;
                    allImagePrompts = projectData.memory.allImagePrompts || {};
                    generatedTitlesAndThumbnails = projectData.memory.generatedTitlesAndThumbnails || null;
                    promptPaginationState = projectData.memory.promptPaginationState || {}; // Load pagination state

                    // Renderiza os prompts de imagem paginados ap√≥s carregar
                    const scriptSectionIds = ['introSection', 'developmentSection', 'climaxSection', 'conclusionSection'];
                    scriptSectionIds.forEach(id => {
                        if (allImagePrompts[id] && allImagePrompts[id].length > 0) {
                            renderImagePromptsForSection(id);
                        }
                    });

                    updateButtonStates();
                    
                    if (elements.outlineContent.textContent.trim().length > 100) markButtonAsCompleted('generateOutlineBtn');
                    if (document.getElementById('introSection').innerHTML.trim()) markButtonAsCompleted('generateIntroBtn');
                    if (document.getElementById('developmentSection').innerHTML.trim()) markButtonAsCompleted('generateDevelopmentBtn');
                    if (document.getElementById('climaxSection').innerHTML.trim()) markButtonAsCompleted('climaxBtn');
                    if (document.getElementById('conclusionSection').innerHTML.trim()) markButtonAsCompleted('conclusionBtn');
                    if (document.getElementById('videoDescriptionContent').innerHTML.includes('Hashtags')) markButtonAsCompleted('generateDescriptionBtn');
                    if (document.getElementById('titlesThumbnailsContent').innerHTML.includes('Analisar CTR')) markButtonAsCompleted('generateTitlesAndThumbnailsBtn');

                    reNumberAllScenes();
                    updateProgressBar(); 
                    
                    elements.projectDashboard.classList.remove('hidden');
                    window.showToast("Projeto importado com sucesso!");

                } catch (err) {
                    window.showToast("Erro: Ficheiro de projeto inv√°lido ou corrompido.");
                    console.error("Erro ao importar projeto:", err);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        };

        // =========================================================================
        // PASSO 2: SUBSTITUA A FUN√á√ÉO analyzeAndSetStrategy INTEIRA POR ESTA
        // =========================================================================
        const analyzeAndSetStrategy = async (button) => {
            // Verifica se j√° existe conte√∫do gerado para pedir confirma√ß√£o
            if (document.querySelector('#scriptSectionsContainer .accordion-item')) {
                const userConfirmed = await showConfirmationDialog("Redefinir Estrat√©gia?", "Isso limpar√° todo o roteiro e metadados j√° gerados. Deseja continuar?");
                if (!userConfirmed) return;
            }
            
            resetProjectOutputs(); 

            const theme = document.getElementById('videoTheme')?.value.trim();
            const description = document.getElementById('videoDescription')?.value.trim();
            if (!theme || !description) {
                window.showToast("Preencha o Tema e a Descri√ß√£o do V√≠deo.");
                return;
            }
            
            showButtonLoading(button);
            isSettingStrategy = true;
            
            // Pega as op√ß√µes dispon√≠veis para guiar a IA
            const objectiveOptions = Array.from(document.getElementById('videoObjective').options).map(o => `'${o.value}'`).join(', ');
            const toneOptions = Array.from(document.getElementById('narrativeTone').options).map(o => `'${o.value}'`).join(', ');
            const languageStyleOptions = Array.from(document.getElementById('languageStyle').options).map(o => `'${o.value}'`).join(', ');
            const speakingPaceOptions = Array.from(document.getElementById('speakingPace').options).map(o => `'${o.value}'`).join(', ');

            // >>>>> PROMPT CORRIGIDO E MAIS COMPLETO <<<<<
            const prompt = `Voc√™ √© um Estrategista de Conte√∫do de IA. Analise o tema e a descri√ß√£o de um v√≠deo e defina a melhor estrat√©gia de conte√∫do.

            **Tema do V√≠deo:** "${theme}"
            **Descri√ß√£o:** "${description}"

            Responda APENAS com um objeto JSON v√°lido. Siga estritamente as regras para cada uma das seguintes chaves:
            1.  "target_audience": Descreva em uma frase o p√∫blico-alvo principal.
            2.  "narrative_goal": Determine se a abordagem √© 'storytelling' ou 'storyselling'.
            3.  "narrative_structure": Se 'storytelling', escolha entre 'documentary', 'heros_journey', 'mystery_loop'. Se 'storyselling', escolha entre 'underdog_victory', 'pas', 'bab'.
            4.  "narrative_theme": Defina a "grande ideia" em poucas palavras.
            5.  "narrative_tone": Escolha o tom emocional. O valor DEVE ser um dos seguintes: [${toneOptions}].
            6.  "narrative_voice": Defina a "persona" do narrador (Ex: S√°bio e experiente, En√©rgico e divertido).
            7.  "central_question": Formule a pergunta central que o roteiro deve responder.
            8.  "emotional_arc": Descreva o arco emocional do espectador (Ex: Curiosidade -> Tens√£o -> Surpresa).
            9.  "language_style": Escolha o estilo de linguagem. O valor DEVE ser um dos seguintes: [${languageStyleOptions}].
            10. "video_objective": Escolha o objetivo principal. O valor DEVE ser um dos seguintes: [${objectiveOptions}].
            11. "speaking_pace": Escolha o ritmo de fala. O valor DEVE ser um dos seguintes: [${speakingPaceOptions}].
            12. "image_description_engine": Sugira 3 a 5 palavras-chave visuais (Ex: fotorrealista, sombrio, cinematogr√°fico).
            `;

            try {
                const rawResult = await callGroqAPI(prompt, 2000);
                const strategy = cleanGeneratedText(rawResult, true);

                if (!strategy || typeof strategy !== 'object') {
                    throw new Error("A IA n√£o retornou uma resposta em formato JSON v√°lido.");
                }
                
                // Mapeia a resposta da IA para os campos do formul√°rio
                const keyToElementIdMap = {
                    'target_audience': 'targetAudience',
                    'narrative_goal': 'narrativeGoal',
                    'narrative_structure': 'narrativeStructure',
                    'narrative_theme': 'narrativeTheme',
                    'narrative_tone': 'narrativeTone',
                    'narrative_voice': 'narrativeVoice',
                    'central_question': 'centralQuestion',
                    'emotional_arc': 'emotionalArc',
                    'language_style': 'languageStyle',
                    'video_objective': 'videoObjective',
                    'speaking_pace': 'speakingPace',
                    'image_description_engine': 'imageDescriptionEngine'
                };

                for (const key in keyToElementIdMap) {
                    if (strategy[key]) {
                        const element = document.getElementById(keyToElementIdMap[key]);
                        if (element) {
                            element.value = strategy[key];
                        }
                    }
                }
                
                updateNarrativeStructureOptions(); // Atualiza as estruturas narrativas ap√≥s definir o objetivo
                // Garante que o valor da estrutura seja definido AP√ìS as op√ß√µes serem populadas
                const structureSelect = document.getElementById('narrativeStructure');
                if (structureSelect && strategy.narrative_structure) {
                    structureSelect.value = strategy.narrative_structure;
                }

                const dashboard = document.getElementById('projectDashboard');
                if (dashboard) dashboard.classList.remove('hidden');
                
                document.querySelector('[data-tab="input-tab-estrategia"]')?.click();
                window.showToast("Estrat√©gia definida com sucesso!");
            } catch (error) {
                window.showToast(`Falha ao definir estrat√©gia: ${error.message}`);
                console.error("Erro na an√°lise estrat√©gica:", error);
            } finally {
                isSettingStrategy = false;
                hideButtonLoading(button);
                updateButtonStates();
            }
        };

// ==========================================================
// >>>>> SUBSTITUA SEU EVENT LISTENER INTEIRO POR ESTE <<<<<
// ==========================================================
document.addEventListener('DOMContentLoaded', () => {
     // >>>>> ADICIONE ESTE BLOCO AQUI <<<<<
     // Mapeia todos os elementos e bot√µes para os objetos globais
     document.querySelectorAll('[id]').forEach(el => {
         if (el.tagName === 'BUTTON') {
             buttons[el.id] = el;
         } else {
             elements[el.id] = el;
         }
     });

    // ---- 1. INICIALIZA√á√ÉO GERAL ----
    setupInputTabs();
    setupTabs();
    updateProgressBar();
    updateButtonStates();
    updateNarrativeStructureOptions();

    // ---- 2. EVENTOS DIRETOS EM ELEMENTOS ESPEC√çFICOS ----
    document.getElementById('importFileInput')?.addEventListener('change', importProject);
    
    document.getElementById('darkModeToggle')?.addEventListener('click', () => {
        document.body.classList.toggle('dark');
        const isDarkMode = document.body.classList.contains('dark');
        document.getElementById('moonIcon').classList.toggle('hidden', isDarkMode);
        document.getElementById('sunIcon').classList.toggle('hidden', !isDarkMode);
        localStorage.setItem('darkMode', isDarkMode ? 'enabled' : 'disabled');
    });

    if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark');
        document.getElementById('moonIcon')?.classList.add('hidden');
        document.getElementById('sunIcon')?.classList.remove('hidden');
    }

    document.getElementById('toggleZenModeBtn')?.addEventListener('click', () => document.body.classList.toggle('zen-mode'));
    document.getElementById('exitZenModeBtn')?.addEventListener('click', () => document.body.classList.remove('zen-mode'));
    document.getElementById('imageStyleSelect')?.addEventListener('change', toggleCustomImageStyleVisibility);
    
    document.querySelectorAll('input[name="conclusionType"]').forEach(radio => {
        radio.addEventListener('change', handleConclusionStrategyChange);
    });
    
    const speakingPaceSelect = document.getElementById('speakingPace');
    if (speakingPaceSelect) {
        speakingPaceSelect.addEventListener('change', updateAllReadingTimes);
    }

    // ---- 3. EVENTOS DE INPUT PARA INVALIDA√á√ÉO ----
    document.addEventListener('input', (event) => {
        if (event.target.matches('.generated-content-wrapper[contenteditable="true"]')) {
            const sectionElement = event.target.closest('.script-section');
            if (sectionElement) {
                invalidateAndClearPrompts(sectionElement);
                invalidateAndClearPerformance(sectionElement);
            }
        }
    });

    let hideDetailsTimeout;
    document.getElementById('scriptSectionsContainer').addEventListener('mouseover', (event) => {
        const paragraph = event.target.closest('.retention-paragraph-live');
        if (!paragraph || !paragraph.dataset.suggestion) return;
        clearTimeout(hideDetailsTimeout);
        const sectionId = paragraph.closest('.script-section').id;
        const detailsArea = document.getElementById(`analysis-output-${sectionId.replace('Section', '')}`);
        if (!detailsArea) return;
        const score = paragraph.dataset.score;
        const suggestion = paragraph.dataset.suggestion;
        const scoreLabels = { green: "Ponto Forte", yellow: "Ponto de Aten√ß√£o", red: "Ponto de Risco" };
        const scoreColors = { green: "green-500", yellow: "yellow-400", red: "red-500" };
        let buttonHtml = (score === 'yellow' || score === 'red') ? `<button class="btn btn-secondary btn-small" data-action="optimize-paragraph" data-paragraph-id="${paragraph.id}">Otimizar com IA</button>` : '';
        detailsArea.innerHTML = `<div class="retention-details-card border-l-${scoreColors[score]}"><strong class="text-${scoreColors[score]}">${scoreLabels[score]}</strong><p>${suggestion}</p>${buttonHtml}</div>`;
        detailsArea.classList.remove('hidden');
    });

    document.getElementById('scriptSectionsContainer').addEventListener('mouseout', (event) => {
        const paragraph = event.target.closest('.retention-paragraph-live');
        if (paragraph) {
            const sectionId = paragraph.closest('.script-section').id;
            const detailsArea = document.getElementById(`analysis-output-${sectionId.replace('Section', '')}`);
            if (detailsArea && !detailsArea.classList.contains('hidden')) {
                hideDetailsTimeout = setTimeout(() => {
                    detailsArea.classList.add('hidden');
                    detailsArea.innerHTML = '';
                }, 300);
            }
        }
    });

    document.addEventListener('mouseover', (event) => {
        if (event.target.closest('.section-analysis-output')) {
            clearTimeout(hideDetailsTimeout);
        }
    });

        // =========================================================================
        // PASSO 2: SUBSTITUA SEU "GERENTE DE CLIQUES" INTEIRO POR ESTE BLOCO FINAL
        // =========================================================================
        document.addEventListener('click', function(event) {
            const target = event.target;
            const button = target.closest('button');

            // --- L√≥gica do Acorde√£o (CORRIGIDA) ---
            const accordionHeader = target.closest('.accordion-header');
            if (accordionHeader) {
                // Previne que o clique nos bot√µes de a√ß√£o dispare o acorde√£o
                if (!target.closest('.header-buttons')) {
                    const body = accordionHeader.nextElementSibling;
                    const arrow = accordionHeader.querySelector('.accordion-arrow');
                    if (body && arrow) {
                        body.classList.toggle('open');
                        arrow.classList.toggle('open');
                    }
                }
            }

            // --- L√≥gica dos Bot√µes de A√ß√£o (data-action) ---
            if (button && button.dataset.action) {
                event.preventDefault();
                const action = button.dataset.action;
                if (action === 'regenerate') { window.regenerateSection(button.dataset.sectionId); return; }
                if (action === 'copy') {
                    const content = button.closest('.accordion-item')?.querySelector('.generated-content-wrapper');
                    if (content) { window.copyTextToClipboard(content.textContent); window.showCopyFeedback(button); }
                    return;
                }
                if (action === 'generate-prompts') { window.generatePromptsForSection(button, button.dataset.sectionId); return; }
            }

            // --- L√≥gica dos Bot√µes Principais (por ID) ---
            if (button) {
                const clickActions = {
                    'analyzeStrategyBtn': () => analyzeAndSetStrategy(button),
                    'generateOutlineBtn': () => generateStrategicOutline(button),
                    'mapEmotionsBtn': () => mapEmotionsAndPacing(button),
                    'generateDescriptionBtn': () => generateVideoDescription(button),
                    'generateTitlesAndThumbnailsBtn': () => generateTitlesAndThumbnails(button),
                    'generateSoundtrackBtn': () => generateSoundtrack(button),
                    'generateIntroBtn': () => handleGenerateSection(button, 'intro', 'Introdu√ß√£o', 'intro'),
                    'generateDevelopmentBtn': () => handleGenerateSection(button, 'development', 'Desenvolvimento', 'development'),
                    'climaxBtn': () => handleGenerateSection(button, 'climax', 'Cl√≠max', 'climax'),
                    'conclusionBtn': () => handleGenerateSection(button, 'conclusion', 'Conclus√£o e CTA', 'conclusion'),
                    'generateIdeasBtn': () => generateVideoIdeas(button),
                };
                if (clickActions[button.id]) {
                    event.preventDefault();
                    clickActions[button.id]();
                }
            }
        });




    // ---- 5. L√ìGICA PARA RESETAR ROTEIRO ----
    const strategicInputIds = [
        'videoTheme', 'videoDescription', 'videoDuration', 'speakingPace', 'narrativeGoal',
        'narrativeStructure', 'narrativeTheme', 'narrativeTone', 'narrativeVoice',
        'centralQuestion', 'emotionalArc', 'shockingEndingHook', 'imageDescriptionEngine', 'imageStyleSelect'
    ];

    strategicInputIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            const eventType = (element.tagName === 'SELECT' || element.tagName === 'TEXTAREA') ? 'change' : 'input';
            element.addEventListener(eventType, (e) => {
                if (!isSettingStrategy) {
                    resetGeneratedScriptContent(e.target.id);
                }
            });
        }
    });

    // ---- 6. EVENTO DE SCROLL PARA BARRA FLUTUANTE ----
    window.addEventListener('scroll', window.handleFloatingActionBar);
});

</script>
</body>
</html>